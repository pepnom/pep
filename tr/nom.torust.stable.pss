
#*

ABOUT 

  Translate nom scripts to the rust language. This uses the 
  new script organisation from /tr/nom.tolua.pss. This script can 
  compile itself with

  * create a nom-to-rust translator executable and test
  -----
   pep -f tr/nom.torust.pss tr/nom.torust.pss > nomtorust.rs
   rustc -o nomtorust.exe nomtorust.rs
   echo "read;print;print;clear;" | ./nomtorust.exe > test.rs
   rustc -o test.exe test.rs
   echo "abcd" | ./test.exe
   # prints aabbccdd
  ,,,,

  The above is the remarkable process of translating the translator
  and using the translated translator (nomtorust.exe) to translate 
  a nom script to rust.

  * Even more remarkable: 3rd generation testing 
  -----
   pep -f tr/nom.torust.pss tr/nom.torust.pss > nomtorust.rs
   rustc nomtorust.rs
   cat tr/nom.torust.pss | ./nomtorust > nomtorust3gen.rs
   rustc  nomtorust3gen.rs
   cat eg/text.tohtml.pss | ./nomtorust3gen > texttohtml.rs 
   rustc texttohtml.rs
   cat index.txt | ./texttohtml > index.html
   # create an html file from a 'plain text format'
  ,,,,

  The code above creates a "3rd generation" executable nom-to-rust
  translator and then uses it to translate the html formatter into
  rust and then compile it. Then it generate an html page with the 
  formatter. Pretty amazing, no? I am not sure if 3rd generation 
  executables have any practical purpose, apart from testing the 
  translator.

  This is a nom script that converts nom scripts to the rust 
  language. The output is a "stand-alone" rust program with no
  crate dependencies (that will change when the code is modified
  to read grapheme clusters and not unicode code-points).  

STATUS 

  12 may 2025
    all first gen tests are working and all 2nd gen seem to be 
    working as well. 

BUGS AND ISSUES

  escape '\\'; doesn't seem to work in the translator. I probably need
  to think more about this because it seems a tricky self referential 
  problem.

  This uses a reversed input buffer because buffer.pop() to get the 
  next char in the buffer is fast and easy. A character iterator 
  would be much better but it is really tricky in rust to do this because
  you need to have lifetime parameters everywhere and when you reassign
  the iterator (when the input buffer changes) you have to make sure 
  that lifetimes match etc. Too hard for me.

  But a reversed input buffer is not a good idea for unicode because
  of grapheme clusters and ligatures etc.

  rust considers this: \x a numeric escape char so it wont allow
  me to do self.work.push_str("\x\\x") etc. Need to think of a way around this.

  Also "\a" fails because it is an "unknown character escape"

SOLVED BUGS

  Escaping \\ in single quoted text was doing strange things.

HISTORY

  14 may 2025
    converting to a reversed vector of strings instead
    of a String inputBuffer. This will allow grapheme clusters 
    to work and still allow pop() to process the vector.
  12 may 2025
    got 2nd gen tests working. working on file input output and tests.
  8 may 2025
    all first gen tests are working. 
  5 may 2025
    more work, read seems to work now.
  4 may 2025
    lots of work. some commands are working with stdin. Not read
    or until; etc.
  1 may 2025
    just started converting. I will base this on the translation
    script /tr/nom.tolua.pss because that is the most complete 
    translation script so far.

NOTES

  This rust translator is now the most complete translator script
  of all (may 2025) and will be used to do automatic translations into other 
  languages using some AI engine.

  The input buffer is currently reversed because then I can just
  use pop() to consume one char at a time. 

  For InputType::Stdin input I will just read all of stdin and 
  the same with "file" and "string" input. InputType::FileStream
  and StdinStream will read one line at a time into the inputBuffer

  See /tr/nom.todart.pss for info about this new translation
  script organisation.

  https://www.regular-expressions.info/unicode.html#category
    important unicode regexp info for different languages. The 
    unicode script names and properties which are included here 
    were copied from this website. These are used for classes in
    tests and while/whilenot. Some class tests can be implemented
    with a matchClass function which may be faster.

  There are various input "types" meaning where the input comes 
  from and if it is a stream or just all read at once into a buffer.

UNICODE CATEGORIES

  Does rust support these categories?, here is a list.

  Apparently \P{L} (capital P) is the inverse set, ie any non-letter.
  But \p{L} does not match grapheme clusters, see below for that.

UNICODE SCRIPT NAMES

  Information from regular-expressions.info/unicode.html#script
  A surprising useful website.

  The JGsoft engine, Perl, PCRE, PHP, Ruby 1.9, Delphi can match Unicode scripts. 

UNICODE BLOCKS

  I would like for nom to support all these categories, scripts and 
  blocks if the target translation language supports them. But in 
  some cases it may be better for the translator to create 'ascii' 
  regular expressions for the sake of speed.

RUST SYNTAX
  
  The rust borrow checker can be tricky, as well as "lifetimes" which
  all are necessary because there is no garbage collector in rust.

DONE

  second gen tests.
  test file and string input output. 

TODO


  unicode character categories? no.

TESTING 

  Have tested non trivial  scripts such as /eg/nom.syntax.reference.pss
  /eg/palindrome.pss and /eg/xml.parse.pss and they all seem to work.

  Using the bash functions in nomsf://helpers.pars.sh you can do.

  * compile an inline nom script to rust and display
  >> pep.rus 'r;t;t;d;'  

  * compile an inline nom script to rust and run with input
  >> pep.rus 'r;t;t;d;' 'abcd'   

  These bash functions are just to save typing when translating nom
  scripts to rust. Here is the equivalent
  without them:

  * translate an inline script to rust and print to stdout 
  >> pep -f nom.torust.pss -i "r;[\n]{lines;add ' ';}print;d;"

  * test with the one-line nom scripts in /tr/translate.test.txt 
  >> pep.tt rust

  * test but start at swap tests 
  >> pep.tt rust blah '# swap'

TOKENS 

 This token list is pretty useful for thinking about 
 sequences of tokens. Especially for error sequences.

  Literal BE!<>{}(),.;
  quoted*  text between "" or ''.  I will put "" around this and escape
           all " at the time of tokenising. This is because I want \n \r
           etc to work within strings. But it means I have to be careful
           about other escape sequences. like $ etc. 
  class*   eg [:space:] [abcd] [a-z] 
  word*    eg: eof,reparse,==
  begin*   the begin word
  parselabel* 
  command* eg: add clear print 
  test*    eg: "x" [:space:] !B"a" B"a" E"a" !E"a"
  ortest*  test*,*test*
  andtest*  test*.*test*
  statement* eg: clear; add "xx"; or "test" { ... }
  statementset* a list of statements 
  script*

*#

  read;

  # sort-of line-relative character numbers 
  [\n] { nochars; }
  # ignore space except in quotes. but be careful about silent
  # exit on read at eof
  [:space:] { 
     clear; (eof) { .reparse } !(eof) { .restart } 
  }

  # literal tokens, for readability maybe 'dot*' and 'comma*'
  [<>}()!BE,.;] { put; add "*"; push; .reparse }
  [{] { 
    # line and char number to help with missing close brace 
    # errors
    clear;
    add "line:"; lines; add " char:"; chars;
    put; clear; add "{*"; push; .reparse
  }

  # parse (eof) etc as tokens? yes

  # command names, need to do some tricks to parse ++ -- a+ etc
  # here. This is because [:alpha:],[+-] etc is not a union set
  # and while cannot do "while [:alpha:],[+-] etc

  # subtle bug, [+-^0=] parses as a range!!! [a-z]
  [:alpha:],[-+^0=] {

    # a much more succint abbreviation code
    "0" { clear; add "zero"; }
    "^" { clear; add "escape"; }
    # increment tape pointer ++ command
    "+" { while [+]; }
    # decrement tape pointer -- command
    "-" { while [-]; }
    # tape test (==)
    "=" { while [=]; }

    # for better error messages dont read ahead for the 
    # above commands.
    !"zero".!"escape".!B"+".!B"-".!B"=" {
      while [:alpha:]; 
    }

    # parse a+ or a- for the accumulator
    "a" { 
      # while [+-] is bug because compile.pss thinks its a range class
      # not a list class
      while [-+]; "a+","a-" { put; }
      "a" { clear; add "add"; }
    }

    # one letter command abbreviation expansions.
    # 'D' doesn't actually work in compile.pss !
    put; clear; add "#"; get; add "#";
    replace "#k#" "#clip#"; replace "#K#" "#clop#";
    replace "#D#" "#replace#"; replace "#d#" "#clear#"; 
    replace "#t#" "#print#"; replace "#p#" "#pop#"; replace "#P#" "#push#"; 
    replace "#u#" "#unstack#"; replace "#U#" "#stack#"; replace "#G#" "#put#"; 
    replace "#g#" "#get#"; replace "#x#" "#swap#"; replace "#m#" "#mark#"; 
    replace "#M#" "#go#"; replace "#r#" "#read#"; replace "#R#" "#until#"; 
    replace "#w#" "#while#"; replace "#W#" "#whilenot#"; replace "#n#" "#count#"; 
    replace "#c#" "#chars#"; replace "#C#" "#nochars#"; replace "#l#" "#lines#"; 
    replace "#L#" "#nolines#"; replace "#v#" "#unescape#"; 
    replace "#z#" "#delim#"; 
    replace "#S#" "#state#"; replace "#q#" "#quit#"; replace "#s#" "#write#"; 
    replace "#o#" "#nop#"; replace "#rs#" "#restart#"; replace "#rp#" "#reparse#"; 

    # remove leading/trailing #
    clip; clop; put;

    # dont want to use this syntax anymore because we already have
    # lines and 'l' or chars and 'c'
    "ll","cc" { 
      clear;
      add '* The syntax "'; get; add '" for lines or chars';
      add "  is no longer valid.\n";
      add "  use 'chars' or 'c' for a character count \n";
      add "  use 'lines' or 'l' for a line count \n";
      put; clear; add "nom.error*"; push; .reparse
    }

    "+","-" { 
      clear;
      add '* This syntax "'; get; add '" which were 1 letter abbreviations\n';
      add "  are no longer valid because.\n";
      add "  it is silly to have 1 letter abbrevs for 2 letter commands.";
      put; clear; add "nom.error*"; push; .reparse
    }

    # writefile is also a command?
    # commands parsed above
    "a+","a-","zero","++","--",
    "add","clip","clop","replace","upper","lower","cap","clear",
    "print","state","pop","push","unstack","stack","put","get","swap",
    "mark","go","read","until","while","whilenot",
    "count","zero","chars","lines","nochars","nolines",
    "escape","unescape","echar","delim","quit","write","nop" {
      clear; add "command*"; push; .reparse
    }

    # words not commands == was parsed above
    "parse","reparse","restart","eof","EOF","==" {
      put; clear; add "word*"; push; .reparse
    }

    "begin" { put; add "*"; push; .reparse }

    # lower case and check for command with error
    lower; 
    "add","clip","clop","replace","upper","lower","cap","clear",
    "print","state","pop","push","unstack","stack","put","get","swap",
    "mark","go","read","until","while","whilenot",
    "count","zero","chars","lines","nochars","nolines",
    "escape","unescape","echar","delim","quit", "write",
    "zero","++","--","a+","a-","nop",
    "begin","parse","reparse","restart" {
      ++; put; --;
      clear; 
      add '* incorrect command "'; get; add '"\n'; 
      add '- all nom commands and words are lower case \n';
      add '  (except for EOF and abbreviations) \n';
      add "- did you mean '"; ++; get; --; add "'?";

      put; clear; add "nom.error*"; push; .reparse
    }

    clear; add '* unknown word or command "'; get; add '"'; 
    add "

    - Valid nom commands are: 

    add clip clop replace upper lower cap clear 
    print state pop push unstack stack put get swap 
    mark go read until while whilenot 
    count zero chars lines nochars nolines 
    escape unescape delim quit write (writefile ?) 
    zero ++ -- a+ a- nop 
    
    - Valid nom words are 

    parse reparse restart begin eof EOF == 

    see www.nomlang.org/doc/commands/ \n";
    
    put; 
    clear; add "nom.error*"; push; .reparse
  }

  # single line comments
  # no need to rethink
  '#' {
    (eof) { clear; .reparse }
    read; 
    # just delete empty comments
    [#\n] { clear; .reparse }
    # multiline comments this needs to go within '#'
    "#*" {
      # save the start line number for error messages
      clear; 
      add "line:"; lines; add " char:"; chars; put; clear; 
      until "*#"; 
      !E"*#" { 
        clear; add '* unterminated multiline comment #*... \n  starting at '; 
        get; put; clear; add "nom.error*"; push; .reparse
      }
      clip; clip; put; clear;
      add "comment*"; push; .reparse 
    }
    clear; whilenot [\n]; put; 
    clear; add "comment*"; push; .reparse
  }

  # quoted text 
  # I will double quote all text and escape $ and \\ 
  # double quotes are for strings and single for chars in rust
  '"' {
    # save the start line number (for error messages) in case 
    # there is no terminating quote character.
    clear; 
    add "line:"; lines; add " char:"; chars; put; clear; 
    until '"'; 
    !E'"',(eof) { 
      clear; add '* unterminated quote (") or incomplete command starting at '; 
      get; put; clear; add "nom.error*"; push; .reparse
    }
    # empty quotes are checked later. must escape \\ first 
    clip; unescape '"'; 
    # escape "\\"; 
    # escape "$"; 
    escape '"'; put; 
    clear; add '"'; get; add '"'; put; 
    clear; add "quoted*"; push; .reparse 
  }

  # single quotes
  "'" {
    clear; 
    # save start line/char of "'" for error messages
    add "line:"; lines; add " char:"; chars; put; clear; 
    until "'"; 
    !E"'",(eof) { 
      clear; add '* unterminated quote (\') or incomplete command starting at '; 
      put; clear; add "nom.error*"; push; .reparse
    }
    # empty quotes are checked later . must escape "\\" first 
    clip; unescape "'"; 
    # not sure about escaping this. It is causing problems with 2nd gen
    # escape "\\"; 
    escape '"'; 
    put; 
    clear; add '"'; get; add '"'; put; 
    clear; add "quoted*"; push; .reparse 
  }

  # classes like [:space:] or [abc] or [a-z] 
  # these are used in tests and also in while/whilenot
  # The *until* command will read past 'escaped' end characters eg \]
  # 

  "[" {
    clear; 
    # just leave brackets eg [:etc:]
    # save start line/char of '[' for error messages
    add "line:"; lines; add " char:"; chars; put; clear; 
    until "]"; 
    !E"]",(eof) { 
      clear; 
      add '* unterminated class [...] or incomplete command starting at '; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clip; put; 
    
    B":".E":".!":".!"::" { 
      clip; clop; put;
      # no nom class abbreviations, Unicode categories already have many
      # abbreviations, I will use those. I would like to accept any unicode
      # script/block/category but can't unless I want to code them.

      # these are ctype classes 

      "alnum","alpha","ascii","word","blank",
      "cntrl","digit","graph","lower","print",
      "punct","space","upper","xdigit" {
        # these will all be handled by the Machine.matchClass() method
        # because is will all be changed by grapheme clusters and 
        # by using unicode rust crates ?
        clear; add "[:"; get; add ":]"; put; 
        clear; add "class*"; push; .reparse 
      }

     # unicode category names, the first is an abbreviation of the 
     # second. It would be good to allow all lower case etc.

     # allow writing spaces or dots instead of _  This is ok because 
     # unicode script names dont have spaces or dots in them.
     replace " " "_"; replace "." "_"; 
     "L","Letter","Ll","Lowercase_Letter","Lu","Uppercase_Letter",
     "Lt","Titlecase_Letter","L&","Cased_Letter","Lm","Modifier_Letter",
     "Lo","Other_Letter","M","Mark","Mn","Non_Spacing_Mark",
     "Mc","Spacing_Combining_Mark","Me","Enclosing_Mark",
     "Z","Separator","Zs","Space_Separator","Zl","Line_Separator",
     "Zp","Paragraph_Separator","S","Symbol","Sm","Math_Symbol",
     "Sc","Currency_Symbol","Sk","Modifier_Symbol","So","Other_Symbol",
     "N","Number","Nd","Decimal_Digit_Number","Nl","Letter_Number",
     "No","Other_Number","P","Punctuation","Pd","Dash_Punctuation",
     "Ps","Open_Punctuation","Pe","Close_Punctuation","Pi","Initial_Punctuation",
     "Pf","Final_Punctuation","Pc","Connector_Punctuation","Po",
     "Other_Punctuation","C","Other","Cc","Control","Cf","Format",
     "Co","Private_Use","Cs","Surrogate","Cn","Unassigned" {
       add ":
         This nom->rust translator does not currently support unicode character 
         category names in nom classes. You could try the nom->dart
         translator if you really need them:
           nomlang.org/tr/nom.todart.pss \n";
       put; clear; add "nom.error*"; push; .reparse
     }

      # unicode script names, 
      "Common","Arabic","Armenian","Bengali","Bopomofo",
      "Braille","Buhid","Canadian_Aboriginal","Cherokee",
      "Cyrillic","Devanagari","Ethiopic","Georgian","Greek",
      "Gujarati","Gurmukhi","Han","Hangul","Hanunoo",
      "Hebrew","Hiragana","Inherited","Kannada","Katakana",
      "Khmer","Lao","Latin","Limbu","Malayalam","Mongolian",
      "Myanmar","Ogham","Oriya","Runic","Sinhala","Syriac",
      "Tagalog","Tagbanwa","TaiLe","Tamil","Telugu","Thaana",
      "Thai","Tibetan","Yi" {
        add ":
         This nom->rust translator does not currently support unicode script 
         names in nom classes. You could try the nom->dart
         translator if you really need them:
           nomlang.org/tr/nom.todart.pss \n";
        put; clear; add "nom.error*"; push; .reparse
      }

      # blocks

      # unicode block names. not supported 
      "InBasic_Latin","InLatin-1_Supplement","InLatin_Extended-A",
      "InLatin_Extended-B","InIPA_Extensions","InSpacing_Modifier_Letters",
      "InCombining_Diacritical_Marks","InGreek_and_Coptic","InCyrillic",
      "InCyrillic_Supplementary","InArmenian","InHebrew","InArabic",
      "InSyriac","InThaana","InDevanagari","InBengali","InGurmukhi",
      "InGujarati","InOriya","InTamil","InTelugu","InKannada",
      "InMalayalam","InSinhala","InThai","InLao","InTibetan","InMyanmar",
      "InGeorgian","InHangul_Jamo","InEthiopic","InCherokee",
      "InUnified_Canadian_Aboriginal_Syllabics","InOgham","InRunic",
      "InTagalog","InHanunoo","InBuhid","InTagbanwa","InKhmer",
      "InMongolian","InLimbu","InTai_Le","InKhmer_Symbols",
      "InPhonetic_Extensions","InLatin_Extended_Additional",
      "InGreek_Extended","InGeneral_Punctuation",
      "InSuperscripts_and_Subscripts","InCurrency_Symbols",
      "InCombining_Diacritical_Marks_for_Symbols","InLetterlike_Symbols",
      "InNumber_Forms","InArrows","InMathematical_Operators",
      "InMiscellaneous_Technical","InControl_Pictures",
      "InOptical_Character_Recognition","InEnclosed_Alphanumerics",
      "InBox_Drawing","InBlock_Elements","InGeometric_Shapes",
      "InMiscellaneous_Symbols","InDingbats",
      "InMiscellaneous_Mathematical_Symbols-A","InSupplemental_Arrows-A",
      "InBraille_Patterns","InSupplemental_Arrows-B",
      "InMiscellaneous_Mathematical_Symbols-B",
      "InSupplemental_Mathematical_Operators",
      "InMiscellaneous_Symbols_and_Arrows","InCJK_Radicals_Supplement",
      "InKangxi_Radicals","InIdeographic_Description_Characters",
      "InCJK_Symbols_and_Punctuation","InHiragana","InKatakana",
      "InBopomofo","InHangul_Compatibility_Jamo","InKanbun",
      "InBopomofo_Extended","InKatakana_Phonetic_Extensions",
      "InEnclosed_CJK_Letters_and_Months","InCJK_Compatibility",
      "InCJK_Unified_Ideographs_Extension_A","InYijing_Hexagram_Symbols",
      "InCJK_Unified_Ideographs","InYi_Syllables","InYi_Radicals",
      "InHangul_Syllables","InHigh_Surrogates",
      "InHigh_Private_Use_Surrogates","InLow_Surrogates",
      "InPrivate_Use_Area","InCJK_Compatibility_Ideographs",
      "InAlphabetic_Presentation_Forms","InArabic_Presentation_Forms-A",
      "InVariation_Selectors","InCombining_Half_Marks",
      "InCJK_Compatibility_Forms","InSmall_Form_Variants",
      "InArabic_Presentation_Forms-B","InHalfwidth_and_Fullwidth_Forms",
      "InSpecials" {
         add ":
           This nom->rust translator does not currently support unicode block 
           names in nom class patterns. ";
         put; clear; add "nom.error*"; push; .reparse
      }

      clear; 
      add "* Incorrect nom character class\n"; 
      add ' 
      Character classes are used in tests and the nom while 
      and whilenot commands
        eg: [:space:] { while [:space:]; clear; } 
        or: [:alnum:] { while [:alnum:]; clear; } \n';
      put; clear; add "nom.error*"; push; .reparse
    }
    # not using regexes for matching classes in this translator
    # ] should already be escaped in the nom class
    # this is a normal escape so as not to break the '...'
    escape '"'; unescape ']'; put;
    clear; add "["; get; add "]"; put;
    clear; add "class*"; push; .reparse
  }

  !"" {
    put; clear; 
    add "* strange character found '"; get; add "'\n\n"; 
    add "  see www.nomlang.org/doc/syntax for nom syntax documentation \n"; 
    put; clear; add "nom.error*"; push; .reparse
  }

 parse>
  # watch the parse-stack resolve.  
  # add "--> line "; lines; add " char "; chars; add ": "; print; clear; 
  # unstack; print; stack; add "\n"; print; clear;
   
  # ----------------
  # error trapping and help here
  pop;

  # parse help token for a topic, category of # topics or everthing. 
  "nom.help*" {
    # the topic or category to display help for is in the attribute
    clear; swap; 

    # a short list of commands and abbreviations 
    "commands.shortlist","commands","all" {
      swap; add "
      # 'D' doesn't actually work in compile.pss !
      nom abbreviations and commands: 

        zero k clip K clop D replace d clear
        t print p pop P push u unstack U stack G put g get x swap
        m mark M go r read R until w while W whilenot n count c chars C nochars 
        l lines L nolines v escape unescape z delim S state q quit s write
        o nop .rs .restart .rp .reparse
        (no abbreviations)
        a+ a- ++ --

          ";
    }

    # specific help for the add command 
    "command.add","commands","all" {
      swap; add "
      add command:
        add text to end of the workspace buffer
        see: nomlang.org/doc/commands/nom.add.html
      eg:
        add ':tag:';     # correct
        add [:space:];   # incorrect, cannot have class parameter 
        add;             # incorrect, missing parameter
          ";
    }

    #  
    "semicolon","punctuation","all" {
      swap; add "
       semicolon:
         All statements (commands) must end with a semi-colon 
         except .reparse and .restart (even the last command in
         the block)
       eg:
         clear; .reparse       # correct
         clear add '.';        # incorrect, clear needs ; 
         ";
    }


    # 'brackets' is topic, 'punctuation' is a category, 'all' is everthing 
    "brackets","punctuation","all" {
      swap; add "
      brackets () 
        are used for tests like (eof) (EOF) (==) 
        currently (2025) brackets are not used for logical grouping in 
        tests.
      examples:
         (==)                  # correct
         (==,'abc' { nop; }    # incorrect: unbalanced ";
    }

    "negation","punctuation","all" {
      swap; add "
      negation operator ! 
        is used for negating class and equals tests and with the 
        B and E modifiers. It should precede the test and the 
        B and E modifiers.

      examples:
         !(eof) { add '.'; }   # correct, not at end-of-file
         ![:space:] { clear; } # correct 
         'abc'! { clear; }     # incorrect: ! must precede test.
         B!'abc' { clear; }    # incorrect: ! must precede 'B'  ";
    }


    # 
    "modifiers","tests","all" {
      swap; add "
      begins-with 'B' and ends-with 'E' modifiers:
        are used with quoted text tests and cannot be used with 
        class tests.
      eg: 
        B'abc' { clear; }        # correct 
        E\"abc\" { clear; }      # correct 
        B[:alpha:] { clear; }  # incorrect  ";
    }

    # help for the help system 
    "help","help","all" {
      swap; add "
        help system:
          categories: tests, commands, punctuation etc
          type '#:help <command>' in a [nom] script to get help
          for a particular command or word or category
        eg:
          #:help add    # shows help for the add command
          #:help tests  # shows help nom block tests.
        ";
    }

    # This help system quits after showing the help message
    # but you could keep parsing if there is any point. 
    add "\n\n"; print; quit; 
  }

  "nom.error*" {
    # get the parse stack here as well
    clear; 
    add "! Nom syntax:";
    add " near line:"; lines; add " char:"; chars; add "\n";
    get; 
    add "\n run /eg/nom.syntax.reference.pss for more detailed \n"; 
    add " syntax checking. See www.nomlang.org/doc for complete-ish \n";
    add " pep and nom documentation. \n";
    print;
    # provide help from the help* token if one was put on the stack. 
    clear; pop; "nom.help*" { push; .reparse } 
    quit;
  }

  # this error is when the error should have been trapped earlier
  "nom.untrapped.error*" {
    clear; 
    add "! Nom untrapped error! :";
    add " near line:"; lines; add " char:"; chars; add "\n";
    get; 
    add "\n run /eg/nom.syntax.reference.pss for more detailed \n"; 
    add " syntax checking. \n";
    print; quit;
  }

  #----------------
  # 2 parse token errors

  #*
  possible tokens: 
  literal* BE!<>{}(),.;
  quoted* class* word* command* test*
  ortest* andtest* statement* statementset* 
  *#

  # none of these literal tokens can start a sequence because
  # they should have already reduced to a subpattern (token)
  pop;

  "B*class*","E*class*" {
    clear; 

    clear; add "modifiers"; put; 
    clear; add "nom.help*"; push;
    add "  B or E modifier before class test."; put; 
    clear; add "nom.error*"; push; .reparse
  }

  # general token sequence errors

  # literal token error sequences.

  B"}*",B";*",B">*",B")*" {
    clear; add "* misplaced } or ; or > or ) character?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  B"B*",B"E*" {
    E"!*" {
      clear; add "negation"; put; 
      clear; add "nom.help*"; push;
      add "* The negation operator (!) must precede the  \n"; 
      add "  begins-with (B) or ends-with (E) modifiers \n";
      put; clear; add "nom.error*"; push; .reparse
    }
  }

  B"B*".!"B*".!E"quoted*" {
    clear; 
    add "* misplaced begin-test modifier 'B' ?"; 
    add "  eg: B'##' { d; add 'heading*'; push; .reparse } "; 
    put; clear; add "nom.error*"; push; .reparse
  }

  B"E*".!"E*".!E"quoted*" {
    clear; 
    add "* misplaced end-test modifier 'E' ?"; 
    add "  eg: E'.' { d; add 'phrase*'; push; .reparse } "; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # empty quote after B or E
  B"E*".E"quoted*" {
    clear; ++; get; --;
    '""' {
      clear; add "modifiers"; put; 
      clear; add "nom.help*"; push;
      add "  Empty quote after 'E' modifier "; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "E*quoted*"; 
  }

  B"B*".E"quoted*" {
    clear; ++; get; --;
    '""' {
      clear; add "modifiers"; put; 
      clear; add "nom.help*"; push;
      add "  Empty quote after 'B' modifier "; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "B*quoted*"; 
  }
  
  B"!*".!"!*".!E"(*".!E"<*".!E"B*".!E"E*".!E"quoted*".!E"class*".!E"test*" {
    clear; 
    add "* misplaced negation operator (!) ?"; 
    add "  e.g. \n";
    add "   !B'$#@' { clear; }   # correct \n"; 
    add '   !"xyz" { clear; }   # correct \n'; 
    add '   "abc"! { clear; }   # incorrect \n'; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # comma sequence errors, 2 tokens
  # error eg: ,,
  B",*".!E"(*".!E"<*".!E"!*".!E"B*".!E"E*".
  !E"quoted*".!E"class*".!E"test*" {
    clear; add "* misplaced comma ?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: . {
  B".*".!E"(*".!E"<*".!E"!*".!E"B*".!E"E*".
  !E"quoted*".!E"class*".!E"test*".!E"word*" {
    clear; add "* misplaced dot?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: {}
  B"{*".E"}*" {
    clear; add "* empty block {} "; put;
    clear; add "nom.error*"; push; .reparse
  }
  
  # error eg: { ,
  B"{*".!"{*" {
    E">*",E",*",E")*",E"{*",E"}*",E";*" {
      clear; add "* misplaced character '"; ++; get; --; add "' ?"; put;
      clear; add "nom.error*"; push; .reparse
    }
  }
  
  # try to diagnose missing close brace errors at end of script
  # eg ortest*{*statement*
  # we probably need a line/char number in the tape cell
  (eof) {
    "{*statement*","{*statementset*" {
      clear; 
      add "* missing close brace (}) ?\n"; 
      add "  At "; get; add " there is an opening brace ({) which does \n"; 
      add "  not seem to be matched with a closing brace ";
      put; clear; add "nom.error*"; push; .reparse
    }
  }

  # missing dot
  # error eg: clear; reparse 
  !B".*".E"word*".!"word*" {
    push; push; --; get; ++; 
    "reparse","restart" {
      clear; add "* missing dot before reparse/restart ? "; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; pop; pop;
  }

  # error eg: ( add
  # currently brackets are only used for tests
  B"(*".!"(*".!E"word*" {
    clear; add "* strange syntax after '(' "; put;
    clear; add "nom.error*"; push; .reparse
  }

  "<*;*" {
    clear; 
    add "* '<' used to be an abbreviation for '--' \n"; 
    add "* but no-longer (mar 2025) since it clashes with <eof> etc "; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # error eg: < add
  # currently angle brackets are only used for tests ( <eof> <==> ) 
  B"<*".!"<*".!E"word*" {
    clear; add "* bad test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  ">*;*" {
    clear; 
    add "* '>' used to be an abbreviation for '++' \n"; 
    add "  but no-longer (mar 2025) since it clashes with <eof> etc \n"; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # error eg: begin add
  B"begin*".!"begin*".!E"{*" {
    clear; 
    add "* begin is always followed by a brace.\n"; 
    add "   eg: begin { delim '/'; }\n"; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # error eg: clear; begin { clear; }
  E"begin*".!"begin*".!B"comment*" {
    clear; add "* only comments can precede a begin block."; put;
    clear; add "nom.error*"; push; .reparse
  }

  "command*}*" {
    clear; add "* missing semicolon? "; 
    add "
     In nom all commands except .reparse and .restart 
     must be terminated with a semicolon, even the last 
     command in a block {...} 

     see www.nomlang.org/doc/syntax/ for details \n";
    put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: clear {
  B"command*".!"command*".!E";*".!E"quoted*".!E"class*" {
    clear; add "* bad command syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # specific analysis of the token sequences permitted above
  "command*class*" {
    clear; get; 
    !"while".!"whilenot" {
      clear; 
      add "* command '"; get; add "' does not take class argument.\n"; 
      add "  see www.nomlang/doc/commands/nom."; get; add ".html "; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*class*";
  }

  "command*quoted*" {
    clear; get; 
    !"add".!"replace".!"mark".!"go".!"until".
    !"delim".!"escape".!"unescape".!"echar" {
      clear; 
      add "* command '"; get; add "' does not take quoted argument.\n\n"; 
      add "  see www.nomlang/doc/commands/nom."; get; add ".html ";
      add "  for details.";
      put; clear; add "nom.error*"; push; .reparse
    }
    # for the delimiter and the escape char only allow one 'character'
    # (ie unicode code-point) not a unicode grapheme cluster, which
    # could be several 'characters'. This is because it is unnecessary and
    # I doubt that any language is going to use a grapheme cluster as
    # an escape character.
    "delim","echar" {
      clear; ++; get; --; 
      clip;clop;clip;
      !"" {
        clear; add "* multiple char argument to 'delim' or 'echar'. "; put;
        clear; add "nom.error*"; push; .reparse
      }
    }
    # check that not empty argument.
    clear; ++; get; --;
    '""' {
      clear; 
      add "* empty quoted text ('' or \"\") is an error here.\n\n"; 
      add "  - The 2nd argument to 'replace' can be an empty quote\n";
      add "    eg: replace 'abc' ''; # replace 'abc' with nothing \n";
      add "  - Also, empty quotes can be used in tests \n";
      add "    eg: '' { add 'xyz'; } !'' { clear; } \n";
      put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*quoted*";
  }

  "command*;*" {
    clear; get; 
    "add","replace","while","whilenot","delim","escape","unescape","echar" {
      clear; 
      add "* command '"; get; add "' requires argument."; 
      add "- eg: add 'abc'; while [:alnum:]; escape ']'; "; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*;*";
  }

  # end-of-script 2 token command errors.
  (eof) {
    E"command*" {
      clear; 
      add "* unterminated command '"; get; add "' at end of script"; 
      put; clear; add "nom.error*"; push; .reparse
    }
    "command*quoted*","command*class*" {
        clear; 
        add "* unterminated command '"; get; add "' at end of script"; 
        put; clear; add "nom.error*"; push; .reparse
    }
  }

  # error eg: "xx" }
  B"quoted*".!"quoted*".!E"{*".!E"quoted*".!E";*".!E",*".!E".*" {
    clear; 
    add " dubious syntax (eg: missing semicolon ';') after quoted text."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: [:space:] }
  B"class*".!"class*".!E"{*".!E";*".!E",*".!E".*" {
    clear; add "semicolon"; put; 
    clear; add "nom.help*"; push;
    clear; add "* missing semi-colon after class? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # A word is not a command. reparse and restart have already reduced.
  # error eg: eof (
  B"word*".!"word*".!E")*".!E">*" {
    clear; add "* bad syntax after word."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: E"abc";
  B"test*".!"test*".!E",*".!E".*".!E"{*" {
    clear; add "* bad test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error "xx","yy"."zz"
  B"ortest*".!"ortest*".E".*" {
    clear; add "* AND '.' operator in OR test."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa" "abc";
  "ortest*quoted*","ortest*test*" {
    clear; add "* missing comma in test?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa",E"abc";
  B"ortest*".!"ortest*".!E",*".!E"{*" {
    clear; add "* bad OR test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error "xx"."yy","zz"
  B"andtest*".!"andtest*".E",*" {
    clear; add "* OR ',' operator in AND test."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa".E"abc";
  "andtest*quoted*","andtest*test*" {
    clear; add "* missing dot in test?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa".E"abc";
  B"andtest*".!"andtest*".!E".*".!E"{*" {
    clear; add "* bad AND test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # end-of-script 2 token test errors.
  (eof) {
    E"test*",B"test*",E"ortest*",B"ortest*",E"andtest*",B"andtest*" {
      clear; 
      add "* test with no block {} at end of script"; 
      put; clear; add "nom.error*"; push; .reparse
    }
  }

  # error eg: add 'x'; { 
  B"statement*".!"statement*" {
    E",*",E"{*" {
      clear; add "* misplaced dot/comma/brace ?"; put;
      clear; add "nom.error*"; push; .reparse
    }
  }

  # error eg: clear;add 'x'; { 
  B"statementset*".!"statementset*" {
    E",*",E"{*" {
      clear; add "* misplaced dot/comma/brace ?"; put;
      clear; add "nom.error*"; push; .reparse
    }
  }

  # specific command errors

  # until, mark, go etc have no-parameter versions
  "command*;*" {
    clear; get;
    "add","replace","while","whilenot","delim","escape","unescape","echar" {
      clear; add "* command '"; get; add "' requires argument"; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*;*";
  }

  #----------------
  # 3 parse token errors, 
  pop;

  # missing semicolon errors?
  # error eg: [:space:] { whilenot [:space:] }
  B"command*class*".!"command*class*".!E";*" {
    clear; add "semicolon"; put; 
    clear; add "nom.help*"; push;
    clear; add "* missing semi-colon after statement? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # missing semicolon errors
  # error eg: [:space:] { until "</em>" }
  B"command*quoted*".!"command*quoted*".!E";*".!E"quoted*" {
    clear; add "* missing semi-colon after statement? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "cd" "ef" {
  B"quoted*quoted*".!E";*" {
    clear; add "* missing comma or dot in test? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: , "cd" "ef"
  E"quoted*quoted*".!B"command*" {
    clear; add "* missing comma or dot in test? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  "command*quoted*quoted*" {
    clear; get; 
    !"replace" {
      clear; 
      add "* command '"; get; add "' does not take 2 quoted arguments.\n"; 
      add "- The only nom command with 2 quoted arguments is 'replace'."; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*quoted*quoted*";
  }

  # error eg: clear "x"; already checked above.
  # "command*quoted*;*" {}

  # error eg: add [:space:] already checked above in 2 tokens
  # "command*class*;*" {}

  #----------------
  # 4 parse token errors
  pop;
  "command*quoted*quoted*;*" {
    clear; get;
    !"replace" {
      clear; add "* command '"; get; add "' does not take 2 arguments."; put;
      clear; add "nom.error*"; push; .reparse
    }
    # check that not 1st argument is empty
    clear; ++; get; --;
    '""' {
      clear; add "* empty quoted text '' is an error here."; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*quoted*quoted*;*";
  }

  push;push;push;push;
  # end of errors
  # ----------------


  # ----------------
  # 2 grammar parse tokens 
  pop;pop;
  
  # permit comments anywhere in script
  #
  B"comment*".!"comment*" {
    # A translator would try to conserve the comment.
    replace "comment*" ""; push; 
    get; --; put; ++; clear;
    .reparse
  }

  E"comment*".!"comment*" {
    replace "comment*" ""; push; .reparse
  }

  #------------ 
  # The .restart command jumps to the first instruction after the
  # begin block (if there is a begin block), or the first instruction
  # of the script.
  ".*word*" {
    clear; ++; get; --;
    "restart" {
      clear; add "continue 'script;"; put; 
      clear; add "statement*"; push; .reparse 
    }
    "reparse" {
      clear; 
      # check accumulator to see if we are in the "lex" block
      # or the "parse" block and adjust the .reparse compilation
      # accordingly.
      count; 
      # if the count is not 0/1 then something is wrong. Probably
      # > 1 parse> label which should have already been trapped.
      !"0".!"1" {
        clear; add "* multiple parse label error?"; put;
        clear; add "nom.untrapped.error*"; push; .reparse
      }
      "0" { clear; add "break 'lex;"; }
      "1" { clear; add "continue 'parse;"; }
      # for languages that have goto we can use the following
      # add "goto parse;";
      put; 
      clear; add "statement*"; push; .reparse 
    }
    clear; add "* invalid statement ."; put;
    clear; add "nom.untrapped.error*"; push; .reparse
  }

  "word*>*" {
    clear; get; 
    "parse" { 
      clear; count;
      !"0" {
        clear; 
        add "script error:\n";
        add "  extra parse> label at line "; lines; add ".\n";
        print;
        quit;
      }
      clear; add "--> parse>"; put;
      clear; add "parselabel*"; push;
      # use accumulator to indicate after parse> label
      a+; .reparse 
    }
    clear; add "word*>*";
  }

  #-----------------------------------------
  # format: E"text" or E'text'
  #  This format is used to indicate a "workspace-ends-with" text before
  #  a brace block.
  # eg: E"abc" { ... }
  "E*quoted*" {
    clear; add "self.work.ends_with("; ++; get; add ")"; --; put;
    clear; add "test*"; push; .reparse
  } 

  #-----------------------------------------
  # format: B"sometext" or B'sometext' 
  #   A 'B' preceding some quoted text is used to indicate a 
  #   'workspace-begins-with' test, before a brace block.
  "B*quoted*" {
    clear; add "self.work.starts_with("; ++; get; add ")"; --; put;
    clear; add "test*"; push; .reparse
  } 

  #---------------------------------
  # Compiling comments so as to transfer them to the output code
  # but comments in some places are an error.
  "comment*statement*","statement*comment*","statementset*comment*" {
    clear; get; add "\n"; ++; get; --; put; clear;
    add "command*"; push; .reparse
  }
  "comment*comment*" {
    clear; get; add "\n"; ++; get; --; put; clear;
    add "comment*"; push; .reparse
  }

  # -----------------------
  # negated tokens.
  #  This format is used to indicate a negative test for 
  #  a brace block. eg: ![aeiou] { add "< not a vowel"; print; clear; }
  # eg: ![:alpha:] ![a-z] ![abcd] !"abc" !B"abc" !E"xyz"
  "!*test*" {
    clear; add "!("; ++; get; --; add ")"; put; 
    clear; add "test*"; push; .reparse
  }

  # transform quotes and classses to tests, this greatly reduces the number
  # of rules required for other reductions
  ",*quoted*",".*quoted*","!*quoted*" { 
    push; clear; add "self.work == "; get; put;
    clear; add "test*"; push; .reparse
  }

  # transform quotes to tests
  "quoted*,*","quoted*.*","quoted*{*" { 
    replace "quoted*" "test*"; push; push; 
    --; --; add "self.work == "; get; put;
    ++; ++; clear; .reparse
  }

  # transform classes to tests, all characters in the workspace need
  # to match the (unicode) class, category or unicode script name for the 
  # class test to return true. Empty workspace never matches.
  ",*class*",".*class*","!*class*" { 
    push; clear; 
    add 'self.matchClass(&self.work.clone(), "'; get; add '")';
    put; clear; add "test*"; push; .reparse
  }

  # transform classes to tests
  "class*,*","class*.*","class*{*" { 
    replace "class*" "test*"; push; push; 
    --; --; 
    add 'self.matchClass(&self.work.clone(), "'; get; add '")';
    put; 
    ++; ++; clear; .reparse
  }

  #--------------------------------------------
  # ebnf: command := command ';' ;
  # formats: "pop; push; clear; print; " etc
  "command*;*" {
     clear; get;

     # error trap here .
     !"go".!"mark".!"until".!"clip".!"clop".!"clear".!"upper".!"lower".
     !"cap".!"print".!"pop".!"push".!"unstack".!"stack".!"state".!"put".!"get".
     !"swap".!"++".!"--".!"read".!"count".!"a+".!"a-".!"zero".!"chars".
     !"lines".!"nochars".!"nolines".!"quit".!"write".!"nop" {
       clear; add "  incorrect command syntax?"; put;
       clear; add "nom.untrapped.error*"; push; .reparse
     }

     # go; not implemented in pars/compile.pss yet (feb 2025)
     "go" { 
       clear;
       add "self.goToMark(&self.tape[self.cell]);  /* go (tape) */";
     }
     "mark" { 
       clear;
       add "let s = self.tape[self.cell].clone();\n";
       add "self.addMark(&s);  /* mark (tape) */";
     }

     # the new until; command with no argument
     "until" { 
       clear;
       add "let s = self.tape[self.cell].clone();\n";
       add "self.readUntil(&s);  /* until (tape) */";
     }

     "clip" { 
       clear; add "self.work.pop();    /* clip */"; 
     }
     "clop" { 
       clear; 
       add "if !self.work.is_empty() { /* clop */\n";
       add "  self.work.remove(0); \n}   ";
     }
     "clear" { 
       clear; add "self.work.clear();  /* clear */";
     }
     "upper" { 
       clear; 
       add "let s = self.work.to_uppercase(); /* upper */\n";
       add "self.work.clear(); self.work.push_str(&s);";
     }
     "lower" { 
       clear; 
       add "let s = self.work.to_lowercase(); /* lower */\n";
       add "self.work.clear(); self.work.push_str(&s);";
     }
     "cap" { 
       clear; 
       # capitalize every word not just the first.
       # other translators and pep just capitalise the first letter
       # but thats silly. This command "cap" is not really required.
       add "self.capitalise(); /* cap */"; 
     }
     "print" { 
       clear; 
       # write to stdout/file/string
       add "self.write(); /* print */ ";
     }
     "pop" { clear; add "self.pop();"; }
     "push" { clear; add "self.push();"; }
     "unstack" { clear; add "while self.pop() {}   /* unstack */"; }
     "stack" { clear; add "while self.push() {}   /* stack */"; }
     "state" { clear; add "self.printState();    /* state */"; }
     "put" { 
       clear; 
       add "self.tape[self.cell].clear(); /* put */\n";
       add "self.tape[self.cell].push_str(&self.work); ";
     }
     "get" { 
       clear; 
       add "self.work.push_str(&self.tape[self.cell]); /* get */";
     }
     "swap" { 
       clear; 
       add "std::mem::swap(&mut self.tape[self.cell], &mut self.work);";
     }
     # need a method because we may need to increase the tape size.
     "++" { clear; add "self.increment();   /* ++ */"; }
     "--" { 
       clear; add "if self.cell > 0 { self.cell -= 1; } /* -- */"; 
     }
     "read" { 
       clear; 
       # it is better to break out of the nom script loop than exit() or 
       # return because we may need to close open files or flush written
       # file content.
       add "if self.eof { break 'script; } self.read(); /* read */";
     }
     "count" { 
       clear; 
       add "self.work.push_str(&self.accumulator.to_string()); /* count */"; 
     }
     "a+" { clear; add "self.accumulator += 1; /* a+ */"; }
     "a-" { clear; add "self.accumulator -= 1; /* a- */"; }
     "zero" { clear; add "self.accumulator = 0; /* zero */"; }
     "chars" { 
       clear; 
       add "self.work.push_str(&self.charsRead.to_string()); /* chars */"; 
     }
     "lines" { 
       clear; 
       add "self.work.push_str(&self.linesRead.to_string()); /* lines */"; 
     }
     "nochars" { clear; add "self.charsRead = 0; /* nochars */"; }
     "nolines" { clear; add "self.linesRead = 0; /* nolines */"; }
     # use a labelled loop to quit script.
     # better to break than return because can close open files etc.
     "quit" { clear; add "break 'script; /* quit */"; }
     "write" { 
       clear; 
       add "/* write */\n";
       add 'fs::write("sav.pp", &self.work).expect("Unable to write file");';
     }
     # just eliminate since it does nothing.
     "nop" { clear; add "// removed nop: does nothing "; }

     put; clear; add "statement*";
     push; .reparse
   }

  "statementset*statement*","statement*statement*" {
    clear; get; add "\n"; ++; get; --; put;
    clear; add "statementset*"; push; .reparse
  }

  # ----------------
  # 3 grammar parse tokens 
  pop;
  "(*word*)*","<*word*>*" {
    clear; ++; get; --;

    !"eof".!"==" {
      clear; add "* invalid test <> or () ."; put;
      clear; add "nom.untrapped.error*"; push; .reparse
    }
    "eof" { 
      clear; add "self.eof";
    }
    "==" { 
      clear; add "self.tape[self.cell] == self.work";
    }
    put; clear; add "test*"; push; .reparse 
  }

  #--------------------------------------------
  # quoted text is already double quoted eg "abc" 
  # eg: add "text";
  "command*quoted*;*" {
    clear; get;
    # error trap here 
    !"mark".!"go".!"delim".!"add".!"until".
    !"escape".!"unescape".!"echar" {
      clear; 
      add "  superfluous argument or other error?\n"; 
      add "  (error should have been trapped in error block: check)"; 
      put; clear; add "nom.untrapped.error*"; push; .reparse
    }

    "mark" {
      clear; add 'self.addMark('; ++; get; --; add '); /* mark */';
    }
    "go" {
      clear; add 'self.goToMark('; ++; get; --; add '); /* go */';
    }

    "delim" {
      # rust has a char type, but it is for 'code points' not 
      # grapheme clusters (diacritics etc). So technically the 'delim'
      # char could be a string of several chars but in practice this 
      # is not necessary.
      clear; ++; get; 
      # remove double quotes
      # have already verified one char in error block 
      clip; clop; escape "'"; put; --;
      clear; add "self.delimiter = '"; ++; get; --; add "'; /* delim */";
    }

    "add" {
      clear; add 'self.work.push_str('; ++; get; --; 
      # handle multiline text
      # it is possible to just use multiline strings in some languages
      # but they will be indented by the translator, so they will have 
      # handle multiline text check this! \\n or \n
      # more indentation than the script writer intended...

      # this is more readable than just adding 
      replace "\n" '");\nself.work.push_str("\\n';
      add '); /* add */';
    }
   
    # no while/whilenot "quoted"; syntax
    "until" {
       clear; add 'self.readUntil('; ++; get; --; 
       # handle multiline argument
       replace "\n" "\\n"; add ');'; 
     }

    "escape","unescape" {
       # only use the first char or grapheme cluster of escape argument?
       # remove double quotes
       clear; ++; get; clip; clop; escape "'"; put; --;
       clear; add "self."; get; add "Char"; 
       add "('"; ++; get; --; add "');"; 
     }

     # can only be a unicode codepoint not grapheme cluster
     "echar" {
       clear; ++; get; 
       # remove double quotes because rust uses single quotes for 
       # the char type.
       clip; clop; escape "'"; put; --;
       add "self.escape = '"; ++; get; --; add "'; /* echar */";
     }

     put; clear; add "statement*"; push; .reparse
   }

  # eg: while [:alpha:]; or whilenot [a-z];
  "command*class*;*" {
    clear; get;

    # 
    "while" {
      clear;
      add "/* while */\n";
      add 'while self.matchClass(&self.peep.clone(), "'; ++; get; --; 
      add '") {\n';
      add "  if self.eof { break; } self.read();\n}"; 
      put; clear; add "statement*"; push; .reparse
    }

    "whilenot" {
      clear;
      add "/* whilenot */  \n";
      add 'while !self.matchClass(&self.peep.clone(), "'; ++; get; --; 
      add '") {\n';
      add "  if self.eof { break; } self.read();\n}"; 
      put; clear; add "statement*"; push; .reparse
    }
    clear; add "*** unchecked error in rule: statement = command class ;"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # brackets around tests will be ignored.
  "(*test*)*" {
    clear; ++; get; --; put; clear;
    add "test*"; push; .reparse
  }

  # brackets will allow mixing AND and OR logic 
  "(*ortest*)*","(*andtest*)*" {
    clear; ++; get; --; put; clear;
    add "test*"; push; .reparse
  }

  # -------------
  # parses and compiles concatenated tests
  # eg: 'a',B'b',E'c',[def],[:space:],[g-k] { ...

  "test*,*test*","ortest*,*test*" {
    # OR logic concatenation 
    # put brackets around tests even though operator 
    # precedence should take care of it
    "test*,*test*" {
      clear; add "("; get; add ")";
    }
    "ortest*,*test*" { clear; get; } 
    add " || ("; ++; ++; get; --; --; add ")"; 
    put; clear; add "ortest*"; push; .reparse
  }

  # -------------
  # AND logic 
  # parses and compiles concatenated AND tests
  # eg: 'a',B'b',E'c',[def],[:space:],[g-k] { ...
  # negated tests can be chained with non negated tests.
  # eg: B'http'.!E'.txt' { ... }
  "test*.*test*","andtest*.*test*" {
    # AND logic concatenation 
    # add brackets 
    "test*.*test*" {
      clear; add "("; get; add ")";
    }
    "andtest*.*test*" { clear; get; } 
    add " && ("; ++; ++; get; --; --; add ")"; 
    put; clear; add "andtest*"; push; .reparse
  }

  # dont need to reparse 
  "{*statement*}*" { replace "ment*" "mentset*"; }

  # ----------------
  # 4 grammar parse tokens 
  pop;

  # see below
  # "command*quoted*quoted*;*" { clear; add "statement*"; push; .reparse }

  # eg:  replace "and" "AND" ; 
  "command*quoted*quoted*;*" {
    clear; get;
    "replace" {
      #---------------------------
      # a command plus 2 arguments, eg replace "this" "that"
      # multiline replace? no.
      clear;
      add 'self.replace('; ++; get; add ', '; ++; get; 
      add ');  /* replace */'; 
      --; --; put;
      clear; add "statement*"; push; .reparse
    }

    # error trap
    clear; add "  incorrect command syntax?"; put;
    clear; add "nom.untrapped.error*"; push; .reparse
  }

  # reducing blocks
  "test*{*statementset*}*", 
  "ortest*{*statementset*}*",
  "andtest*{*statementset*}*" {
    clear; 
    # indent the translated code for readability
    ++; ++; add "\n"; get; replace "\n" "\n  "; put; --; --; 
    clear; add "if ("; get; add ") {";
    ++; ++; get; add "\n}"; --; --; put; 
    clear; add "statement*"; push; .reparse
  }

  "begin*{*statementset*}*" {
     clear; 
     ++; ++; get; --; --; put; clear;
     add "beginblock*"; push; .reparse
  }

  # end of input stream errors
  (eof) {
    "test*","ortest*","andtest*","begin*" {
       clear; 
       add "* Incomplete script."; put;
       clear; add "nom.error*"; push; .reparse
    }
  }

  # cannot be reduced to one push;
  push;push;push;push;

  pop;pop;pop;
  (eof) {
    # need to arrange the labelled loops or gotos here. Because the 
    # loop cannot include the beginblock.
    # just a trick to make the following rules simpler
    replace "statement*" "statementset*";
    # rust has labelled loops

    "statementset*parselabel*statementset*" {
      clear; 
      # indent both code blocks
      add "    "; get; replace "\n" "\n    "; put; clear; ++; ++;
      add "    "; get; replace "\n" "\n    "; put; clear; --; --;
      # add a block so that .reparse works before the parse> label.
      add "'script:\n";
      add "loop {\n";
      add "  'lex: { \n";
      get; 
      add "\n  } /* lex block */\n"; 
      add "  'parse: \n";
      add "    loop { \n"; ++; ++; get; --; --;
      add "\n    break 'parse;  /* run-once parse loop */";
      add "\n  } /* parse block */"; 
      add "\n} /* nom script loop */";
      put; 
      clear; add "script*"; push; .reparse
    }
  }
  push;push;push;
  # this cannot be reduced to 'push;'
  pop;pop;
  (eof) {
    # need to arrange the labelled loops or gotos here. Because the 
    # loop cannot include the beginblock.
    # just a trick to make the following rules simpler
    replace "statement*" "statementset*";

    "statementset*parselabel*" {
       clear; add "    "; get; replace "\n" "\n    "; put; clear; 
       add "'script:\n";
       add "loop {\n";
       add "  'lex: { \n"; get; 
       add "\n  } /* lex block */\n"; 
       # parse label with no statement after.
       add "  'parse: {}";
       add "\n} /* nom script loop */";
       put; 
       clear; add "script*"; push; .reparse
    }

    "parselabel*statementset*" {
       clear; add "    "; ++; get; --; replace "\n" "\n    "; put; clear; 
       add "'script:\n";
       add "loop {\n";
       add "  'parse: \n";
       add "    loop { \n"; get;
       add "\n    break 'parse;  /* run-once parse loop */";
       add "\n  } /* parse block */"; 
       add "\n} /* nom script loop */";
       put; 
       clear; add "script*"; push; .reparse
    }


    "beginblock*script*" {
      clear; get; add "\n"; ++; get; --; put;
      clear; add "script*"; push; .reparse
    }
  }
  # cannot reduce to push
  push;push;
  pop;
  (eof) {
    # need to arrange the labelled loops or gotos here. Because the 
    # loop cannot include the beginblock.
    # just a trick to make the following rules simpler
    replace "statement*" "statementset*";
    "statementset*" {
       clear; add "  "; get; replace "\n" "\n  "; put; clear; 
       add "'script:\n";
       add "loop {\n"; get;
       add "\n} // nom script loop "; put;
       clear; add "script*"; push; .reparse 
    }
    "beginblock*","comment*","parselabel*" {
       clear; add "script*"; push; .reparse 
    }
  }

  push;push;push;push;

  (eof) {
    pop;pop;
    "" {
      add "--> empty nom script\n"; 
      print; quit;
    }
    !"script*" {
      push;push;
      unstack; put; clear; 
      add "* script syntax problem: the error was not caught by the \n"; 
      add "  syntax checker, and should have been.\n";
      add "  The parse stack was: ";
      get; put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "/* good nom syntax. */ \n"; print; clear;
    # indent the compiled code
    add "\n"; get; replace "\n" "\n      "; put; clear;
    # create the virtual machine object code and save it
    # on the tape.
    add '
 #![allow(unused)]    
 #![allow(dead_code)]
 #![allow(non_snake_case)]
 /* 
   tips to make rust binaries smaller
   Stripping debug symbols (strip <binary>).
   Optimizing for size in the Cargo.toml (opt-level = "z").
   Using link-time optimization (lto = true).
 */

 /* Rust code generated by "nom.torust.pss" */
 // use std::mem;     // for swap
 use std::io;
 use std::io::Stdin;
 use std::io::stdin;
 use std::io::Stdout;
 use std::io::StdoutLock;
 use std::io::stdout;
 use std::io::Read;
 use std::io::Write;
 use std::io::{BufWriter, BufReader, BufRead};
 use std::process;
 use std::fs;
 use std::fs::File;
 use std::str::Chars;  // for the char iterator
 use std::env;  // for command line arguments
 //use regex::Regex;

 #[derive(Debug)]
 enum InputType {
   Unset,    // no input type has been set
   Stdin,    // read all of stdin at once into buffer
   StdinStream,  // read stdin as a stream (line by line?)
   File,         // read all of file at once into buffer
   FileStream,   // read a file as a stream
   String        // read from a string
 }
 #[derive(Debug)]
 enum OutputType {
   Unset,
   Stdout,
   File,
   String
 }

 pub struct Machine {
   accumulator: i32,  // counter for anything
   peep: String,      // next char in input stream. It is better to
                      // make this a String because a grapheme cluster will
                      // consist of multible unicode char points.
   charsRead: u32,    // No. of chars read so far init:0
   linesRead: u32,    // No. of lines read so far init:1

   /* a reversed array of strings where each string represents one
      grapheme cluster or character in the input stream. By reversing
      we can process this one char at a time with Vec.pop() 
      This is a better alternative to a simple inputBuffer string */
   inputChars: Vec<String>,   
   inputBuffer: String,    // the nom read command will read from this 
                           // this also helps with grapheme clusters.
                           // this is reversed!! (will change to inputChars
   outputBuffer: String,   // where string output will go. 
   sourceType: InputType,  // enum: reading from stdin/string/file etc
   sinkType: OutputType,   // should be enum?
   work: String,         // text accumulator
   stack: Vec<String>,   // parse token stack
   tapeLength: usize,    // tape initial length
   tape: Vec<String>,    // array of token attributes, growable
   marks: Vec<String>,   // tape marks
   cell: usize,          // pointer to current cell
   input: BufReader<File>,   // text input stream
   output: BufWriter<File>,  // 
   eof: bool,       // end of stream reached?
   escape: char,    // char used to "escape" others: default "\\"
   delimiter: char  // push/pop delimiter (default is "*"). This can only be 
                    // 1 unicode code-point not a grapheme cluster because its
                    // not necessary.
 }

 impl Machine {

   /** make a new machine. I am creating
       a temp file because I dont know how to just create a file object. */
   pub fn new() -> Self {
     Machine {
       tapeLength: 100,
       input: BufReader::new(File::create("temp.xyz.123.txt").unwrap()),
       output: BufWriter::new(File::create("temp.xyz.123.txt").unwrap()),
       eof: false,
       charsRead: 0, 
       linesRead: 1, 
       inputBuffer: String::new(),
       outputBuffer: String::new(),
       inputChars: Vec::with_capacity(1000),
       sourceType: InputType::Unset,  // set this at parse() if unset
       sinkType: OutputType::Stdout,
       escape: \'\\\\\',
       delimiter: \'*\',
       accumulator: 0,
       work: String::new(),
       stack: Vec::with_capacity(100),
       cell: 0,
       tape: vec!["".to_string();100],
       marks: vec!["".to_string();100],
       peep: String::new(),  // could be grapheme cluster
     } // self
   }

   /* this is useful for creating the internal representation of 
      the input, which could be a char iterator, a vector, array 
      of chars or grapheme clusters (strings) or just a plain string.
      At the moment the rust code uses a reversed string, but this 
      will change */
   pub fn fillInputBuffer(&mut self, text: &str) {
     // this will change to generate a vector of strings (chars or 
     // grapheme clusters).
     // is a non-empty input buffer an error here?
     //self.inputBuffer.clear(); 
     let revtext: String = text.chars().rev().collect();
     self.inputBuffer.push_str(&revtext); 
   }

   pub fn newFillInputBuffer(&mut self, text: &str) {
     // change to text.graphemes().rev for grapheme clusters.
     for c in text.chars().rev() {
       self.inputChars.push(c.to_string());
     }
     // fill into a vector
     // let string_vector_from_string: Vec<String> = 
     //     text.chars().map(|c| c.to_string()).collect();

   }

   /*  read one character from the input stream and 
       update the machine. This may reads though a inputBuffer so as to handle
       unicode grapheme clusters (which can be more than one "character").
   */ 
   pub fn read(&mut self) { 
     /* this exit code should never be called in a translated script
      because the Machine:parse() method will return just before 
      a read() on self.eof But I should keep this here in case 
      the machine methods are used outside of a parse() method? */
     if (self.eof) { 
       // need to return from parse method (i.e break loop) when reading on eof.
       process::exit(0) // print("eof exit") 
     } 

     let mut result = 0;
     let mut line = String::new();
     self.charsRead += 1;
     // increment lines
     if self.peep == "\\n" { self.linesRead += 1; }
     self.work.push_str(&self.peep);

     // fix: it would be better not to have a switch match here.
     /* stdin.all/string/file all read the whole input stream 
        at once into a buffer. */
     match self.sourceType {
       InputType::Stdin|InputType::String|InputType::File => {
         if (self.inputBuffer == "") {
           self.eof = true;
           self.peep.clear();
         } else {
           self.peep.clear();
           // the inputBuffer/Chars is reversed! pop() returns an option type
           self.peep.push_str(&self.inputBuffer.pop().unwrap().to_string());
           // can become self.inputChars.pop() ....
         }
         return;
       },
       InputType::FileStream|InputType::StdinStream => {
         if (self.inputBuffer == "") {
           if self.input.read_line(&mut line).unwrap() > 0 {
             self.fillInputBuffer(&line);
           } else {
             self.eof = true;
             self.peep.clear();
           }
         }
         if !self.inputBuffer.is_empty() {
           self.peep.clear();
           // the inputBuffer is reversed!  pop() gives an option type
           self.peep.push_str(&self.inputBuffer.pop().unwrap().to_string());
           // can become self.inputChars.pop() ....
         }
         return;
       },
       _ => {
         println!(
           "Machine.sourceType error {:?} while trying to read input", 
           self.sourceType); 
         process::exit(1);
       }
     } 
   } // read

   /*
     write to current machine destination (stdout/string/file) 
     no filestream or filelines types for file output because not
     required
   */

   // function Machine:write(output)
   pub fn write(&mut self) {
     match self.sinkType {
       OutputType::Stdout => {
         print!("{}",&self.work);
       }
       OutputType::File => { 
         write!(self.output, "{}", &self.work).unwrap()
       }
       OutputType::String => {
         self.outputBuffer.push_str(&self.work);
       }
       _ => {
         println!("Machine.sinkType error for type {:?}", self.sinkType);
       }
     }
   }

   /** increment tape pointer by one */
   pub fn increment(&mut self) {
     self.cell += 1;
     if self.cell >= self.tapeLength {
       for ii in 1..50 {
         self.tape.push(String::from(""));
         self.marks.push(String::from(""));
       }
       self.tapeLength += 50;
     }
   }


   // Machine.decrement() is compiled inline

   /** remove escape char, the char should be a string because it could be 
       a unicode grapheme cluster (diacritics etc) */
   pub fn unescapeChar(&mut self, c: char) {
     // dont unescape chars that are not escaped!
     let mut countEscapes = 0;
     let mut s = String::from(""); 
     //let nextChar = ;
     if self.work.is_empty() { return; }

     for nextChar in self.work.chars() {
       if (nextChar == c) && (countEscapes % 2 == 1) {
         // assuming that the escape char is only one char?
         // remove last escape char
         s.pop();
       } 
       if nextChar == self.escape {
         countEscapes += 1;
       } else { countEscapes = 0; }
       s.push(nextChar);
     } 
     self.work.clear(); self.work.push_str(&s);
   } 

   /* add escape character, dont escape chars that are already escaped! 
      modify this for grapheme clusters.
     */
   pub fn escapeChar(&mut self, c: char) {
     let mut countEscapes = 0;
     let mut s = String::from(""); 
     if self.work.is_empty() { return; }
     for nextChar in self.work.chars() {
       if (nextChar == c ) && (countEscapes % 2 == 0) {
         s.push(self.escape);
       } 
       if nextChar == self.escape {
         countEscapes += 1;
       } else { countEscapes = 0; }
       s.push(nextChar);
     } 
     self.work.clear();
     self.work.push_str(&s);
   } 

   /* a helper to see how many trailing escape chars */
   pub fn countEscaped(&mut self, suffix: &str) -> usize {
     let mut s = self.work.clone();
     let mut count = 0;
     if s.ends_with(suffix) {
       s.truncate(s.len() - suffix.len());
     }
     while s.ends_with(self.escape) {
       count += 1; s.pop();
     }
     return count;
   }

   /** reads the input stream until the work end with text. It is 
       better to call this readUntil instead of until because some 
       languages dont like keywords as methods. Same for read()
       should be readChar() */
   pub fn readUntil(&mut self, suffix: &str) {
     // read at least one character
     if self.eof { return; }
     self.read();
     loop {
       if self.eof { return; }
       if self.work.ends_with(suffix) {
         if self.countEscaped(suffix) % 2 == 0 { return; }
       }
       self.read();
     }
   }

   /** pop the first token from the stack into the workspace */
   pub fn pop(&mut self) -> bool {
     if self.stack.len() == 0 { return false; }
     self.work.insert_str(0, self.stack.pop().unwrap().as_str());     
     if self.cell > 0 { self.cell -= 1; }
     return true;
   }

   
   // push the first token from the workspace to the stack 
   pub fn push(&mut self) -> bool {
     // dont increment the tape pointer on an empty push
     if self.work.is_empty() { return false; }

     // no iterate chars.
     let mut token = String::new();
     let mut remainder = String::new();
     for (ii,c) in self.work.chars().enumerate() {
       token.push(c); 
       if c == self.delimiter {
         self.stack.push(token);
         let remainder: String = self.work.chars().skip(ii+1).collect();
         self.work.clear();
         self.work.push_str(&remainder);  
         self.increment();
         return true;
       }

     }
     // push the whole workspace if there is no token delimiter
     self.stack.push(token);
     self.work.clear();
     self.increment();
     return true;
   }

   /** swap current tape cell with the workspace */
   // swap not required, use mem::swap ??


   /* swap current tape cell with the workspace */
   /*
   fn swap(&mut self) {
     let s = self.work;
     self.work = self.tape[self.cell].clone(); 
     self.tape[self.cell] = s;
   }
   */
 
    /* code to read a line from BufReader */
    /*
    while reader.read_line(&mut line)? > 0 {
      if line.trim() == "STOP" {
          break;
      }
      println!("Read line: {}", line.trim());
      line.clear(); // Clear the buffer for the next read
    }
    */


   // save the workspace to file "sav.pp" 
   // we can put this inline?
   pub fn writeToFile(&mut self) {
     fs::write("sav.pp", self.work.clone()).expect("Unable to write file");
   }

   pub fn goToMark(&mut self, mark: &str) {
     for (ii, thismark) in self.marks.iter().enumerate() {
       if thismark.eq(&mark) { self.cell = ii; return; }
     }
     print!("badmark \'{}\'!", mark); 
     process::exit(1);
   }

   /* remove existing marks with the same name and add new mark */
   pub fn addMark(&mut self, newMark: &str) {
     // remove existing marks with the same name.
     for mark in self.marks.iter_mut() {
       if mark == newMark { mark.clear(); }
     }
     self.marks[self.cell].clear();
     self.marks[self.cell].push_str(newMark);
   }

   /* check if the workspace matches given list class eg [hjk]
    or a range class eg [a-p]. The class string will be "[a-p]" ie
    with brackets [:alpha:] may have already been made into something else by the
    compiler. 
    fix: for grapheme clusters and more complete classes  
   */

   pub fn matchClass(&mut self, text: &str, class: &str) -> bool {
     // empty text should never match a class.
     if text.is_empty() { return false; }

     // a character type class like [:alpha:]
     if class.starts_with("[:") && class.ends_with(":]") && 
        (class != "[:]") && (class != "[::]") {
       let mut charType: String = class.chars().skip(2).collect();
       charType.pop(); charType.pop();
       // \'\'.is_alphabetic()

       // these functions are unicode aware for code-points (not graphemes)
       match charType.as_str() {
         "alnum" => return text.chars().all(|c| c.is_alphanumeric()),
         "alpha" => return text.chars().all(|c| c.is_alphabetic()),
         "ascii" => return text.chars().all(|c| c.is_ascii()),
         "word" => return text.chars().all(|c| c.is_alphanumeric()||c == \'_\'),
         "blank" => return text.chars().all(|c| c==\' \'||c==\'\\t\'),
         "control" => return text.chars().all(|c| c.is_control()),
         "cntrl" => return text.chars().all(|c| c.is_control()),
         "digit" => return text.chars().all(|c| c.is_digit(10)),
         "graph" => return text.chars().all(|c| c.is_ascii_graphic()),
         "lower" => return text.chars().all(|c| c.is_lowercase()),
         "upper" => return text.chars().all(|c| c.is_uppercase()),
         "print" => return text.chars().all(|c| c.is_control() && c != \' \'),
         "punct" => return text.chars().all(|c| c.is_ascii_punctuation()),
         "space" => return text.chars().all(|c| c.is_whitespace()),
         "xdigit" => return text.chars().all(|c| c.is_digit(16)),
         _ => {
           println!("unrecognised char class in translated nom script");
           println!("{}", charType);
           process::exit(1);
         }
       }
       return false;
     }

     // get a vector of chars except the first and last which are [ and ]
     let mut charList: Vec<char> = class.chars().skip(1).collect();
     charList.pop();
     // is a range class like [a-z]
     if (charList.len() == 3) && (charList[1] == \'-\') {
       for char in text.chars() { 
         if (char < charList[0]) || (char > charList[2]) { return false; } 
       } 
       return true;
     }

     // list class like: [xyzabc]
     // check if all characters in text are in the class list
     if text.chars().all(|c| charList.contains(&c)) { return true; }
     return false;
     // also must handle eg [:alpha:] This can be done with char methods
   } 

   /* a plain text string replace function on the workspace */
   pub fn replace(&mut self, old: &str, new: &str) {
     if old.is_empty() { return; }
     if old == new { return; }

     let mut text = String::new();
     for cc in self.work.chars() {
       text.push(cc);
       if text.ends_with(old) {
         text.truncate(text.len()-old.len());
         text.push_str(new);
       } 
     }
     self.work.clear();
     self.work.push_str(&text);
   } 

   /* make the workspace capital case */
   pub fn capitalise(&mut self) {
     let mut result = String::new();
     let mut capitalize_next = true;
     for c in self.work.chars() {
       if c.is_alphabetic() {
         if capitalize_next {
           result.push(c.to_uppercase().next().unwrap());
           capitalize_next = false;
         } else {
           result.push(c.to_lowercase().next().unwrap());
         }
       } else {
         result.push(c);
         if c==\'\\n\' || c==\' \' || c==\'.\' || c==\'?\' || c==\'!\' {
           capitalize_next = true;
         }
       }
     }
     self.work.clear(); self.work.push_str(&result);
   } 

   /* print the internal state of the pep/nom parsing machine. This 
      is handy for debugging */
   pub fn printState(&self) {
      println!("\\n--------- Machine State ------------- ");
      println!("(input buffer:{})", self.inputBuffer.escape_default());
      print!("Stack[");
      for token in &self.stack {
        print!("{},", token);
      }
      print!("] Work[{}] ", self.work);
      print!("Peep[{}]\\n", self.peep.escape_default());
      print!("Acc:{} ", self.accumulator);
      print!("EOF:{} ", self.eof);
      print!("Esc:{} ", self.escape);
      print!("Delim:{} ", self.delimiter);
      print!("Chars:{} ", self.charsRead);
      print!("Lines:{}\\n", self.linesRead);
      println!("-------------- Tape ----------------- ");
      println!("Tape Size: {}", self.tapeLength);
      let mut start = 0;
      if self.cell > 3 {
        start = self.cell - 4; 
      } 
      let end = self.cell + 4; 
      for ii in start..end {
        print!("   {ii}");
        if ii == self.cell { print!("> ["); }
        else { print!("  ["); }
        print!("{}]\\n", self.tape.get(ii as usize).unwrap());
      }
   }

   /* just sets the Machine.inputBuffer to the given text
      but in this implementation, also reverses it. Bad idea.
      */

   /*
   pub fn setInputBuffer(&mut self, text: &str) {
     // fix: for grapheme clusters
     self.inputBuffer.clear(); 
     let revtext: String = text.chars().rev().collect();
     self.inputBuffer.push_str(&revtext); 
   } 
   */

   /* makes the machine read from a string also needs to prime 
      the "peep" value. */
   pub fn setStringInput(&mut self, text: &str) {
     self.sourceType = InputType::String; 
     self.inputBuffer.clear();
     self.fillInputBuffer(text);
     // prime the "peep" with the 1st char
     self.peep.clear(); self.read(); self.charsRead = 0;
   } 

   /* makes the machine write to a string */
   pub fn setStringOutput(&mut self) {
     self.sinkType = OutputType::String;
   } 

   /* parse/translate from a string and return the translated
      string */
   pub fn parseString(&mut self, input: &str) -> &str {
     self.setStringInput(input);
     self.sinkType = OutputType::String;
     self.parse();
     return &self.outputBuffer;
   } 

   /* makes the machine read from a file stream line by line, 
      not from stdin */
   pub fn setFileStreamInput(&mut self, filename: &str) {
     if !checkTextFile(filename) { process::exit(1); }
     let file = File::open(filename).unwrap();
     self.input = BufReader::new(file);
     self.sourceType = InputType::FileStream;
     // prime the peep, the read() method should refill the 
     // inputChars or inputBuffer if it is empty.
     self.peep.clear(); self.read(); self.charsRead = 0;
   } 
 
   /* makes the machine read from a file line buffer array
      but this also needs to prime the "peep" value */
   pub fn setFileInput(&mut self, filename: &str) {

     let mut file = BufReader::new(File::open(filename)
       .expect("Could not open file for reading."));
     // reads a file all at once into the Machine.inputBuffer
     let mut text = String::new();
     file.read_to_string(&mut text);
     // there is an extra newline being added, I dont know where.
     if text.ends_with("\n") { text.pop(); }
     self.sourceType = InputType::File;
     self.inputBuffer.clear();
     self.fillInputBuffer(&text);
     // prime the "peep" with the 1st char
     self.peep.clear(); self.read(); self.charsRead = 0;
   } 

   /* makes the machine write to a file not to stdout (the default) */
   pub fn setFileOutput(&mut self, filename: &str) {
     if !checkTextFile(filename) {
       process::exit(1);
     }
     let file = File::create(filename).unwrap(); 
     self.output = BufWriter::new(file);
     self.sinkType = OutputType::File;
   } 

   // parse from a file and put result in file 
   pub fn parseFile(&mut self, inputFile: &str, outputFile: &str) {
     self.setFileInput(inputFile);
     self.setFileOutput(outputFile);
     self.parse()
   } 

   /* parse from any stream, fix handle */
   /*
   pub fn parseStream(&mut self, reader: Read) {
     //self.input = handle;
     self.parse();
   } 
   */

   /* this is the default parsing mode. If no other is selected 
      it will be activated when parse() is first called. I activate it when
      parse is 1st called because otherwise it will block if no stdin
      is availabel. It also sets stdout as output */
   pub fn setStandardInput(&mut self) {
     self.sourceType = InputType::Stdin;  
     self.sinkType = OutputType::Stdout; 
     
     // unused because all input read at oncej
     //self.input = io.stdin 
     //self.output = io.stdout

     // read the whole of stdin into the inputBuffer 
     self.inputBuffer.clear();
     let mut reader = BufReader::new(stdin());
     let mut buffer = String::new();
     match reader.read_to_string(&mut buffer) {
       Err(why) => {
         // panic!("couldnt read : {}", why),
         return;
       }
       Ok(_) => {
         // print!("input:{}", buffer),
         // fix: change to graphemes
         // let text = buffer.chars().rev().collect::<String>();
         // self.inputBuffer.push_str(&text);
         self.fillInputBuffer(&buffer)
       }
     }

     // prime the "peep" with the 1st char, but this doesnt count as 
     // a character read.
     self.peep.clear(); self.read(); self.charsRead = 0;
   } 

   /** parse and translate the input stdin/file/string */
   pub fn parse(&mut self) {
     match self.sourceType {
       InputType::Unset => self.setStandardInput(),
       _ => (), 
     } 
     ';
     # get the compiled code from the tape
     get;
   add '
     // close open files here? yes. use break, not return
     match self.sinkType {
       OutputType::File => { self.output.flush().unwrap(); }
       OutputType::Stdout => { }
       OutputType::String => { }
       _ => {
         println!("unsupported output type: {:?}", self.sinkType);
       }
     }
   } // 
 } // Machine impl

  fn printHelp() {
    println!("
    Nom script translated to rust by www.nomlang.org/tr/nom.torust.pss
    usage: 
       echo \\"..sometext..\\" | ./script 
       cat somefile.txt | ./script 
       ./script -f <file>
       ./script -i <text>
    options:
     --file -f <file>
        run the script with <file> as input (not stdin)
     --input -i <text>
        run the script with <text> as input 
     --filetest -F <file>
        test the translated script with file input and output 
     --inputtest -I <text>
        test the translated script with string input and output 
     --help -h 
        show this help
        ");
  }

  /* display a message about a missing argument to the translated
     script */
  fn missingArgument() {
    println!("Missing argument.");
    printHelp();
    process::exit(1);
  }

  /* display a message if an command line option is repeated */
  fn duplicateSwitch() {
    println!("Duplicate switch found.");
    printHelp();
    process::exit(1);
  }

  fn checkTextFile(filepath: &str) -> bool {
    match File::open(filepath) {
      Ok(_) => true,
      Err(e) => {
        match e.kind() {
          io::ErrorKind::NotFound => {
            println!("File [{}] not found.", filepath);
          }
          io::ErrorKind::PermissionDenied => {
            println!("Permission denied to read file [{}] ", filepath);
          }
          _ => {
            println!("Error opening file {}: {:?}", filepath, e);
          }
        }
        return false;
      }
    }
  }

  fn main() { 

    /* add switches for file to file and string to string parsing 
       the -F and -I switch are mainly to allow file/string input/output
       to be easily tested by scripts */

    let mut mm: Machine = Machine::new();
    let mut input = ""; 
    let mut filename = "";

    let args: Vec<String> = env::args().collect();
    for (pos, e) in args.iter().enumerate() {
      if (e == "-f") || (e == "--file") { 
        if !filename.is_empty() { duplicateSwitch(); }
        if pos>=args.len()-1 { missingArgument(); }
        filename = &args[pos+1];
        if !checkTextFile(filename) { 
          printHelp();
          process::exit(1); 
        }
        mm.setFileInput(filename);
        // print output file here
      }
      if (e == "-F") || (e == "--filetest") { 
        if pos>=args.len()-1 { missingArgument(); }
        if !filename.is_empty() { duplicateSwitch(); }
        filename = &args[pos+1];
        if !checkTextFile(filename) { 
          printHelp();
          process::exit(1);
        }
        mm.parseFile(filename, "out.txt");
        let mut output = fs::read_to_string("out.txt").unwrap();
        print!("{}", output);
        process::exit(0)
      }
      if (e == "-i") || (e == "--input") { 
        if pos>=args.len()-1 { missingArgument(); }
        if !input.is_empty() { duplicateSwitch(); }
        input = &args[pos+1];
        mm.setStringInput(input);
      }
      if (e == "-I") || (e == "--inputtest") { 
        if pos>=args.len()-1 { missingArgument(); }
        if !input.is_empty() { duplicateSwitch(); }
        input = &args[pos+1];
        let text = mm.parseString(input);
        print!("{}",text);
        process::exit(0)
      }
      if (e == "-h") || (e == "--help") { 
        printHelp(); process::exit(0);
      }
    
      if !input.is_empty() && !filename.is_empty() {
        print!("
     Either use the --file/--filetest options or the --input/--inputtest
     options, not both
        ");
        printHelp(); process::exit(0);
      }
    }

    mm.parse();

   // println!("Hello rust nom translator");

  }

  \n';
    print; quit;
  } # end of block
