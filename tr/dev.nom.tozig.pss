
#*

ABOUT 

  Translate nom scripts to the zig language. The zig language is 
  relatively "low-level" and has the ability to compile to very small
  executables, which is one of the reasons I wish to write this
  translator.

  This is the new translator script organisation, (as indicated 
  by the name "nom.to<lang>.pss" and is much better than the old
  organisation.

STATUS 

  25 may 2025
    Just started this. I have copied an automatic translation from
    rust into the machine structure but it needs to be debugged
    and also all the generated code needs to be written. I will
    probably try to do the kotlin translation first, just because it
    seems a bit easier.
    
BUGS AND ISSUES
 
  If I escape \\ in quoted text then 2nd gen tests dont work because
  \n becomes \\n There may be no way around this in any language.

SOLVED BUGS

  Escaping \\ in single quoted text was doing strange things.

HISTORY
  
  25 may 2025
    began.

NOTES

  Its a good idea to include defined marks in sub printState()
  In the machine code section all backslashes need to be doubled eg \\\\

  The input buffer, is actually an array of strings and is currently reversed
  because then I can just use pop() to consume one
  character/codepoint/grapheme-cluster at a time. 

  https://www.regular-expressions.info/unicode.html#category
    important unicode regexp info for different languages. The 
    unicode script names and properties which are included here 
    were copied from this website. These are used for classes in
    tests and while/whilenot. Some class tests can be implemented
    with a matchClass function which may be faster.

  There are various input "types" meaning where the input comes 
  from and if it is a stream or just all read at once into a buffer.

UNICODE CATEGORIES

  Does zig support these categories?, here is a list.

  Apparently \P{L} (capital P) is the inverse set, ie any non-letter.
  But \p{L} does not match grapheme clusters, see below for that.

UNICODE SCRIPT NAMES

  Information from regular-expressions.info/unicode.html#script
  A surprising useful website.

  The JGsoft engine, Perl, PCRE, PHP, Ruby 1.9, Delphi can match Unicode scripts. 

UNICODE BLOCKS

  I would like for nom to support all these categories, scripts and 
  blocks if the target translation language supports them. But in 
  some cases it may be better for the translator to create 'ascii' 
  regular expressions for the sake of speed.

zig SYNTAX
  
  * some code to iterate an array and read sequences of same chars
  ------
  my @chars = ('a', 'b', 'c', 'x', 'x', 'x', 'd', 'e', 'x', 'f', 'f', 'x', 'g');

  my $target_char = 'x';
  my @consecutive_x = ();
  for (my $i = 0; $i < @chars; $i++) {
      if ($chars[$i] eq $target_char) {
          # Found the target character, now collect all consecutive ones
          while ($i < @chars && $chars[$i] eq $target_char) {
            #push @consecutive_x, $chars[$i];
            $i++; # Move to the next character
          }
          # Now process the @consecutive_x array
          print "Found consecutive '$target_char': @consecutive_x\n";
          @consecutive_x = (); # Reset for the next sequence
          $i--; # Adjust index because the inner loop went one step too far
      } else {
          print "Encountered: $chars[$i]\n";
      }
  }
  ,,,,

  * check if all character in string are in list
  ----
    my %allowed = map { $_ => 1 } @allowed_chars; 
    # Create a hash for faster lookup
    for my $char (split //, $string) {
      return 0 unless exists $allowed{$char};
    }
    return 1;
  ,,,,
  
  * an example of splitting grapheme clusters (not code points)
  -----
    my $original = "re\x{0301}sume\x{0301}";
    my $wrong    = reverse $original;
    my $right    = join '', reverse split /(\X)/, $original;
  ,,,,,

  * another way to split into grapheme clusters?
  >> my @grapheme_clusters = $string =~ m/\X/g;

  * use a module
  ------
    use Unicode::GraphemeClusters;

    my $string = "你好世界\x{1F469}\x{1F3FB}\x{1F468}\x{1F3FC}";
    print "Original string: $string\n";

    my @graphemes = grapheme_clusters($string);

    print "Grapheme clusters:\n";
    for my $grapheme (@graphemes) {
        print "'$grapheme'\n";
    }
    print "Number of grapheme clusters: ", scalar @graphemes, "\n";
  ,,,,

DONE

TODO

  unicode char categories/scripts.
  grapheme clusters
  interpret method
  test file and string input output.

TESTING 

  * compile an inline nom script to zig and display
  >> pep.pls 'r;t;t;d;'  

  * compile an inline nom script to zig and run with input
  >> pep.pls 'r;t;t;d;' 'abcd'   

  These bash functions are just to save typing when translating nom
  scripts to zig. Here is the equivalent
  without them:

  * translate an inline script to zig and print to stdout 
  >> pep -f nom.tozig.pss -i "r;[\n]{lines;add ' ';}print;d;"

  * test with the one-line nom scripts in /tr/translate.test.txt 
  >> pep.tt zig 

  * test but start at swap tests 
  >> pep.tt zig blah '# swap'

TOKENS 

 This token list is pretty useful for thinking about 
 sequences of tokens. Especially for error sequences.

  Literal BE!<>{}(),.;
  quoted*  text between "" or ''.  I will put "" around this and escape
           all " at the time of tokenising. This is because I want \n \r
           etc to work within strings. But it means I have to be careful
           about other escape sequences. like $ etc. 
  class*   eg [:space:] [abcd] [a-z] 
  word*    eg: eof,reparse,==
  begin*   the begin word
  parselabel* 
  command* eg: add clear print 
  test*    eg: "x" [:space:] !B"a" B"a" E"a" !E"a"
  ortest*  test*,*test*
  andtest*  test*.*test*
  statement* eg: clear; add "xx"; or "test" { ... }
  statementset* a list of statements 
  script*

*#

  read;

  # sort-of line-relative character numbers 
  [\n] { nochars; }
  # ignore space except in quotes. but be careful about silent
  # exit on read at eof
  [:space:] { 
     clear; (eof) { .reparse } !(eof) { .restart } 
  }

  # literal tokens, for readability maybe 'dot*' and 'comma*'
  [<>}()!BE,.;] { put; add "*"; push; .reparse }
  [{] { 
    # line and char number to help with missing close brace 
    # errors
    clear;
    add "line:"; lines; add " char:"; chars;
    put; clear; add "{*"; push; .reparse
  }

  # parse (eof) etc as tokens? yes

  # command names, need to do some tricks to parse ++ -- a+ etc
  # here. This is because [:alpha:],[+-] etc is not a union set
  # and while cannot do "while [:alpha:],[+-] etc

  # subtle bug, [+-^0=] parses as a range!!! [a-z]
  [:alpha:],[-+^0=] {

    # a much more succint abbreviation code
    "0" { clear; add "zero"; }
    "^" { clear; add "escape"; }
    # increment tape pointer ++ command
    "+" { while [+]; }
    # decrement tape pointer -- command
    "-" { while [-]; }
    # tape test (==)
    "=" { while [=]; }

    # for better error messages dont read ahead for the 
    # above commands.
    !"zero".!"escape".!B"+".!B"-".!B"=" {
      while [:alpha:]; 
    }

    # parse a+ or a- for the accumulator
    "a" { 
      # while [+-] is bug because compile.pss thinks its a range class
      # not a list class
      while [-+]; "a+","a-" { put; }
      "a" { clear; add "add"; }
    }

    # one letter command abbreviation expansions.
    # 'D' doesn't actually work in compile.pss !
    put; clear; add "#"; get; add "#";
    replace "#k#" "#clip#"; replace "#K#" "#clop#";
    replace "#D#" "#replace#"; replace "#d#" "#clear#"; 
    replace "#t#" "#print#"; replace "#p#" "#pop#"; replace "#P#" "#push#"; 
    replace "#u#" "#unstack#"; replace "#U#" "#stack#"; replace "#G#" "#put#"; 
    replace "#g#" "#get#"; replace "#x#" "#swap#"; replace "#m#" "#mark#"; 
    replace "#M#" "#go#"; replace "#r#" "#read#"; replace "#R#" "#until#"; 
    replace "#w#" "#while#"; replace "#W#" "#whilenot#"; replace "#n#" "#count#"; 
    replace "#c#" "#chars#"; replace "#C#" "#nochars#"; replace "#l#" "#lines#"; 
    replace "#L#" "#nolines#"; replace "#v#" "#unescape#"; 
    replace "#z#" "#delim#"; 
    replace "#S#" "#state#"; replace "#q#" "#quit#"; replace "#s#" "#write#"; 
    replace "#o#" "#nop#"; replace "#rs#" "#restart#"; replace "#rp#" "#reparse#"; 

    # remove leading/trailing #
    clip; clop; put;

    # dont want to use this syntax anymore because we already have
    # lines and 'l' or chars and 'c'
    "ll","cc" { 
      clear;
      add '* The syntax "'; get; add '" for lines or chars';
      add "  is no longer valid.\n";
      add "  use 'chars' or 'c' for a character count \n";
      add "  use 'lines' or 'l' for a line count \n";
      put; clear; add "nom.error*"; push; .reparse
    }

    "+","-" { 
      clear;
      add '* This syntax "'; get; add '" which were 1 letter abbreviations\n';
      add "  are no longer valid because.\n";
      add "  it is silly to have 1 letter abbrevs for 2 letter commands.";
      put; clear; add "nom.error*"; push; .reparse
    }

    # writefile is also a command?
    # commands parsed above
    "a+","a-","zero","++","--",
    "add","clip","clop","replace","upper","lower","cap","clear",
    "print","state","pop","push","unstack","stack","put","get","swap",
    "mark","go","read","until","while","whilenot",
    "count","zero","chars","lines","nochars","nolines",
    "escape","unescape","echar","delim","quit","write","nop" {
      clear; add "command*"; push; .reparse
    }

    # words not commands == was parsed above
    "parse","reparse","restart","eof","EOF","==" {
      put; clear; add "word*"; push; .reparse
    }

    "begin" { put; add "*"; push; .reparse }

    # lower case and check for command with error
    lower; 
    "add","clip","clop","replace","upper","lower","cap","clear",
    "print","state","pop","push","unstack","stack","put","get","swap",
    "mark","go","read","until","while","whilenot",
    "count","zero","chars","lines","nochars","nolines",
    "escape","unescape","echar","delim","quit", "write",
    "zero","++","--","a+","a-","nop",
    "begin","parse","reparse","restart" {
      ++; put; --;
      clear; 
      add '* incorrect command "'; get; add '"\n'; 
      add '- all nom commands and words are lower case \n';
      add '  (except for EOF and abbreviations) \n';
      add "- did you mean '"; ++; get; --; add "'?";

      put; clear; add "nom.error*"; push; .reparse
    }

    clear; add '* unknown word or command "'; get; add '"'; 
    add "

    - Valid nom commands are: 

    add clip clop replace upper lower cap clear 
    print state pop push unstack stack put get swap 
    mark go read until while whilenot 
    count zero chars lines nochars nolines 
    escape unescape delim quit write (writefile ?) 
    zero ++ -- a+ a- nop 
    
    - Valid nom words are 

    parse reparse restart begin eof EOF == 

    see www.nomlang.org/doc/commands/ \n";
    
    put; 
    clear; add "nom.error*"; push; .reparse
  }

  # single line comments
  # no need to rethink
  '#' {
    (eof) { clear; .reparse }
    read; 
    # just delete empty comments
    [#\n] { clear; .reparse }
    # multiline comments this needs to go within '#'
    "#*" {
      # save the start line number for error messages
      clear; 
      add "line:"; lines; add " char:"; chars; put; clear; 
      until "*#"; 
      !E"*#" { 
        clear; add '* unterminated multiline comment #*... \n  starting at '; 
        get; put; clear; add "nom.error*"; push; .reparse
      }
      clip; clip; put; clear;
      add "comment*"; push; .reparse 
    }
    clear; whilenot [\n]; put; 
    clear; add "comment*"; push; .reparse
  }

  # quoted text 
  # I will double quote all text and escape $ and \\ 
  # double quotes are for strings and single for chars in zig?
  '"' {
    # save the start line number (for error messages) in case 
    # there is no terminating quote character.
    clear; 
    add "line:"; lines; add " char:"; chars; put; clear; 
    until '"'; 
    !E'"',(eof) { 
      clear; add '* unterminated quote (") or incomplete command starting at '; 
      get; put; clear; add "nom.error*"; push; .reparse
    }
    # empty quotes are checked later.
    clip; 

    # this trick 
    unescape '"'; 
    #escape '\\'; 

    # I need to escape $ for variable names and @ for arrays in
    # zig double quoted strings. I think that is all. This is a thorny
    # issue because I want \n \t etc character substitution but not
    # the rest.
    escape "$"; escape "@"; 
    escape '"'; put; 
    clear; add '"'; get; add '"'; put; 
    clear; add "quoted*"; push; .reparse 
  }

  # single quotes
  "'" {
    clear; 
    # save start line/char of "'" for error messages
    add "line:"; lines; add " char:"; chars; put; clear; 
    until "'"; 
    !E"'",(eof) { 
      clear; add '* unterminated quote (\') or incomplete command starting at '; 
      put; clear; add "nom.error*"; push; .reparse
    }
    # empty quotes are checked later . must escape "\\" first 
    clip; unescape "'"; 
    # not sure about escaping this. It is causing problems with 2nd gen
    unescape '"'; 
    # escape '\\'; 

    escape "$"; escape "@"; 
    escape '"'; put; 

    clear; add '"'; get; add '"'; put; 
    clear; add "quoted*"; push; .reparse 
  }

  # classes like [:space:] or [abc] or [a-z] 
  # these are used in tests and also in while/whilenot
  # The *until* command will read past 'escaped' end characters eg \]
  # 

  "[" {
    clear; 
    # just leave brackets eg [:etc:]
    # save start line/char of '[' for error messages
    add "line:"; lines; add " char:"; chars; put; clear; 
    until "]"; 
    !E"]",(eof) { 
      clear; 
      add '* unterminated class [...] or incomplete command starting at '; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clip; put; 
    
    B":".E":".!":".!"::" { 
      clip; clop; put;
      # no nom class abbreviations, Unicode categories already have many
      # abbreviations, I will use those. I would like to accept any unicode
      # script/block/category but can't unless I want to code them.

      # these are ctype classes 

      "alnum","alpha","ascii","word","blank",
      "cntrl","digit","graph","lower","print",
      "punct","space","upper","xdigit" {
        # these will all be handled by the Machine.matchClass() method
        # because it will all be changed by grapheme clusters and 
        # by using unicode perl modules ?
        clear; add "[:"; get; add ":]"; put; 
        clear; add "class*"; push; .reparse 
      }

     # unicode category names, the first is an abbreviation of the 
     # second. It would be good to allow all lower case etc.

     # allow writing spaces or dots instead of _  This is ok because 
     # unicode script names dont have spaces or dots in them.
     replace " " "_"; replace "." "_"; 
     "L","Letter","Ll","Lowercase_Letter","Lu","Uppercase_Letter",
     "Lt","Titlecase_Letter","L&","Cased_Letter","Lm","Modifier_Letter",
     "Lo","Other_Letter","M","Mark","Mn","Non_Spacing_Mark",
     "Mc","Spacing_Combining_Mark","Me","Enclosing_Mark",
     "Z","Separator","Zs","Space_Separator","Zl","Line_Separator",
     "Zp","Paragraph_Separator","S","Symbol","Sm","Math_Symbol",
     "Sc","Currency_Symbol","Sk","Modifier_Symbol","So","Other_Symbol",
     "N","Number","Nd","Decimal_Digit_Number","Nl","Letter_Number",
     "No","Other_Number","P","Punctuation","Pd","Dash_Punctuation",
     "Ps","Open_Punctuation","Pe","Close_Punctuation","Pi","Initial_Punctuation",
     "Pf","Final_Punctuation","Pc","Connector_Punctuation","Po",
     "Other_Punctuation","C","Other","Cc","Control","Cf","Format",
     "Co","Private_Use","Cs","Surrogate","Cn","Unassigned" {
       add ":
         This nom->perl translator does not currently support unicode character 
         category names in nom classes. You could try the nom->dart
         translator if you really need them:
           nomlang.org/tr/nom.todart.pss \n";
       put; clear; add "nom.error*"; push; .reparse
     }

      # unicode script names, 
      "Common","Arabic","Armenian","Bengali","Bopomofo",
      "Braille","Buhid","Canadian_Aboriginal","Cherokee",
      "Cyrillic","Devanagari","Ethiopic","Georgian","Greek",
      "Gujarati","Gurmukhi","Han","Hangul","Hanunoo",
      "Hebrew","Hiragana","Inherited","Kannada","Katakana",
      "Khmer","Lao","Latin","Limbu","Malayalam","Mongolian",
      "Myanmar","Ogham","Oriya","Runic","Sinhala","Syriac",
      "Tagalog","Tagbanwa","TaiLe","Tamil","Telugu","Thaana",
      "Thai","Tibetan","Yi" {
        add ":
         This nom->perl translator does not currently support unicode script 
         names in nom classes. You could try the nom->dart
         translator if you really need them:
           nomlang.org/tr/nom.todart.pss \n";
        put; clear; add "nom.error*"; push; .reparse
      }

      # blocks

      # unicode block names. not supported 
      "InBasic_Latin","InLatin-1_Supplement","InLatin_Extended-A",
      "InLatin_Extended-B","InIPA_Extensions","InSpacing_Modifier_Letters",
      "InCombining_Diacritical_Marks","InGreek_and_Coptic","InCyrillic",
      "InCyrillic_Supplementary","InArmenian","InHebrew","InArabic",
      "InSyriac","InThaana","InDevanagari","InBengali","InGurmukhi",
      "InGujarati","InOriya","InTamil","InTelugu","InKannada",
      "InMalayalam","InSinhala","InThai","InLao","InTibetan","InMyanmar",
      "InGeorgian","InHangul_Jamo","InEthiopic","InCherokee",
      "InUnified_Canadian_Aboriginal_Syllabics","InOgham","InRunic",
      "InTagalog","InHanunoo","InBuhid","InTagbanwa","InKhmer",
      "InMongolian","InLimbu","InTai_Le","InKhmer_Symbols",
      "InPhonetic_Extensions","InLatin_Extended_Additional",
      "InGreek_Extended","InGeneral_Punctuation",
      "InSuperscripts_and_Subscripts","InCurrency_Symbols",
      "InCombining_Diacritical_Marks_for_Symbols","InLetterlike_Symbols",
      "InNumber_Forms","InArrows","InMathematical_Operators",
      "InMiscellaneous_Technical","InControl_Pictures",
      "InOptical_Character_Recognition","InEnclosed_Alphanumerics",
      "InBox_Drawing","InBlock_Elements","InGeometric_Shapes",
      "InMiscellaneous_Symbols","InDingbats",
      "InMiscellaneous_Mathematical_Symbols-A","InSupplemental_Arrows-A",
      "InBraille_Patterns","InSupplemental_Arrows-B",
      "InMiscellaneous_Mathematical_Symbols-B",
      "InSupplemental_Mathematical_Operators",
      "InMiscellaneous_Symbols_and_Arrows","InCJK_Radicals_Supplement",
      "InKangxi_Radicals","InIdeographic_Description_Characters",
      "InCJK_Symbols_and_Punctuation","InHiragana","InKatakana",
      "InBopomofo","InHangul_Compatibility_Jamo","InKanbun",
      "InBopomofo_Extended","InKatakana_Phonetic_Extensions",
      "InEnclosed_CJK_Letters_and_Months","InCJK_Compatibility",
      "InCJK_Unified_Ideographs_Extension_A","InYijing_Hexagram_Symbols",
      "InCJK_Unified_Ideographs","InYi_Syllables","InYi_Radicals",
      "InHangul_Syllables","InHigh_Surrogates",
      "InHigh_Private_Use_Surrogates","InLow_Surrogates",
      "InPrivate_Use_Area","InCJK_Compatibility_Ideographs",
      "InAlphabetic_Presentation_Forms","InArabic_Presentation_Forms-A",
      "InVariation_Selectors","InCombining_Half_Marks",
      "InCJK_Compatibility_Forms","InSmall_Form_Variants",
      "InArabic_Presentation_Forms-B","InHalfwidth_and_Fullwidth_Forms",
      "InSpecials" {
         add ":
           This nom->perl translator does not currently support unicode block 
           names in nom class patterns. ";
         put; clear; add "nom.error*"; push; .reparse
      }

      clear; 
      add "* Incorrect nom character class\n"; 
      add ' 
      Character classes are used in tests and the nom while 
      and whilenot commands
        eg: [:space:] { while [:space:]; clear; } 
        or: [:alnum:] { while [:alnum:]; clear; } \n';
      put; clear; add "nom.error*"; push; .reparse
    }
    # not using regexes for matching classes in this translator
    # ] should already be escaped in the nom class
    # this is a normal escape so as not to break the '...'
    escape '"'; unescape ']'; put;
    clear; add "["; get; add "]"; put;
    clear; add "class*"; push; .reparse
  }

  !"" {
    put; clear; 
    add "* strange character found '"; get; add "'\n\n"; 
    add "  see www.nomlang.org/doc/syntax for nom syntax documentation \n"; 
    put; clear; add "nom.error*"; push; .reparse
  }

 parse>
  # watch the parse-stack resolve.  
  # add "--> line "; lines; add " char "; chars; add ": "; print; clear; 
  # unstack; print; stack; add "\n"; print; clear;
   
  # ----------------
  # error trapping and help here
  pop;

  # parse help token for a topic, category of # topics or everthing. 
  "nom.help*" {
    # the topic or category to display help for is in the attribute
    clear; swap; 

    # a short list of commands and abbreviations 
    "commands.shortlist","commands","all" {
      swap; add "
      # 'D' doesn't actually work in compile.pss !
      nom abbreviations and commands: 

        zero k clip K clop D replace d clear
        t print p pop P push u unstack U stack G put g get x swap
        m mark M go r read R until w while W whilenot n count c chars C nochars 
        l lines L nolines v escape unescape z delim S state q quit s write
        o nop .rs .restart .rp .reparse
        (no abbreviations)
        a+ a- ++ --

          ";
    }

    # specific help for the add command 
    "command.add","commands","all" {
      swap; add "
      add command:
        add text to end of the workspace buffer
        see: nomlang.org/doc/commands/nom.add.html
      eg:
        add ':tag:';     # correct
        add [:space:];   # incorrect, cannot have class parameter 
        add;             # incorrect, missing parameter
          ";
    }

    #  
    "semicolon","punctuation","all" {
      swap; add "
       semicolon:
         All statements (commands) must end with a semi-colon 
         except .reparse and .restart (even the last command in
         the block)
       eg:
         clear; .reparse       # correct
         clear add '.';        # incorrect, clear needs ; 
         ";
    }


    # 'brackets' is topic, 'punctuation' is a category, 'all' is everthing 
    "brackets","punctuation","all" {
      swap; add "
      brackets () 
        are used for tests like (eof) (EOF) (==) 
        currently (2025) brackets are not used for logical grouping in 
        tests.
      examples:
         (==)                  # correct
         (==,'abc' { nop; }    # incorrect: unbalanced ";
    }

    "negation","punctuation","all" {
      swap; add "
      negation operator ! 
        is used for negating class and equals tests and with the 
        B and E modifiers. It should precede the test and the 
        B and E modifiers.

      examples:
         !(eof) { add '.'; }   # correct, not at end-of-file
         ![:space:] { clear; } # correct 
         'abc'! { clear; }     # incorrect: ! must precede test.
         B!'abc' { clear; }    # incorrect: ! must precede 'B'  ";
    }


    # 
    "modifiers","tests","all" {
      swap; add "
      begins-with 'B' and ends-with 'E' modifiers:
        are used with quoted text tests and cannot be used with 
        class tests.
      eg: 
        B'abc' { clear; }        # correct 
        E\"abc\" { clear; }      # correct 
        B[:alpha:] { clear; }  # incorrect  ";
    }

    # help for the help system 
    "help","help","all" {
      swap; add "
        help system:
          categories: tests, commands, punctuation etc
          type '#:help <command>' in a [nom] script to get help
          for a particular command or word or category
        eg:
          #:help add    # shows help for the add command
          #:help tests  # shows help nom block tests.
        ";
    }

    # This help system quits after showing the help message
    # but you could keep parsing if there is any point. 
    add "\n\n"; print; quit; 
  }

  "nom.error*" {
    # get the parse stack here as well
    clear; 
    add "! Nom syntax:";
    add " near line:"; lines; add " char:"; chars; add "\n";
    get; 
    add "\n run /eg/nom.syntax.reference.pss for more detailed \n"; 
    add " syntax checking. See www.nomlang.org/doc for complete-ish \n";
    add " pep and nom documentation. \n";
    print;
    # provide help from the help* token if one was put on the stack. 
    clear; pop; "nom.help*" { push; .reparse } 
    quit;
  }

  # this error is when the error should have been trapped earlier
  "nom.untrapped.error*" {
    clear; 
    add "! Nom untrapped error! :";
    add " near line:"; lines; add " char:"; chars; add "\n";
    get; 
    add "\n run /eg/nom.syntax.reference.pss for more detailed \n"; 
    add " syntax checking. \n";
    print; quit;
  }

  #----------------
  # 2 parse token errors

  #*
  possible tokens: 
  literal* BE!<>{}(),.;
  quoted* class* word* command* test*
  ortest* andtest* statement* statementset* 
  *#

  # none of these literal tokens can start a sequence because
  # they should have already reduced to a subpattern (token)
  pop;

  "B*class*","E*class*" {
    clear; 

    clear; add "modifiers"; put; 
    clear; add "nom.help*"; push;
    add "  B or E modifier before class test."; put; 
    clear; add "nom.error*"; push; .reparse
  }

  # general token sequence errors

  # literal token error sequences.

  B"}*",B";*",B">*",B")*" {
    clear; add "* misplaced } or ; or > or ) character?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  B"B*",B"E*" {
    E"!*" {
      clear; add "negation"; put; 
      clear; add "nom.help*"; push;
      add "* The negation operator (!) must precede the  \n"; 
      add "  begins-with (B) or ends-with (E) modifiers \n";
      put; clear; add "nom.error*"; push; .reparse
    }
  }

  B"B*".!"B*".!E"quoted*" {
    clear; 
    add "* misplaced begin-test modifier 'B' ?"; 
    add "  eg: B'##' { d; add 'heading*'; push; .reparse } "; 
    put; clear; add "nom.error*"; push; .reparse
  }

  B"E*".!"E*".!E"quoted*" {
    clear; 
    add "* misplaced end-test modifier 'E' ?"; 
    add "  eg: E'.' { d; add 'phrase*'; push; .reparse } "; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # empty quote after B or E
  B"E*".E"quoted*" {
    clear; ++; get; --;
    '""' {
      clear; add "modifiers"; put; 
      clear; add "nom.help*"; push;
      add "  Empty quote after 'E' modifier "; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "E*quoted*"; 
  }

  B"B*".E"quoted*" {
    clear; ++; get; --;
    '""' {
      clear; add "modifiers"; put; 
      clear; add "nom.help*"; push;
      add "  Empty quote after 'B' modifier "; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "B*quoted*"; 
  }
  
  B"!*".!"!*".!E"(*".!E"<*".!E"B*".!E"E*".!E"quoted*".!E"class*".!E"test*" {
    clear; 
    add "* misplaced negation operator (!) ?"; 
    add "  e.g. \n";
    add "   !B'$#@' { clear; }   # correct \n"; 
    add '   !"xyz" { clear; }   # correct \n'; 
    add '   "abc"! { clear; }   # incorrect \n'; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # comma sequence errors, 2 tokens
  # error eg: ,,
  B",*".!E"(*".!E"<*".!E"!*".!E"B*".!E"E*".
  !E"quoted*".!E"class*".!E"test*" {
    clear; add "* misplaced comma ?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: . {
  B".*".!E"(*".!E"<*".!E"!*".!E"B*".!E"E*".
  !E"quoted*".!E"class*".!E"test*".!E"word*" {
    clear; add "* misplaced dot?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: {}
  B"{*".E"}*" {
    clear; add "* empty block {} "; put;
    clear; add "nom.error*"; push; .reparse
  }
  
  # error eg: { ,
  B"{*".!"{*" {
    E">*",E",*",E")*",E"{*",E"}*",E";*" {
      clear; add "* misplaced character '"; ++; get; --; add "' ?"; put;
      clear; add "nom.error*"; push; .reparse
    }
  }
  
  # try to diagnose missing close brace errors at end of script
  # eg ortest*{*statement*
  # we probably need a line/char number in the tape cell
  (eof) {
    "{*statement*","{*statementset*" {
      clear; 
      add "* missing close brace (}) ?\n"; 
      add "  At "; get; add " there is an opening brace ({) which does \n"; 
      add "  not seem to be matched with a closing brace ";
      put; clear; add "nom.error*"; push; .reparse
    }
  }

  # missing dot
  # error eg: clear; reparse 
  !B".*".E"word*".!"word*" {
    push; push; --; get; ++; 
    "reparse","restart" {
      clear; add "* missing dot before reparse/restart ? "; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; pop; pop;
  }

  # error eg: ( add
  # currently brackets are only used for tests
  B"(*".!"(*".!E"word*" {
    clear; add "* strange syntax after '(' "; put;
    clear; add "nom.error*"; push; .reparse
  }

  "<*;*" {
    clear; 
    add "* '<' used to be an abbreviation for '--' \n"; 
    add "* but no-longer (mar 2025) since it clashes with <eof> etc "; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # error eg: < add
  # currently angle brackets are only used for tests ( <eof> <==> ) 
  B"<*".!"<*".!E"word*" {
    clear; add "* bad test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  ">*;*" {
    clear; 
    add "* '>' used to be an abbreviation for '++' \n"; 
    add "  but no-longer (mar 2025) since it clashes with <eof> etc \n"; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # error eg: begin add
  B"begin*".!"begin*".!E"{*" {
    clear; 
    add "* begin is always followed by a brace.\n"; 
    add "   eg: begin { delim '/'; }\n"; 
    put; clear; add "nom.error*"; push; .reparse
  }

  # error eg: clear; begin { clear; }
  E"begin*".!"begin*".!B"comment*" {
    clear; add "* only comments can precede a begin block."; put;
    clear; add "nom.error*"; push; .reparse
  }

  "command*}*" {
    clear; add "* missing semicolon? "; 
    add "
     In nom all commands except .reparse and .restart 
     must be terminated with a semicolon, even the last 
     command in a block {...} 

     see www.nomlang.org/doc/syntax/ for details \n";
    put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: clear {
  B"command*".!"command*".!E";*".!E"quoted*".!E"class*" {
    clear; add "* bad command syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # specific analysis of the token sequences permitted above
  "command*class*" {
    clear; get; 
    !"while".!"whilenot" {
      clear; 
      add "* command '"; get; add "' does not take class argument.\n"; 
      add "  see www.nomlang/doc/commands/nom."; get; add ".html "; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*class*";
  }

  "command*quoted*" {
    clear; get; 
    !"add".!"replace".!"mark".!"go".!"until".
    !"delim".!"escape".!"unescape".!"echar" {
      clear; 
      add "* command '"; get; add "' does not take quoted argument.\n\n"; 
      add "  see www.nomlang/doc/commands/nom."; get; add ".html ";
      add "  for details.";
      put; clear; add "nom.error*"; push; .reparse
    }
    # for the delimiter and the escape char only allow one 'character'
    # (ie unicode code-point) not a unicode grapheme cluster, which
    # could be several 'characters'. This is because it is unnecessary and
    # I doubt that any language is going to use a grapheme cluster as
    # an escape character.
    "delim","echar" {
      clear; ++; get; --; 
      clip;clop;clip;
      !"" {
        clear; add "* multiple char argument to 'delim' or 'echar'. "; put;
        clear; add "nom.error*"; push; .reparse
      }
    }
    # check that not empty argument.
    clear; ++; get; --;
    '""' {
      clear; 
      add "* empty quoted text ('' or \"\") is an error here.\n\n"; 
      add "  - The 2nd argument to 'replace' can be an empty quote\n";
      add "    eg: replace 'abc' ''; # replace 'abc' with nothing \n";
      add "  - Also, empty quotes can be used in tests \n";
      add "    eg: '' { add 'xyz'; } !'' { clear; } \n";
      put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*quoted*";
  }

  "command*;*" {
    clear; get; 
    "add","replace","while","whilenot","delim","escape","unescape","echar" {
      clear; 
      add "* command '"; get; add "' requires argument."; 
      add "- eg: add 'abc'; while [:alnum:]; escape ']'; "; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*;*";
  }

  # end-of-script 2 token command errors.
  (eof) {
    E"command*" {
      clear; 
      add "* unterminated command '"; get; add "' at end of script"; 
      put; clear; add "nom.error*"; push; .reparse
    }
    "command*quoted*","command*class*" {
        clear; 
        add "* unterminated command '"; get; add "' at end of script"; 
        put; clear; add "nom.error*"; push; .reparse
    }
  }

  # error eg: "xx" }
  B"quoted*".!"quoted*".!E"{*".!E"quoted*".!E";*".!E",*".!E".*" {
    clear; 
    add " dubious syntax (eg: missing semicolon ';') after quoted text."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: [:space:] }
  B"class*".!"class*".!E"{*".!E";*".!E",*".!E".*" {
    clear; add "semicolon"; put; 
    clear; add "nom.help*"; push;
    clear; add "* missing semi-colon after class? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # A word is not a command. reparse and restart have already reduced.
  # error eg: eof (
  B"word*".!"word*".!E")*".!E">*" {
    clear; add "* bad syntax after word."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: E"abc";
  B"test*".!"test*".!E",*".!E".*".!E"{*" {
    clear; add "* bad test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error "xx","yy"."zz"
  B"ortest*".!"ortest*".E".*" {
    clear; add "* AND '.' operator in OR test."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa" "abc";
  "ortest*quoted*","ortest*test*" {
    clear; add "* missing comma in test?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa",E"abc";
  B"ortest*".!"ortest*".!E",*".!E"{*" {
    clear; add "* bad OR test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error "xx"."yy","zz"
  B"andtest*".!"andtest*".E",*" {
    clear; add "* OR ',' operator in AND test."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa".E"abc";
  "andtest*quoted*","andtest*test*" {
    clear; add "* missing dot in test?"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "aa".E"abc";
  B"andtest*".!"andtest*".!E".*".!E"{*" {
    clear; add "* bad AND test syntax."; put;
    clear; add "nom.error*"; push; .reparse
  }

  # end-of-script 2 token test errors.
  (eof) {
    E"test*",B"test*",E"ortest*",B"ortest*",E"andtest*",B"andtest*" {
      clear; 
      add "* test with no block {} at end of script"; 
      put; clear; add "nom.error*"; push; .reparse
    }
  }

  # error eg: add 'x'; { 
  B"statement*".!"statement*" {
    E",*",E"{*" {
      clear; add "* misplaced dot/comma/brace ?"; put;
      clear; add "nom.error*"; push; .reparse
    }
  }

  # error eg: clear;add 'x'; { 
  B"statementset*".!"statementset*" {
    E",*",E"{*" {
      clear; add "* misplaced dot/comma/brace ?"; put;
      clear; add "nom.error*"; push; .reparse
    }
  }

  # specific command errors

  # until, mark, go etc have no-parameter versions
  "command*;*" {
    clear; get;
    "add","replace","while","whilenot","delim","escape","unescape","echar" {
      clear; add "* command '"; get; add "' requires argument"; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*;*";
  }

  #----------------
  # 3 parse token errors, 
  pop;

  # missing semicolon errors?
  # error eg: [:space:] { whilenot [:space:] }
  B"command*class*".!"command*class*".!E";*" {
    clear; add "semicolon"; put; 
    clear; add "nom.help*"; push;
    clear; add "* missing semi-colon after statement? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # missing semicolon errors
  # error eg: [:space:] { until "</em>" }
  B"command*quoted*".!"command*quoted*".!E";*".!E"quoted*" {
    clear; add "* missing semi-colon after statement? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: "cd" "ef" {
  B"quoted*quoted*".!E";*" {
    clear; add "* missing comma or dot in test? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  # error eg: , "cd" "ef"
  E"quoted*quoted*".!B"command*" {
    clear; add "* missing comma or dot in test? "; put;
    clear; add "nom.error*"; push; .reparse
  }

  "command*quoted*quoted*" {
    clear; get; 
    !"replace" {
      clear; 
      add "* command '"; get; add "' does not take 2 quoted arguments.\n"; 
      add "- The only nom command with 2 quoted arguments is 'replace'."; 
      put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*quoted*quoted*";
  }

  # error eg: clear "x"; already checked above.
  # "command*quoted*;*" {}

  # error eg: add [:space:] already checked above in 2 tokens
  # "command*class*;*" {}

  #----------------
  # 4 parse token errors
  pop;
  "command*quoted*quoted*;*" {
    clear; get;
    !"replace" {
      clear; add "* command '"; get; add "' does not take 2 arguments."; put;
      clear; add "nom.error*"; push; .reparse
    }
    # check that not 1st argument is empty
    clear; ++; get; --;
    '""' {
      clear; add "* empty quoted text '' is an error here."; put;
      clear; add "nom.error*"; push; .reparse
    }
    clear; add "command*quoted*quoted*;*";
  }

  push;push;push;push;
  # end of errors
  # ----------------

  # ----------------
  # 2 grammar parse tokens 
  pop;pop;
  
  # permit comments anywhere in script
  #
  B"comment*".!"comment*" {
    # A translator would try to conserve the comment.
    replace "comment*" ""; push; 
    get; --; put; ++; clear;
    .reparse
  }

  E"comment*".!"comment*" {
    replace "comment*" ""; push; .reparse
  }

  #------------ 
  # The .restart command jumps to the first instruction after the
  # begin block (if there is a begin block), or the first instruction
  # of the script.
  ".*word*" {
    clear; ++; get; --;
    "restart" {
      clear; add "next SCRIPT;"; put; 
      clear; add "statement*"; push; .reparse 
    }
    "reparse" {
      clear; 
      # check accumulator to see if we are in the "lex" block
      # or the "parse" block and adjust the .reparse compilation
      # accordingly.
      count; 
      # if the count is not 0/1 then something is wrong. Probably
      # > 1 parse> label which should have already been trapped.
      !"0".!"1" {
        clear; add "* multiple parse label error?"; put;
        clear; add "nom.untrapped.error*"; push; .reparse
      }
      "0" { clear; add "last LEX;"; }
      "1" { clear; add "next PARSE;"; }
      # for languages that have goto we can use the following
      # add "goto parse;";
      put; 
      clear; add "statement*"; push; .reparse 
    }
    clear; add "* invalid statement ."; put;
    clear; add "nom.untrapped.error*"; push; .reparse
  }

  "word*>*" {
    clear; get; 
    "parse" { 
      clear; count;
      !"0" {
        clear; 
        add "script error:\n";
        add "  extra parse> label at line "; lines; add ".\n";
        print;
        quit;
      }
      clear; add "--> parse>"; put;
      clear; add "parselabel*"; push;
      # use accumulator to indicate after parse> label
      a+; .reparse 
    }
    clear; add "word*>*";
  }

  #-----------------------------------------
  # format: E"text" {...} or E'text' {...}
  # the ends-with test. The \Q...\E construct quotes all 'meta'
  # pattern characters so they will be matched literally. I wonder 
  # if this is slower than the substr approach
  "E*quoted*" {
    # remove quotes around text and unescape escaped chars 
    clear; 
    ++;
    add "(length("; get; add ") <= length($self->{work})) && ";
    add "(substr($self->{work}, -length("; get; add ")) eq "; get; add ")"; 
    --; put;
    clear; add "test*"; push; .reparse
  } 

  #*
    This is perl code to do an 'ends with' test using substr which
    may be faster than a regex.
    # If the suffix is longer than the string, it can't be a suffix.
    return 0 if length($suffix) > $length($string);
    return substr($string, -$length($suffix)) eq $suffix;
  *#

  #-----------------------------------------
  # format: B"sometext" or B'sometext' 
  #  The begins-with test. I use a substring equals approach in perl
  #  for speed and to avoid regular expression meta-quoted issues.
  #  I dont think it is necessary to bracket this expression?
  "B*quoted*" {
    clear; add "substr($self->{work}, 0, length("; ++; get; add ")) eq "; 
    get; --; put;
    clear; add "test*"; push; .reparse
  } 

  #---------------------------------
  # Compiling comments so as to transfer them to the output code
  # but comments in some places are an error.
  "comment*statement*","statement*comment*","statementset*comment*" {
    clear; get; add "\n"; ++; get; --; put; clear;
    add "command*"; push; .reparse
  }
  "comment*comment*" {
    clear; get; add "\n"; ++; get; --; put; clear;
    add "comment*"; push; .reparse
  }

  # -----------------------
  # negated tokens.
  #  This format is used to indicate a negative test for 
  #  a brace block. eg: ![aeiou] { add "< not a vowel"; print; clear; }
  # eg: ![:alpha:] ![a-z] ![abcd] !"abc" !B"abc" !E"xyz"
  "!*test*" {
    clear; add "!("; ++; get; --; add ")"; put; 
    clear; add "test*"; push; .reparse
  }

  # transform quotes and classses to tests, this greatly reduces the number
  # of rules required for other reductions
  ",*quoted*",".*quoted*","!*quoted*" { 
    push; clear; add "$self->{work} eq "; get; put;
    clear; add "test*"; push; .reparse
  }

  # transform quotes to tests
  "quoted*,*","quoted*.*","quoted*{*" { 
    replace "quoted*" "test*"; push; push; 
    --; --; add "$self->{work} eq "; get; put;
    ++; ++; clear; .reparse
  }

  # transform classes to tests, all characters in the workspace need
  # to match the (unicode) class, category or unicode script name for the 
  # class test to return true. Empty workspace never matches.
  ",*class*",".*class*","!*class*" { 
    push; clear; 
    add '$self->matchClass($self->{work}, "'; get; add '")';
    put; clear; add "test*"; push; .reparse
  }

  # transform classes to tests
  "class*,*","class*.*","class*{*" { 
    replace "class*" "test*"; push; push; 
    --; --; 
    add '$self->matchClass($self->{work}, "'; get; add '")';
    put; 
    ++; ++; clear; .reparse
  }

  #--------------------------------------------
  # ebnf: command := command ';' ;
  # formats: "pop; push; clear; print; " etc
  "command*;*" {
     clear; get;

     # error trap here .
     !"go".!"mark".!"until".!"clip".!"clop".!"clear".!"upper".!"lower".
     !"cap".!"print".!"pop".!"push".!"unstack".!"stack".!"state".!"put".!"get".
     !"swap".!"++".!"--".!"read".!"count".!"a+".!"a-".!"zero".!"chars".
     !"lines".!"nochars".!"nolines".!"quit".!"write".!"nop" {
       clear; add "  incorrect command syntax?"; put;
       clear; add "nom.untrapped.error*"; push; .reparse
     }

     # go; not implemented in pars/compile.pss yet (feb 2025)
     "go" { 
       clear;
       add "$self->goToMark($self->{tape}[$self->{cell}]);  # go (tape) ";
     }
     "mark" { 
       clear;
       add "$mark = $self->{tape}[$self->{cell}];\n";
       add "$self->addMark($mark);  # mark (tape) ";
     }

     # the new until; command with no argument
     "until" { 
       clear;
       add "$text = $self->{tape}[$self->{cell}];\n";
       add "$self->readUntil($text); "; 
       add "# until (tape)";
     }

     "clip" { 
       # use chop for code points not grapheme clusters
       clear; add "$self->{work} =~ s/\\X$//; # clip";
     }
     "clop" { 
       # use Unicode:GCString; is one option for perl grapheme clusters
       # but \\X should work.
       clear; add "$self->{work} =~ s/^\\X//; # clop";
     }
     "clear" { 
       clear; add "$self->{work} = '';  # clear ";
     }
     "upper" { 
       # grapheme clusters?
       clear; add "$self->{work} = uc($self->{work});  # upper"; 
     }
     "lower" { 
       clear; add "$self->{work} = lc($self->{work});  # lower";
     }
     "cap" { 
       clear; 
       # capitalize every word not just the first.
       # other translators and pep just capitalise the first letter
       # but thats silly. This command "cap" is not really required.
       add "$self->capitalise(); # cap "; 
     }
     "print" { 
       clear; 
       # write to stdout/file/string
       add "$self->writeText(); # print  ";
     }
     "pop" { clear; add "$self->popToken();"; }
     "push" { clear; add "$self->pushToken();"; }
     "unstack" { clear; add "while ($self->popToken()) { next; }   # unstack "; }
     "stack" { clear; add "while ($self->pushToken()) { next; }   # stack "; }
     "state" { clear; add "$self->printState();    # state "; }
     "put" { 
       clear; 
       add "${$self->{tape}}[$self->{cell}] = $self->{work};   # put "; 
     }
     "get" { 
       clear; 
       add "$self->{work} .= $self->{tape}[$self->{cell}];  # get";
       # add "$self->{work} .= ${$self->{tape}}[$self->{cell}];  # get";
     }
     "swap" { 
       clear; 
       add "($self->{tape}[$self->{cell}], $self->{work}) = ";
       add "($self->{work}, $self->{tape}[$self->{cell}]);  # swap";
     }
     # need a method because we may need to increase the tape size.
     "++" { clear; add "$self->increment();   # ++ "; }
     "--" { 
       clear; add "if ($self->{cell} > 0) { $self->{cell} -= 1; } # --"; 
     }
     "read" { 
       clear; 
       # it is better to break out of the nom script loop than exit() or 
       # return because we may need to close open files or flush written
       # file content.
       add "if ($self->{eof}) { last SCRIPT; } $self->readChar(); # read ";
     }
     "count" { 
       clear; 
       add "$self->{work} .= $self->{accumulator}; # count "; 
     }
     "a+" { clear; add "$self->{accumulator} += 1; # a+ "; }
     "a-" { clear; add "$self->{accumulator} -= 1; # a- "; }
     "zero" { clear; add "$self->{accumulator} = 0; # zero "; }
     "chars" { 
       clear; add "$self->{work} .= $self->{charsRead}; # chars "; 
     }
     "lines" { 
       clear; add "$self->{work} .= $self->{linesRead}; # lines "; 
     }
     "nochars" { clear; add "$self->{charsRead} = 0; # nochars "; }
     "nolines" { clear; add "$self->{linesRead} = 0; # nolines "; }
     # use a labelled loop to quit script.
     # better to break than return because can close open files etc.
     "quit" { clear; add "last SCRIPT; # quit "; }
     "write" { 
       clear; add "open my $fh, '>:utf8', 'sav.pp';\n";
       add "print $fh $self->{work}; close $fh; # write";
     }
     # just eliminate since it does nothing.
     "nop" { clear; add "# removed nop: does nothing "; }

     put; clear; add "statement*";
     push; .reparse
   }

  "statementset*statement*","statement*statement*" {
    clear; get; add "\n"; ++; get; --; put;
    clear; add "statementset*"; push; .reparse
  }

  # ----------------
  # 3 grammar parse tokens 
  pop;
  "(*word*)*","<*word*>*" {
    clear; ++; get; --;

    !"eof".!"==" {
      clear; add "* invalid test <> or () ."; put;
      clear; add "nom.untrapped.error*"; push; .reparse
    }
    "eof" { 
      clear; add "$self->{eof}";
    }
    "==" { 
      clear; add "$self->{tape}[$self->{cell}] eq $self->{work}";
    }
    put; clear; add "test*"; push; .reparse 
  }

  #--------------------------------------------
  # quoted text is already double quoted eg "abc" 
  # eg: add "text";
  "command*quoted*;*" {
    clear; get;
    # error trap here 
    !"mark".!"go".!"delim".!"add".!"until".
    !"escape".!"unescape".!"echar" {
      clear; 
      add "  superfluous argument or other error?\n"; 
      add "  (error should have been trapped in error block: check)"; 
      put; clear; add "nom.untrapped.error*"; push; .reparse
    }

    "mark" {
      clear; add '$self->addMark('; ++; get; --; add '); # mark ';
    }
    "go" {
      clear; add '$self->goToMark('; ++; get; --; add '); # go ';
    }

    "delim" {
      # perl has a char type?, but it is for 'code points' not 
      # grapheme clusters (diacritics etc). So technically the 'delim'
      # char could be a string of several chars but in practice this 
      # is not necessary.
      # have already verified one char in error block 
      clear; add "$self->{delimiter} = "; ++; get; --; add "; # delim ";
    }

    "add" {
      clear; add '$self->{work} .= '; ++; get; --; 
      # handle multiline text
      # it is possible to just use multiline strings in some languages
      # but they will be indented by the translator, so they will have 
      # handle multiline text check this! \\n or \n
      # more indentation than the script writer intended...

      # this is more readable than just adding 
      replace "\n" '";\n$self->{work} .= "\\n';
      add '; # add ';
    }

   
    # read until workspace ends with text
    "until" {
       clear; add '$self->readUntil('; ++; get; --; 
       # handle multiline argument
       replace "\n" "\\n"; add ');'; 
     }

    "escape","unescape" {
       # only use the first char or grapheme cluster of escape argument?
       # cant use single quotes because they are not interpolated
       # an chars like $ and @ are escaped in perl
       clear; add "$self->"; get; add "Char"; 
       add "("; ++; get; --; add ");"; 
     }

     # can only be a unicode codepoint not grapheme cluster because 
     # I say so.
     "echar" {
       # 
       clear; add "$self->{escape} = "; ++; get; --; add "; # echar ";
     }

     put; clear; add "statement*"; push; .reparse
   }

  # eg: while [:alpha:]; or whilenot [a-z];
  "command*class*;*" {
    clear; get;

    # 
    "while" {
      clear;
      add "# while \n";
      add 'while ($self->matchClass($self->{peep}, "'; ++; get; --; 
      add '")) {\n';
      add "  if ($self->{eof}) { last; } $self->readChar();\n}"; 
      put; clear; add "statement*"; push; .reparse
    }

    "whilenot" {
      clear;
      add "# whilenot   \n";
      add 'while (!$self->matchClass($self->{peep}, "'; ++; get; --; 
      add '")) {\n';
      add "  if ($self->{eof}) { last; } $self->readChar();\n}"; 
      put; clear; add "statement*"; push; .reparse
    }
    clear; add "*** unchecked error in rule: statement = command class ;"; put;
    clear; add "nom.error*"; push; .reparse
  }

  # brackets around tests will be ignored.
  "(*test*)*" {
    clear; ++; get; --; put; clear;
    add "test*"; push; .reparse
  }

  # brackets will allow mixing AND and OR logic 
  "(*ortest*)*","(*andtest*)*" {
    clear; ++; get; --; put; clear;
    add "test*"; push; .reparse
  }

  # -------------
  # parses and compiles concatenated tests
  # eg: 'a',B'b',E'c',[def],[:space:],[g-k] { ...

  "test*,*test*","ortest*,*test*" {
    # OR logic concatenation 
    # put brackets around tests even though operator 
    # precedence should take care of it
    "test*,*test*" {
      clear; add "("; get; add ")";
    }
    "ortest*,*test*" { clear; get; } 
    add " || ("; ++; ++; get; --; --; add ")"; 
    put; clear; add "ortest*"; push; .reparse
  }

  # -------------
  # AND logic 
  # parses and compiles concatenated AND tests
  # eg: 'a',B'b',E'c',[def],[:space:],[g-k] { ...
  # negated tests can be chained with non negated tests.
  # eg: B'http'.!E'.txt' { ... }
  "test*.*test*","andtest*.*test*" {
    # AND logic concatenation 
    # add brackets 
    "test*.*test*" {
      clear; add "("; get; add ")";
    }
    "andtest*.*test*" { clear; get; } 
    add " && ("; ++; ++; get; --; --; add ")"; 
    put; clear; add "andtest*"; push; .reparse
  }

  # dont need to reparse 
  "{*statement*}*" { replace "ment*" "mentset*"; }

  # ----------------
  # 4 grammar parse tokens 
  pop;

  # see below
  # "command*quoted*quoted*;*" { clear; add "statement*"; push; .reparse }

  # eg:  replace "and" "AND" ; 
  "command*quoted*quoted*;*" {
    clear; get;
    "replace" {
      #---------------------------
      # a command plus 2 arguments, eg replace "this" "that"
      # multiline replace? no. 
      clear;
      add '$self->replace('; ++; get; add ', '; ++; get; 
      add ');  # replace '; 
      --; --; put;
      clear; add "statement*"; push; .reparse
    }

    # error trap
    clear; add "  incorrect command syntax?"; put;
    clear; add "nom.untrapped.error*"; push; .reparse
  }

  # reducing blocks
  "test*{*statementset*}*", 
  "ortest*{*statementset*}*",
  "andtest*{*statementset*}*" {
    clear; 
    # indent the translated code for readability
    ++; ++; add "\n"; get; replace "\n" "\n  "; put; --; --; 
    clear; add "if ("; get; add ") {";
    ++; ++; get; add "\n}"; --; --; put; 
    clear; add "statement*"; push; .reparse
  }

  "begin*{*statementset*}*" {
     clear; 
     ++; ++; get; --; --; put; clear;
     add "beginblock*"; push; .reparse
  }

  # end of input stream errors
  (eof) {
    "test*","ortest*","andtest*","begin*" {
       clear; 
       add "* Incomplete script."; put;
       clear; add "nom.error*"; push; .reparse
    }
  }

  # cannot be reduced to one push;
  push;push;push;push;

  pop;pop;pop;
  (eof) {
    # need to arrange the labelled loops or gotos here. Because the 
    # loop cannot include the beginblock.
    # just a trick to make the following rules simpler
    replace "statement*" "statementset*";
    # perl has labelled loops?

    "statementset*parselabel*statementset*" {
      clear; 
      # indent both code blocks
      add "    "; get; replace "\n" "\n    "; put; clear; ++; ++;
      add "    "; get; replace "\n" "\n    "; put; clear; --; --;
      # add a block so that .reparse works before the parse> label.
      add "SCRIPT:\n";
      add "while (true) {\n";
      add "  LEX: { \n";
      get; 
      add "\n  } # lex block \n"; 
      add "  PARSE: \n";
      add "    while (true) { \n"; ++; ++; get; --; --;
      add "\n     last PARSE;  # run-once parse loop ";
      add "\n   } # parse block "; 
      add "\n} # nom script loop ";
      put; 
      clear; add "script*"; push; .reparse
    }
  }
  push;push;push;
  # this cannot be reduced to 'push;'
  pop;pop;
  (eof) {
    # need to arrange the labelled loops or gotos here. Because the 
    # loop cannot include the beginblock.
    # just a trick to make the following rules simpler
    replace "statement*" "statementset*";

    "statementset*parselabel*" {
       clear; add "    "; get; replace "\n" "\n    "; put; clear; 
       add "SCRIPT:\n";
       add "while (true) {\n";
       add "  LEX: { \n"; get; 
       add "\n  } # lex block \n"; 
       # parse label with no statement after.
       add "  PARSE: ";
       add "\n} # nom script loop ";
       put; 
       clear; add "script*"; push; .reparse
    }

    "parselabel*statementset*" {
       clear; add "    "; ++; get; --; replace "\n" "\n    "; put; clear; 
       add "SCRIPT:\n";
       add "while (true) {\n";
       add "  PARSE: \n";
       add "    while (true) { \n"; get;
       add "\n     last PARSE;  # run-once parse loop ";
       add "\n   } # parse block "; 
       add "\n} # nom script loop ";
       put; 
       clear; add "script*"; push; .reparse
    }


    "beginblock*script*" {
      clear; get; add "\n"; ++; get; --; put;
      clear; add "script*"; push; .reparse
    }
  }
  # cannot reduce to push
  push;push;
  pop;
  (eof) {
    # need to arrange the labelled loops or gotos here. Because the 
    # loop cannot include the beginblock.
    # just a trick to make the following rules simpler
    replace "statement*" "statementset*";
    "statementset*" {
       clear; add "  "; get; replace "\n" "\n  "; put; clear; 
       add "SCRIPT:\n";
       add "while (true) {\n"; get;
       add "\n} # nom script loop "; put;
       clear; add "script*"; push; .reparse 
    }
    "beginblock*","comment*","parselabel*" {
       clear; add "script*"; push; .reparse 
    }
  }

  push;push;push;push;

  (eof) {
    pop;pop;
    "" {
      add "# empty nom script\n"; 
      print; quit;
    }
    !"script*" {
      push;push;
      unstack; put; clear; 
      add "* script syntax problem: the error was not caught by the \n"; 
      add "  syntax checker, and should have been.\n";
      add "  The parse stack was: ";
      get; put; clear; add "nom.error*"; push; .reparse
    }
    clear; add "#!/usr/bin/perl \n"; print; clear;
    # indent the compiled code
    add "\n"; get; replace "\n" "\n      "; put; clear;
    # create the virtual machine object code and save it
    # on the tape.
    add '

  // ----------------------------------------

  const std = @import("std");
  const fs = std.fs;
  const io = std.io;
  const process = std.process;
  const mem = std.mem;

  const InputType = enum {
    Unset,
    Stdin,
    StdinStream,
    File,
    FileStream,
    String,
  };

  const OutputType = enum {
    Unset,
    Stdout,
    File,
    String,
  };

  pub const Machine = struct {
    accumulator: i32,
    peep: []u8, // Using []u8 for dynamic strings, assuming UTF-8
    charsRead: u32,
    linesRead: u32,

    inputBuffer: std.ArrayList([]u8), // Reversed vector of strings
    outputBuffer: std.ArrayList(u8),   // Accumulates output as bytes
    sourceType: InputType,
    sinkType: OutputType,
    work: std.ArrayList(u8),    // Text accumulator
    stack: std.ArrayList([]u8), // Parse token stack
    tapeLength: usize,
    tape: std.ArrayList([]u8),  // Array of token attributes
    marks: std.ArrayList([]u8), // Tape marks
    cell: usize,
    input_file: fs.File, // Placeholder for file input, will be closed
    output_file: fs.File, // Placeholder for file output, will be closed
    eof: bool,
    escape: u8,    // Char used to "escape" others: default '\\'
    delimiter: u8, // Push/pop delimiter (default is '*')

    allocator: mem.Allocator,

    pub fn new(allocator: mem.Allocator) !*Machine {
      var machine = try allocator.create(Machine);
      machine.* = Machine {
        .accumulator = 0,
        .peep = "",
        .charsRead = 0,
        .linesRead = 1,
        .inputBuffer = std.ArrayList([]u8).init(allocator),
        .outputBuffer = std.ArrayList(u8).init(allocator),
        .sourceType = .Unset,
        .sinkType = .Stdout,
        .work = std.ArrayList(u8).init(allocator),
        .stack = std.ArrayList([]u8).init(allocator),
        .tapeLength = 100,
        .tape = std.ArrayList([]u8).init(allocator),
        .marks = std.ArrayList([]u8).init(allocator),
        .cell = 0,
        .eof = false,
        .escape = '\\',
        .delimiter = '*',
        // Temporarily create dummy files, these will be replaced by actual files
        .input_file = try fs.createFile(allocator, "temp_in.xyz.123.txt", .{ .read = true }),
        .output_file = try fs.createFile(allocator, "temp_out.xyz.123.txt", .{ .truncate = true }),
        .allocator = allocator,
      };

      // Initialize tape and marks
      for (0..machine.tapeLength) |_| {
        try machine.tape.append("");
        try machine.marks.append("");
      }

      return machine;
    }

    pub fn deinit(self: *Machine) void {
      self.inputBuffer.deinit();
      self.outputBuffer.deinit();
      self.work.deinit();
      self.stack.deinit();
      self.tape.deinit();
      self.marks.deinit();
      self.input_file.close();
      self.output_file.close();
      self.allocator.destroy(self);
    }

    pub fn fillInputBuffer(self: *Machine, text: []const u8) !void {
      // This assumes UTF-8 and iterates over code points.
      // For true grapheme clusters, a more complex library would be needed.
      var it = std.unicode.utf8.revIterate(text);
      while (it.next()) |char_code| {
        var char_buf: [4]u8 = undefined;
        const len = std.unicode.utf8.encode(char_code, &char_buf);
        try self.inputBuffer.append(try self.allocator.dupe(u8, char_buf[0..len]));
      }
    }

    pub fn read(self: *Machine) !void {
      if (self.eof) {
        process.exit(0);
      }

      self.charsRead += 1;
      if (std.mem.eql(u8, self.peep, "\n")) {
        self.linesRead += 1;
      }

      try self.work.appendSlice(self.peep);

      switch (self.sourceType) {
        .Stdin, .String, .File => {
          if (self.inputBuffer.items.len == 0) {
            self.eof = true;
            self.peep = "";
          } else {
            self.peep = self.inputBuffer.pop();
          }
        },
        .FileStream => {
          if (self.inputBuffer.items.len == 0) {
            var line_buffer = std.ArrayList(u8).init(self.allocator);
            defer line_buffer.deinit();

            const bytes_read = try self.input_file.reader().readUntilDelimiterOrEof(&line_buffer, '\n');
            if (bytes_read) |br| {
              if (br > 0) {
                try self.fillInputBuffer(line_buffer.items);
              } else {
                self.eof = true;
                self.peep = "";
              }
            } else {
              // EOF without reading anything
              self.eof = true;
              self.peep = "";
            }
          }
          if (self.inputBuffer.items.len > 0) {
            self.peep = self.inputBuffer.pop();
          }
        },
        .Unset, .StdinStream => { // StdinStream is not fully implemented in the Rust code either
          std.debug.print("Machine.sourceType error {any} while trying to read input\n", .{self.sourceType});
          process.exit(1);
        },
      }
    }

    pub fn write(self: *Machine) !void {
      switch (self.sinkType) {
        .Stdout => {
          try io.getStdout().writer().writeAll(self.work.items);
        },
        .File => {
          try self.output_file.writer().writeAll(self.work.items);
        },
        .String => {
          try self.outputBuffer.appendSlice(self.work.items);
        },
        .Unset => {
          std.debug.print("Machine.sinkType error for type {any}\n", .{self.sinkType});
        },
      }
    }

    pub fn increment(self: *Machine) !void {
      self.cell += 1;
      if (self.cell >= self.tapeLength) {
        for (0..50) |_| {
          try self.tape.append("");
          try self.marks.append("");
        }
        self.tapeLength += 50;
      }
    }

    pub fn unescapeChar(self: *Machine, c: u8) !void {
      if (self.work.items.len == 0) return;

      var s = std.ArrayList(u8).init(self.allocator);
      defer s.deinit();

      var countEscapes: usize = 0;
      var it = self.work.reader().iterate();
      while (it.next()) |nextChar| {
        if (nextChar == c and countEscapes % 2 == 1) {
          // Remove last escape char. This is a bit tricky with ArrayList.
          // For simplicity, we'll rebuild the string.
          _ = s.pop(); // Remove the last char (which was the escape)
        }
        if (nextChar == self.escape) {
          countEscapes += 1;
        } else {
          countEscapes = 0;
        }
        try s.append(nextChar);
      }
      self.work.clear();
      try self.work.appendSlice(s.items);
    }

    pub fn escapeChar(self: *Machine, c: u8) !void {
      if (self.work.items.len == 0) return;

      var s = std.ArrayList(u8).init(self.allocator);
      defer s.deinit();

      var countEscapes: usize = 0;
      var it = self.work.reader().iterate();
      while (it.next()) |nextChar| {
        if (nextChar == c and countEscapes % 2 == 0) {
          try s.append(self.escape);
        }
        if (nextChar == self.escape) {
          countEscapes += 1;
        } else {
          countEscapes = 0;
        }
        try s.append(nextChar);
      }
      self.work.clear();
      try self.work.appendSlice(s.items);
    }

    pub fn countEscaped(self: *Machine, suffix: []const u8) usize {
      var s = std.ArrayList(u8).init(self.allocator);
      defer s.deinit();

      _ = s.appendSlice(self.work.items) catch |err| {
        std.debug.print("Error appending to s: {any}\n", .{err});
        return 0;
      };

      var count: usize = 0;
      if (mem.endsWith(u8, s.items, suffix)) {
        s.shrink(s.items.len - suffix.len);
      }
      while (s.items.len > 0 and s.items[s.items.len - 1] == self.escape) {
        count += 1;
        _ = s.pop();
      }
      return count;
    }

    pub fn readUntil(self: *Machine, suffix: []const u8) !void {
      if (self.eof) return;
      try self.read();
      while (true) {
        if (self.eof) return;
        if (mem.endsWith(u8, self.work.items, suffix)) {
          if (self.countEscaped(suffix) % 2 == 0) return;
        }
        try self.read();
      }
    }

    pub fn pop(self: *Machine) bool {
      if (self.stack.items.len == 0) return false;
      var popped_string = self.stack.pop();
      // This is safe because `insertString` will reallocate if needed
      self.work.insertSlice(0, popped_string) catch {
        std.debug.print("Error inserting string during pop: {any}\n", .{@err_name});
        return false;
      };
      if (self.cell > 0) {
        self.cell -= 1;
      }
      return true;
    }

    pub fn push(self: *Machine) !bool {
      if (self.work.items.len == 0) return false;

      var token = std.ArrayList(u8).init(self.allocator);
      defer token.deinit();

      var remainder = std.ArrayList(u8).init(self.allocator);
      defer remainder.deinit();

      // var found_delimiter = false; // This variable was unused in the original code
      var char_iter = std.unicode.utf8.iterator(self.work.items);
      var original_index: usize = 0;

      while (char_iter.next()) |code_point| {
        var char_buf: [4]u8 = undefined;
        const len = std.unicode.utf8.encode(code_point, &char_buf);
        try token.appendSlice(char_buf[0..len]);
        original_index += len; // Keep track of byte offset

        if (code_point == self.delimiter) {
          try self.stack.append(try self.allocator.dupe(u8, token.items));
          _ = remainder.appendSlice(self.work.items[original_index..]) catch {
            std.debug.print("Error appending remainder: {any}\n", .{@err_name});
            return false;
          };
          self.work.clear();
          try self.work.appendSlice(remainder.items);
          try self.increment();
          return true;
        }
      }

      // Push the whole workspace if there is no token delimiter
      try self.stack.append(try self.allocator.dupe(u8, token.items));
      self.work.clear();
      try self.increment();
      return true;
    }

    pub fn writeToFile(self: *Machine) !void {
      var file =
        try fs.createFile(self.allocator, "sav.pp", .{ .truncate = true });
      defer file.close();
      try file.writer().writeAll(self.work.items);
    }

    pub fn goToMark(self: *Machine, mark: []const u8) !void {
      for (self.marks.items) |thismark, ii| {
        if (std.mem.eql(u8, thismark, mark)) {
          self.cell = ii;
          return;
        }
      }
      std.debug.print("badmark '{s}'!\n", .{mark});
      process.exit(1);
    }

    pub fn addMark(self: *Machine, newMark: []const u8) !void {
      for (self.marks.items) |*mark_ptr| {
        if (std.mem.eql(u8, mark_ptr.*, newMark)) {
          mark_ptr.* = ""; // Clear existing mark
        }
      }
      self.marks.items[self.cell] = try self.allocator.dupe(u8, newMark);
    }

    pub fn matchClass(self: *Machine, text: []const u8, class: []const u8) bool {
      if (text.len == 0) return false;

      // Check for character type classes like [:alpha:]
      if (class.len >= 4 and mem.startsWith(u8, class, "[:") and mem.endsWith(u8, class, ":]")) {
        var charType = class[2 .. class.len - 2];
        // These functions operate on Unicode code points
        var it = std.unicode.utf8.iterator(text);
        while (it.next()) |c| {
          switch (charType) {
            "alnum" => if (!std.unicode.isAlphanumeric(c)) return false,
            "alpha" => if (!std.unicode.isAlphabetic(c)) return false,
            "ascii" => if (c > 127) return false,
            "word" => if (!(std.unicode.isAlphanumeric(c) or c == '_')) return false,
            "blank" => if (!(c == ' ' or c == '\t')) return false,
            "control", "cntrl" => if (!std.unicode.isControl(c)) return false,
            "digit" => if (!std.unicode.isDigit(c)) return false,
            "graph" => if (!std.unicode.isPrint(c) or c == ' ') return false, // No direct is_ascii_graphic, approximating
            "lower" => if (!std.unicode.isLower(c)) return false,
            "upper" => if (!std.unicode.isUpper(c)) return false,
            "print" => if (!std.unicode.isPrint(c)) return false,
            "punct" => if (!std.unicode.isPunctuation(c)) return false,
            "space" => if (!std.unicode.isSpace(c)) return false,
            "xdigit" => if (!std.unicode.isHexDigit(c)) return false,
            else => {
              std.debug.print("unrecognised char class in translated nom script: {s}\n", .{charType});
              process.exit(1);
            },
          }
        }
        return true;
      }

      // Get a list of characters from the class string (excluding brackets)
      var class_chars = std.ArrayList(u8).init(self.allocator);
      defer class_chars.deinit();
      if (class.len > 2) {
        try class_chars.appendSlice(class[1 .. class.len - 1]);
      }

      // Is a range class like [a-z]
      if (class_chars.items.len == 3 and class_chars.items[1] == '-') {
        var it = std.unicode.utf8.iterator(text);
        while (it.next()) |char_code| {
          if (char_code < class_chars.items[0] or char_code > class_chars.items[2]) {
            return false;
          }
        }
        return true;
      }

      // List class like: [xyzabc]
      // Check if all characters in text are in the class list
      var text_it = std.unicode.utf8.iterator(text);
      while (text_it.next()) |text_char| {
        var found = false;
        var class_it = std.unicode.utf8.iterator(class_chars.items);
        while (class_it.next()) |class_char| {
          if (text_char == class_char) {
            found = true;
            break;
          }
        }
        if (!found) return false;
      }
      return true;
    }

    pub fn replace(self: *Machine, old: []const u8, new: []const u8) !void {
      if (old.len == 0 or std.mem.eql(u8, old, new)) return;

      var result = std.ArrayList(u8).init(self.allocator);
      defer result.deinit();

      var current_offset: usize = 0;
      while (current_offset < self.work.items.len) {
        if (self.work.items.len - current_offset >= old.len and
            std.mem.eql(u8, self.work.items[current_offset .. current_offset + old.len], old))
        {
          try result.appendSlice(new);
          current_offset += old.len;
        } else {
          try result.append(self.work.items[current_offset]);
          current_offset += 1;
        }
      }
      self.work.clear();
      try self.work.appendSlice(result.items);
    }

    pub fn capitalise(self: *Machine) !void {
      var result = std.ArrayList(u8).init(self.allocator);
      defer result.deinit();

      var capitalize_next = true;
      var it = std.unicode.utf8.iterator(self.work.items);
      while (it.next()) |c| {
        if (std.unicode.isAlphabetic(c)) {
          if (capitalize_next) {
            try result.appendSlice(std.unicode.toUpper(c).toSlice());
            capitalize_next = false;
          } else {
            try result.appendSlice(std.unicode.toLower(c).toSlice());
          }
        } else {
          try result.appendSlice(std.unicode.utf8.encode(c, &[_]u8{}).toSlice());
          if (c == '\n' or c == ' ' or c == '.' or c == '?' or c == '!') {
            capitalize_next = true;
          }
        }
      }
      self.work.clear();
      try self.work.appendSlice(result.items);
    }

    pub fn printState(self: *Machine) void {
      std.debug.print("\n--------- Machine State -------------\n", .{});
      std.debug.print("(input buffer:{any})\n", .{self.inputBuffer.items});
      std.debug.print("Stack[", .{});
      for (self.stack.items) |token| {
        std.debug.print("{s},", .{token});
      }
      std.debug.print("] Work[{s}] ", .{self.work.items});
      std.debug.print("Peep['{s}']\n", .{self.peep});
      std.debug.print("Acc:{} ", .{self.accumulator});
      std.debug.print("EOF:{} ", .{self.eof});
      std.debug.print("Esc:'{}' ", .{self.escape});
      std.debug.print("Delim:'{}' ", .{self.delimiter});
      std.debug.print("Chars:{} ", .{self.charsRead});
      std.debug.print("Lines:{}\n", .{self.linesRead});
      std.debug.print("-------------- Tape -----------------\n", .{});
      std.debug.print("Tape Size: {}\n", .{self.tapeLength});
      var start: usize = 0;
      if (self.cell > 3) {
        start = self.cell - 4;
      }
      const end = std.math.min(self.cell + 4, self.tape.items.len);
      for (start..end) |ii| {
        std.debug.print("  {}", .{ii});
        if (ii == self.cell) {
          std.debug.print("> [{s}]\n", .{self.tape.items[ii]});
        } else {
          std.debug.print("  [{s}]\n", .{self.tape.items[ii]});
        }
      }
    }

    pub fn setStringInput(self: *Machine, text: []const u8) !void {
      self.sourceType = .String;
      self.inputBuffer.clear();
      try self.fillInputBuffer(text);
      self.peep = "";
      try self.read();
      self.charsRead = 0;
    }

    pub fn setStringOutput(self: *Machine) void {
      self.sinkType = .String;
    }

    pub fn parseString(self: *Machine, input: []const u8) ![]u8 {
      try self.setStringInput(input);
      self.sinkType = .String;
      try self.parse();
      return self.outputBuffer.items;
    }

    pub fn setFileStreamInput(self: *Machine, filename: []const u8) !void {
      if (!checkTextFile(self.allocator, filename)) {
        process.exit(1);
      }
      self.input_file.close(); // Close existing dummy file
      self.input_file = try fs.openFile(self.allocator, filename, .{ .read = true });
      self.sourceType = .FileStream;
      self.peep = "";
      try self.read();
      self.charsRead = 0;
    }

    pub fn setFileInput(self: *Machine, filename: []const u8) !void {
      self.input_file.close(); // Close existing dummy file
      var file = try fs.openFile(self.allocator, filename, .{ .read = true });
      defer file.close(); // Close immediately after reading content

      var text_buffer = std.ArrayList(u8).init(self.allocator);
      defer text_buffer.deinit();

      _ = try file.reader().readAll(&text_buffer);

      // Remove trailing newline if present, consistent with Rust behavior
      if (text_buffer.items.len > 0 and text_buffer.items[text_buffer.items.len - 1] == '\n') {
        _ = text_buffer.pop();
      }

      self.sourceType = .File;
      self.inputBuffer.clear();
      try self.fillInputBuffer(text_buffer.items);
      self.peep = "";
      try self.read();
      self.charsRead = 0;
    }

    pub fn setFileOutput(self: *Machine, filename: []const u8) !void {
      if (!checkTextFile(self.allocator, filename)) {
        process.exit(1);
      }
      self.output_file.close(); // Close existing dummy file
      self.output_file = try fs.createFile(self.allocator, filename, .{ .truncate = true });
      self.sinkType = .File;
    }

    pub fn parseFile(self: *Machine, inputFile: []const u8, outputFile: []const u8) !void {
      try self.setFileInput(inputFile);
      try self.setFileOutput(outputFile);
      try self.parse();
    }

    pub fn setStandardInput(self: *Machine) !void {
      self.sourceType = .Stdin;
      self.sinkType = .Stdout;

      self.inputBuffer.clear();
      var buffer = std.ArrayList(u8).init(self.allocator);
      defer buffer.deinit();
      const bytes_read = io.getStdin().reader().readAll(&buffer) catch |err| {
        std.debug.print("couldn't read stdin: {any}\n", .{err});
        return;
      };
      _ = bytes_read; // suppress unused variable warning
      try self.fillInputBuffer(buffer.items);

      self.peep = "";
      try self.read();
      self.charsRead = 0;
    }

    pub fn parse(self: *Machine) !void {
      if (self.sourceType == .Unset) {
        try self.setStandardInput();
      }
      // -----------
      // translated nom code goes here
      // -----------

      ';
      # get the compiled code from the tape
    get;
    add '

      switch (self.sinkType) {
        .File => {
          try self.output_file.writer().flush();
        },
        .Stdout, .String => {},
        .Unset => {
          std.debug.print("unsupported output type: {any}\n", .{self.sinkType});
        },
      }
    }
  };

  fn printHelp() void {
    std.debug.print(
      \\
      Nom script translated to zig by www.nomlang.org/tr/nom.tozig.pss
      usage:
        echo "..sometext.." | ./script
        cat somefile.txt | ./script
        ./script -f <file>
        ./script -i <text>
      options:
        --file -f <file>
          run the script with <file> as input (not stdin)
        --input -i <text>
          run the script with <text> as input
        --filetest -F <filename>
          test the translated script with file input and output
        --filestream -S <filename>
          test the translated script with file-stream input
        --inputtest -I <text>
          test the translated script with string input and output
        --help -h
          show this help
      \\, .{});
  }

  fn missingArgument() noreturn {
    std.debug.print("Missing argument.\n", .{});
    printHelp();
    process.exit(1);
  }

  fn duplicateSwitch() noreturn {
    std.debug.print("Duplicate switch found.\n", .{});
    printHelp();
    process.exit(1);
  }

  fn checkTextFile(allocator: mem.Allocator, filepath: []const u8) bool {
    var file = fs.openFile(allocator, filepath, .{ .read = true }) catch |err| {
      switch (err) {
        error.FileNotFound => std.debug.print("File [{s}] not found.\n", .{filepath}),
        error.PermissionDenied => std.debug.print("Permission denied to read file [{s}]\n", .{filepath}),
        else => std.debug.print("Error opening file {s}: {any}\n", .{filepath, err}),
      }
      return false;
    };
    file.close();
    return true;
  }

  pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    var allocator = gpa.allocator();

    var mm = try Machine.new(allocator);
    defer mm.deinit();

    var input: []const u8 = "";
    var filename: []const u8 = "";

    var args = try process.argsAlloc(allocator);
    defer process.argsFree(allocator, args);

    var pos: usize = 0;
    while (pos < args.len) : (pos += 1) {
      const e = args[pos];
      if (std.mem.eql(u8, e, "-f") or std.mem.eql(u8, e, "--file")) {
        if (filename.len > 0) duplicateSwitch();
        if (pos >= args.len - 1) missingArgument();
        filename = args[pos + 1];
        if (!checkTextFile(allocator, filename)) {
          printHelp();
          process.exit(1);
        }
        try mm.setFileInput(filename);
        pos += 1; // Consume the filename argument
      } else if (std.mem.eql(u8, e, "-F") or std.mem.eql(u8, e, "--filetest")) {
        if (pos >= args.len - 1) missingArgument();
        if (filename.len > 0) duplicateSwitch();
        filename = args[pos + 1];
        if (!checkTextFile(allocator, filename)) {
          printHelp();
          process.exit(1);
        }
        try mm.parseFile(filename, "out.txt");
        var file = try fs.openFile(allocator, "out.txt", .{ .read = true });
        defer file.close();
        var buffer = try file.reader().readAllAlloc(allocator, std.math.maxInt(usize));
        defer allocator.free(buffer);
        try io.getStdout().writer().writeAll(buffer);
        process.exit(0);
      } else if (std.mem.eql(u8, e, "-S") or std.mem.eql(u8, e, "--filestream")) {
        if (pos >= args.len - 1) missingArgument();
        if (filename.len > 0) duplicateSwitch();
        filename = args[pos + 1];
        if (!checkTextFile(allocator, filename)) {
          printHelp();
          process.exit(1);
        }
        try mm.setFileStreamInput(filename);
        pos += 1;
      } else if (std.mem.eql(u8, e, "-i") or std.mem.eql(u8, e, "--input")) {
        if (pos >= args.len - 1) missingArgument();
        if (input.len > 0) duplicateSwitch();
        input = args[pos + 1];
        try mm.setStringInput(input);
        pos += 1;
      } else if (std.mem.eql(u8, e, "-I") or std.mem.eql(u8, e, "--inputtest")) {
        if (pos >= args.len - 1) missingArgument();
        if (input.len > 0) duplicateSwitch();
        input = args[pos + 1];
        var text = try mm.parseString(input);
        try io.getStdout().writer().writeAll(text);
        process.exit(0);
      } else if (std.mem.eql(u8, e, "-h") or std.mem.eql(u8, e, "--help")) {
        printHelp();
        process.exit(0);
      }

      if (input.len > 0 and filename.len > 0) {
        std.debug.print(
          \\
          Either use the --file/--filetest options or the --input/--inputtest
          options, not both
          \\, .{});
        printHelp();
        process.exit(0);
      }
    }

    try mm.parse();
  }
//
  \n';
    print; quit;

} # end of block
