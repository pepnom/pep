#!/usr/bin/perl 


 use strict;
 use warnings;
 use utf8;
 # for unicode character properties.
 # use Unicode::UCD qw(charprop);
 # use IO::File;
 #use IO::BufReader;
 #use IO::BufWriter;
 use Getopt::Long;
 use List::Util;  # for all function
 use Carp; # For croak and confess

 package Machine; 
   use constant { true => 1, false => 0 };

   sub new {
     # my ($class) = @_;
     my $class = shift;  # 
     binmode STDOUT, ":encoding(UTF-8)";

     my $self = {
       accumulator   => 0,       # counter for anything
       peep          => "",      # next char in input stream
       charsRead     => 0,       # No. of chars read so far init:0
       linesRead     => 1,       # No. of lines read so far init:1
       inputBuffer   => [],      # reversed array of input chars/graphemes
       outputBuffer  => "",      # where string output will go
       inputType    => "unset",  # reading from stdin/string/file etc
       sinkType      => "stdout",# 
       work          => "",      # text accumulator
       stack         => [],      # parse token stack
       tapeLength    => 100,     # tape initial length
       tape          => [ map { "" } 1..100 ], # array of token attributes
       marks         => [ map { "" } 1..100 ], # tape marks
       cell          => 0,       # pointer to current cell
       input         => *STDIN,  # text input stream
       output        => *STDOUT, #
       eof           => false,    # end of stream reached? (boolean)
       escape        => "\\",   # char used to "escape" others: default "\"
       delimiter     => "*",      # push/pop delimiter (default is "*")
     };
     bless $self, $class;
     return $self;
   }

   sub fillInputStringBuffer {
     my ($self, $text) = @_;
     my $revtext = reverse $text;
     # push onto the array
     push @{$self->{inputBuffer}}, split //, $revtext;
   }

   sub fillInputBuffer {
     my $self = shift;
     my $text = shift;
     # grapheme clusters regex is \X in perl
     # the grapheme cluster splitter is making an extra empty char 
     # in the array

     # not working?
     # my @charArray = reverse split(/(\X)/, $text);

     #my @graphemes = $text =~ m/\X/g;
     #my @charArray = reverse(@graphemes);
     my @charArray = reverse split(//, $text);
     push (@{$self->{inputBuffer}}, @charArray);
     # display the input buffer array
     # print "[",join(", ", @{$self->{inputBuffer}}),"]";
   }

   # read one character from the input stream and
   #   update the machine. This reads though an inputBuffer/inputChars
   #   so as to handle unicode grapheme clusters (which can be more
   #   than one "character").
   # 
   sub readChar {
     my $self = shift;

     #  this exit code should never be called in a translated script
     #  because the Machine:parse() method will return just before
     #  a read() on self.eof But I should keep this here in case
     #  the machine methods are used outside of a parse() method?
     if ($self->{eof}) {
       # need to return from parse method (i.e break loop) when reading on eof.
       exit 0; # print("eof exit")
     }

     my $result = 0; my $line = "";
     $self->{charsRead} += 1;
     # increment lines
     if ($self->{peep} eq "\n") { $self->{linesRead} += 1; }
     $self->{work} .= $self->{peep};

     # fix: it would be better not to have an if else here
     # stdin.all/string/file all read the whole input stream
     #    at once into a buffer.
     my $inputType = $self->{inputType};
     if ($inputType eq "stdin" || $inputType eq "string" || 
         $inputType eq "file") {
       if (!@{$self->{inputBuffer}}) {
         $self->{eof} = true;
         $self->{peep} = "";
       } else {
         $self->{peep} = "";
         # the inputBuffer is a reversed array. pop() returns the last element
         my $char = pop @{$self->{inputBuffer}};
         $self->{peep} .= $char if defined $char;
       }
       return;
     } elsif ($inputType eq "stdinstream") {
       # read from stdin one line at a time. 
       # 
     } elsif ($inputType eq "filestream") {
       # if (scalar(@{$self->{inputBuffer}}) == 0) {
       if (!@{$self->{inputBuffer}}) {
         my $bytes = $self->{input}->getline(\$line);
         if ($bytes > 0) {
           $self->fillInputBuffer($line);
         } else {
           $self->{eof} = true;
           $self->{peep} = "";
         }
       }
       if (scalar(@{$self->{inputBuffer}}) > 0) {
         $self->{peep} = "";
         my $char = pop @{$self->{inputBuffer}};
         $self->{peep} .= $char if defined $char;
       }
       return;
     } else {
       print STDERR "Machine.inputType error ", $inputType, " while trying to read input\n";
       exit 1;
     }
   } # read

   # function Machine:write(output)
   sub writeText {
     my $self = shift;
     my $outputType = $self->{sinkType};
     if ($outputType eq "stdout") {
       print $self->{work};
     } elsif ($outputType eq "file") {
       print {$self->{output}} $self->{work} or die "Error writing to file: $!";
     } elsif ($outputType eq "string") {
       $self->{outputBuffer} .= $self->{work};
     } else {
       print STDERR "Machine.sinkType error for type ", $outputType, "\n";
     }
   }

   # increment tape pointer by one
   sub increment {
     my ($self) = @_;
     $self->{cell}++;
     if ($self->{cell} >= $self->{tapeLength}) {
       for (my $ii = 1; $ii <= 50; $ii++) {
         push @{$self->{tape}}, "";
         push @{$self->{marks}}, "";
       }
       $self->{tapeLength} += 50;
     }
   }

   # Machine.decrement() is usually compiled inline

   # remove escape char, the char should be a string because it could be
   # a unicode grapheme cluster (diacritics etc) 
   sub unescapeChar {
     my ($self, $c) = @_;
     # dont unescape chars that are not escaped!
     my $countEscapes = 0;
     my $s = "";
     # let nextChar = ;
     return if length($self->{work}) == 0;

     for my $nextChar (split //, $self->{work}) {
       if (($nextChar eq $c) && ($c ne $self->{escape}) && 
           ($countEscapes % 2 == 1)) {
         # assuming that the escape char is only one char?
         # remove last escape char
         substr($s, -1) = "";
       }
       if ($nextChar eq $self->{escape}) {
         $countEscapes++;
       } else {
         if (($c eq $self->{escape}) && ($countEscapes > 0) && 
             ($countEscapes % 2 == 0)) {
           substr($s, -1) = "";
         } 
         $countEscapes = 0;
       }
       $s .= $nextChar;
     }
     $self->{work} = $s;
   }

   #  add escape character, dont escape chars that are already escaped!
   #  It is important to get this code right especially for 2nd 
   #  generation tests and also because some languages will crash or 
   #  refuse to compile if there is an "unrecognised escape sequence"
   #    modify this for grapheme clusters.
   #   
   # This can be tested with something like the following
   # >> pep.pls "whilenot [:space:];escape'x';t;d;(eof){quit;}' 'ab\xc'
   # >> pep.pls 'until ":";escape"\";t;d;(eof){quit;}' 'ab\c'
   # If there are an even number of escape chars (in this case, backslashes)
   # then the target character should not be escaped, *unless* the 
   # target character IS the escape character. Confusing no? But important.
   # Notice that I have to use a while/whilenot/until read to test this
   # properly...
   # 
   # This code should be copied to all the other translators

   # fix: just modify the rust code based on the code in 
   # object/machine.interp.c 
   sub escapeChar {
     my $self = shift;
     my $c = shift;  # the character to escape
     my $countEscapes = 0;
     return if length($self->{work}) == 0;

     my @chars = split(//, $self->{work});
     $self->{work} = "";
     for (my $ii = 0; $ii < @chars; $ii++) {
       # escape the character c but only if it is not the pep
       # machine escape character (by default a backslash \)
       if (($chars[$ii] eq $c) && ($c ne $self->{escape}) && 
           ($countEscapes % 2 == 0)) {
         $self->{work} .= $self->{escape};
       }

       if ($chars[$ii] eq $self->{escape}) {
         $countEscapes += 1;
       }
       else {
         if (($c eq $self->{escape}) && ($countEscapes > 0) && 
            ($countEscapes %2 == 1)) { 
           $self->{work} .= $self->{escape};
         } 
         $countEscapes = 0; 
       } 
       $self->{work} .= $chars[$ii];
     } 
   } 

   # a helper to see how many trailing escape chars, this is used
   # only by the until command to see if it should keep reading or 
   # not.
   sub countEscaped {
     my ($self, $suffix) = @_;
     my $s = $self->{work};
     my $count = 0;
     if (substr($s, -length($suffix)) eq $suffix) {
       $s = substr($s, 0, length($s) - length($suffix));
     }
     while (substr($s, -length($self->{escape})) eq $self->{escape}) {
       $count++;
       $s = substr($s, 0, length($s) - length($self->{escape}));
     }
     return $count;
   }

   #  reads the input stream until the work end with text. It is
   #    better to call this readUntil instead of until because some
   #       languages dont like keywords as methods. Same for read()
   #       should be readChar() 
   sub readUntil {
     my ($self, $suffix) = @_;
     # read at least one character
     return if $self->{eof};
     $self->readChar();
     while (true) {
       return if $self->{eof};
       if (substr($self->{work}, -length($suffix)) eq $suffix) {
         return if $self->countEscaped($suffix) % 2 == 0;
       }
       $self->readChar();
     }
   }

   # pop the first token from the stack into the workspace
   sub popToken {
     my $self = shift;   # a reference to the pep machine
     if (!@{$self->{stack}}) { return false; }
     $self->{work} = pop(@{$self->{stack}}) . $self->{work};
     if ($self->{cell} > 0) { $self->{cell} -= 1; }
     return true;
   }

   # push the first token from the workspace to the stack
   sub pushToken {
     my $self = shift;   # a reference to the pep machine
     # dont increment the tape pointer on an empty push
     if (length($self->{work}) == 0) { return false; }

     # I iterate the workspace buffer chars so that this method
     # can be easily adapted for grapheme clusters
     my $token = "";
     my $remainder = "";
     my @chars = split(//, $self->{work});

     # maybe for grapheme clusters
     # my @chars = split(/\X/, $self->{work});
     for (my $ii = 0; $ii < scalar(@chars); $ii++) {
       my $c = $chars[$ii];
       $token .= $c;
       if ($c eq $self->{delimiter}) {
         push @{$self->{stack}}, $token;
         $remainder = join "", @chars[$ii+1 .. $#chars];
         $self->{work} = "";
         $self->{work} .= $remainder;
         $self->increment();
         return true;
       }
     }
     # push the whole workspace if there is no token delimiter
     push @{$self->{stack}}, $token;
     $self->{work} = "";
     $self->increment();
     return true;
   }

   # save the workspace to file "sav.pp"
   # we can put this inline?
   sub writeToFile {
     my ($self) = @_;
     my $filename = "sav.pp";
     open my $fh, ">:utf8", $filename or 
       die "Could not open file [$filename] for writing: $!";
     print $fh $self->{work};
     close $fh;
   }

   sub goToMark {
     my ($self, $mark) = @_;
     for (my $ii = 0; $ii < @{$self->{marks}}; $ii++) {
       # print("ii:", $ii, " mark:", $thismark,"\n");
       if ($self->{marks}[$ii] eq $mark) {
         $self->{cell} = $ii;
         return;
       }
     }
     print "badmark '$mark'!\n";
     exit 1;
   }

   # # remove existing marks with the same name and add new mark 
   sub addMark {
     my ($self, $newMark) = @_;
     # remove existing marks with the same name.
     for my $mark (@{$self->{marks}}) {
       if ($mark eq $newMark) {
         $mark = "";
       }
     }
     $self->{marks}[$self->{cell}] = $newMark;
   }

   # # check if the workspace matches given list class eg [hjk]
   #    or a range class eg [a-p]. The class string will be "[a-p]" ie
   #    with brackets [:alpha:] may have already been made into something else by the
   #    compiler.
   #    fix: for grapheme clusters and more complete classes
   #   
   sub matchClass {
     my ($self, $text, $class) = @_;
     # empty text should never match a class.
     return false if length($text) == 0;

     # a character type class like [:alpha:]
     # print("class: $class");
         
     if ($class =~ /^\[:(.+):\]$/ && $class ne "[:]" && $class ne "[::]") {
       my $charType = $1;
       my @chars = split //, $text;
       if ($charType eq "alnum") { return $text =~ /^\w+$/; }
       if ($charType eq "alpha") { return $text =~ /^[[:alpha:]]+$/; }
       if ($charType eq "ascii") { return $text =~ /^[[:ascii:]]+$/; }
       if ($charType eq "word") { return $text =~ /^[\w_]+$/; }
       if ($charType eq "blank") { return $text =~ /^[\s\t]+$/; }
       if ($charType eq "control") { return $text =~ /^[[:cntrl:]]+$/; }
       if ($charType eq "cntrl") { return $text =~ /^[[:cntrl:]]+$/; }
       if ($charType eq "digit") { return $text =~ /^\d+$/;}
       if ($charType eq "graph") { return $text =~ /^[[:graph:]]+$/; }
       if ($charType eq "lower") { return $text =~ /^[[:lower:]]+$/; }
       if ($charType eq "upper") { return $text =~ /^[[:upper:]]+$/; }
       if ($charType eq "print") { return $text =~ /^[[:print:]]+$/; 
         # and not eq " "
       }
       if ($charType eq "punct") { return $text =~ /^[[:punct:]]+$/; }
       if ($charType eq "space") { return $text =~ /^\s+$/; }
       if ($charType eq "xdigit") { return $text =~ /^[0-9a-fA-F]+$/; }
       print STDERR "unrecognised char class in translated nom script\n";
       print STDERR "$charType\n";
       exit 1;
       return false;
     }

     # get a vector of chars except the first and last which are [ and ]
     my @charList = split //, substr($class, 1, length($class)-2);
     # is a range class like [a-z]
     if (scalar(@charList) == 3 && $charList[1] eq "-") {
       my ($start, undef, $end) = @charList;
       my @chars = split(//, $text);
       #print("chars: @chars");
       #return all { $_ ge $start && $_ le $end } @chars;
       # modify split for grapheme clusters?
       for my $char (split //, $text) {
         if ($char lt $start || $char gt $end) { return false; }
       }
       return true;
     }

     # list class like: [xyzabc]
     # check if all characters in text are in the class list
     # my @textChars = split //, $text;

     # Create a hash for faster lookup?
     my %charHash = map { $_ => 1 } @charList; 
     for my $char (split //, $text) {
       return false unless exists $charHash{$char};
     }
     return true;

     #return all { grep { $_ eq $textChars[$_] } @charList } 0 .. $#textChars;
     #return false;
     # also must handle eg [:alpha:] This can be done with char methods
   }

   # # a plain text string replace function on the workspace 
   sub replace {
     my ($self, $old, $new) = @_;
     return if length($old) == 0;
     return if $old eq $new;
     $old = quotemeta($old);
     $self->{work} =~ s/$old/$new/g;
   }

   #  make the workspace capital case 
   sub capitalise {
     my ($self) = @_;
     my $result = "";
     my $capitalize_next = 1;
     for my $c (split //, $self->{work}) {
       if ($c =~ /[[:alpha:]]/) {
         if ($capitalize_next) {
           $result .= uc $c;
           $capitalize_next = false;
         } else {
           $result .= lc $c;
         }
       } else {
         $result .= $c;
         if ($c eq "\n" || $c eq " " || $c eq "." || $c eq "?" || $c eq "!") {
           $capitalize_next = true;
         }
       }
     }
     $self->{work} = $result;
   }

   #  print the internal state of the pep/nom parsing machine. This
   #    is handy for debugging 
   sub printState {
     my $self = shift;
     print 
       "\n--------- Machine State ------------- \n",
       "(input buffer:", join(",", @{$self->{inputBuffer}}), ")\n",
       "Stack[", join(",", @{$self->{stack}}), "]", 
       " Work[", $self->{work}, "]",
       " Peep[", $self->{peep}, "]\n",
       "Acc:", $self->{accumulator},
       " EOF:", $self->{eof} eq true? "true":"false", 
       " Esc:", $self->{escape},
       " Delim:", $self->{delimiter}, 
       " Chars:", $self->{charsRead}, " ";
     print "Lines:", $self->{linesRead}, "\n";
     print "-------------- Tape ----------------- \n";
     print "Tape Size: ", $self->{tapeLength}, "\n";
     my $start = 0;
     if ($self->{cell} > 3) {
       $start = $self->{cell} - 4;
     }
     my $end = $self->{cell} + 4;
     for (my $ii = $start; $ii <= $end; $ii++) {
       print "    $ii ";
       if ($ii == $self->{cell}) { print "> ["; }
       else { print "  ["; }
       if (defined $self->{tape}[$ii]) {
         print $self->{tape}[$ii], "] ";
         if (defined $self->{marks}[$ii] && ($self->{marks}[$ii] ne "")) {
           print "(m:", $self->{marks}[$ii], ")";
         }
         print "\n";
       } else {
         print "]\n";
       }
     }
   }


   # print the internal state of the pep/nom parsing machine as an
   # html table. I will use this for illustrating the action of commands
   # on the www.nomlang.org website.
   sub printHtmlState {
     my $self = shift;
     print 
       "\n<table><thead> Machine State </thead> \n",
       "<tr><td>Stack</td><td>Workspace</td><td>Peep</td></tr>\n",
       "<tr><td>", join(",", @{$self->{stack}}), "</td>\n", 
       "    <td>", $self->{work}, "</td>\n",
       "    <td>", $self->{peep}, "</td></tr>\n",
       "<tr><td>Acc</td><td>EOF</td><td>Esc</td>\n",
       "    <td>Delim</td><td>Chars</td><td>Lines</td></tr>\n",
       "<tr><td>", $self->{accumulator}, "</td>\n",
       "    <td>", $self->{eof} eq true? "true":"false", "</td>\n",
       "    <td>", $self->{escape}, "</td>\n",
       "    <td>", $self->{delimiter}, "</td>\n",
       "    <td>", $self->{charsRead}, "</td>\n";
     print "<td>", $self->{linesRead}, "</td></tr>\n";
     print "<tr><td> Tape \n";
     print "Tape Size: ", $self->{tapeLength}, "\n";
     my $start = 0;
     if ($self->{cell} > 3) {
       $start = $self->{cell} - 4;
     }
     my $end = $self->{cell} + 4;
     for (my $ii = $start; $ii <= $end; $ii++) {
       print "    $ii ";
       if ($ii == $self->{cell}) { print "> ["; }
       else { print "  ["; }
       if (defined $self->{tape}[$ii]) {
         print $self->{tape}[$ii], "] ";
         if (defined $self->{marks}[$ii] && ($self->{marks}[$ii] ne "")) {
           print "(m:", $self->{marks}[$ii], ")";
         }
         print "\n";
       } else {
         print "]\n";
       }
     }
     print "</table>\n";
   }

   # # makes the machine read from a string also needs to prime
   #    the "peep" value. 
   sub setStringInput {
     my ($self, $text) = @_;
     $self->{inputType} = "string";
     $self->{inputBuffer} = [];
     $self->fillInputBuffer($text);
     # prime the "peep" with the 1st char
     $self->{peep} = ""; $self->readChar(); $self->{charsRead} = 0;
   }

   # # makes the machine write to a string 
   sub setStringOutput {
     my ($self) = @_;
     $self->{sinkType} = "string";
   }

   # # parse/translate from a string and return the translated
   #    string 
   sub parseString {
     my ($self, $input) = @_;
     $self->setStringInput($input);
     $self->{sinkType} = "string";
     $self->parse();
     return $self->{outputBuffer};
   }

   # # makes the machine read from a file stream line by line,
   #    not from stdin 
   sub setFileStreamInput {
     my ($self, $filename) = @_;
     unless (checkTextFile($filename)) { exit 1; }
     open my $fh, "<:utf8", $filename or 
       die "Cannot open file [$filename] for reading: $!";
     $self->{input} = IO::BufReader->new($fh);
     $self->{inputType} = "filestream";
     # prime the peep, the read() method should refill the
     # inputChars or inputBuffer if it is empty.
     $self->{peep} = ""; $self->readChar(); $self->{charsRead} = 0;
   }

   # # makes the machine read from a file line buffer array
   #    but this also needs to prime the "peep" value 
   sub setFileInput {
     my ($self, $filename) = @_;
     open my $fh, "<:utf8", $filename or 
       die "Could not open file [$filename] for reading: $!";
     my $text = do { local $/ = undef; <$fh> };
     close $fh;
     # there is an extra newline being added, I dont know where.
     if ($text =~ s/\n$//) {}
     $self->{inputType} = "file";
     $self->{inputBuffer} = [];
     $self->fillInputBuffer($text);
     # prime the "peep" with the 1st char
     $self->{peep} = ""; $self->readChar(); $self->{charsRead} = 0;
   }

   # # makes the machine write to a file not to stdout (the default) 
   sub setFileOutput {
     my ($self, $filename) = @_;
     unless (checkTextFile($filename)) { exit 1; }
     open my $fh, ">:utf8", $filename or 
       die "Cannot create file [$filename] for writing: $!";
     $self->{output} = $fh;
     $self->{sinkType} = "file";
   }

   # parse from a file and put result in file
   sub parseFile {
     my ($self, $inputFile, $outputFile) = @_;
     $self->setFileInput($inputFile);
     $self->setFileOutput($outputFile);
     $self->parse();
   }

   # # parse from any stream, fix handle 
   # #
   # sub parseStream {
   #   my ($self, $reader) = @_;
   #   # $self->{input} = $reader; # Needs proper handling of reader type
   #   $self->parse();
   # }
   # 

   # this is the default parsing mode. If no other is selected
   #   it will be activated when parse() is first called. I activate it when
   #   parse is 1st called because otherwise it will block if no stdin
   #   is availabel. It also sets stdout as output 
   sub setStandardInput {
     my $self = shift;
     $self->{inputType} = "stdin";
     $self->{sinkType} = "stdout";
     # for printing wide characters
     binmode STDOUT, ":encoding(UTF-8)";
     # binmode STDERR, ":encoding(UTF-8)";

     # $self->{input} = *STDIN;
     # $self->{output} = *STDOUT;

     # read the whole of stdin into the inputBuffer
     $self->{inputBuffer} = [];
     my $buffer = "";
     #  my $stdin = join("", <STDIN>);
     while (<STDIN>) { $buffer .= $_; }
     
     # print("buffer: [$buffer]\n");
     $self->fillInputBuffer($buffer);
     # prime the "peep" with the 1st char, but this doesnt count as
     # a character read.
     $self->{peep} = ""; $self->readChar(); $self->{charsRead} = 0;
   }


   # This function performs all sorts of magic and shenanigans. 
   # Creates a new method runScript() and evaluates it, 
   # thus acting as an interpreter of a scriptfile given to an
   # -f switch. This method only works when the nom to perl translator has 
   # been run on itself with:
   #   >> pep -f nom.toperl.pss nom.toperl.pss > interp.perl.pl
   #   >> echo "read; print; print; clear; " > test.pss
   #   >> chmod a+x interp.perl.pl
   #   >> echo buzz | ./interp.perl.pl -f test.pss
   #   >> (output should be "bbuuzz")
   # Only those who have achieved
   # true enlightenment will understand this method.
   sub interpret {
     my $self = shift;          # the pep parse machine 
     my $filename = shift;
     # fix: using get opts

     #if ($ARGV[0] eq "-f") { $filename = $ARGV[1]; }
     #if ($ARGV[0] =~ /^-f/) { 
     #  $filename = $ARGV[1]; $filename =~ s/^..//;
     #}
     print $filename;
     if ((!defined $filename) || ($filename eq "")) { return; }
     my $method = $self->parseFile($filename);
     # remove everything except the parse method and rename
     # the method so that it doesnt clash with the existing parse
     # method
     $method =~ s/^.*sub parse \{/sub runScript \{/s;
     # to debug
     print "-----------";
     print $method; 
     print "-----------";
     return;
     # add this new method to the current class via evaluation
     eval($method);
     # execute the new method, thus interpreting the script-file 
     # that was provide. This method did not exist when the script was 
     # first loaded, but apparently that doesnt matter
     $self->runScript(*STDIN, *STDOUT);
   }

   # parse and translate the input stdin/file/string 
   sub parse {
     my $self = shift;
     # some temporary variables
     my $text = ""; my $mark = "";
     my $jumptoparse = false;
     # capture the output of the system command.
     my $result = "";
     if ($self->{inputType} eq "unset") {
       $self->setStandardInput();
     }
    
     # -----------
     # translated nom code inserted below
     # -----------
     
      # while 
      while ($self->matchClass($self->{peep}, "[:space:]")) {
        if ($self->{eof}) { last; } $self->readChar();
      }
      $self->{work} = '';  # clear 
      $self->{work} .= "> Searching for palindromes and sub-palindromes \n"; # add 
      $self->{work} .= "> in the input. Strings of the same character are not \n"; # add 
      $self->{work} .= "> considered as palindromes (eg: xxxx or yyy). \n"; # add 
      $self->{work} .= "> This version does not ignore whitespace characters.\n"; # add 
      $self->{work} .= " Palidrome: text that is the same backwards.  \n"; # add 
      $self->{work} .= "  παλίν (palin) = back \n"; # add 
      $self->{work} .= "  δρομος (dromos) = running \n"; # add 
      $self->writeText(); # print  
      $self->{work} = '';  # clear 
      SCRIPT:
      while (true) {
        LEX: { 
          if ($jumptoparse == true) {
            $jumptoparse = false;
            last LEX;
          }
          if ($self->{eof}) { last SCRIPT; } $self->readChar(); # read 
          if ($self->matchClass($self->{work}, "[\n]")) {
            $self->{charsRead} = 0; # nochars 
          }
          ${$self->{tape}}[$self->{cell}] = $self->{work};   # put 
          $self->{work} = '';  # clear 
          $self->{work} .= "char*"; # add 
          $self->pushToken();
        } # lex block 
        PARSE: 
          while (true) { 
          $self->{work} .= $self->{linesRead}; # lines 
          $self->{work} .= ":"; # add 
          $self->{work} .= $self->{charsRead}; # chars 
          $self->{work} .= " "; # add 
          $self->writeText(); # print  
          $self->{work} = '';  # clear 
          while ($self->popToken()) { next; }   # unstack 
          $self->{work} .= "\n"; # add 
          $self->writeText(); # print  
          $self->{work} =~ s/\X$//; # clip
          while ($self->pushToken()) { next; }   # stack 
          $self->popToken();
          $self->popToken();
          if ($self->{work} eq "pal*pal*") {
            $self->{work} = '';  # clear 
            $self->{work} .= $self->{tape}[$self->{cell}];  # get
            $self->increment();   # ++ 
            if ($self->{tape}[$self->{cell}] eq $self->{work}) {
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
              ${$self->{tape}}[$self->{cell}] = $self->{work};   # put 
              $self->{work} = '';  # clear 
              $self->{work} .= "[palindrome found!] ends at line "; # add 
              $self->{work} .= $self->{linesRead}; # lines 
              $self->{work} .= ", char "; # add 
              $self->{work} .= $self->{charsRead}; # chars 
              $self->{work} .= ": "; # add 
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              $self->{work} .= "\n"; # add 
              $self->writeText(); # print  
              $self->{work} = '';  # clear 
              $self->{work} .= "pal*"; # add 
              $self->pushToken();
              next PARSE;
            }
            $self->{work} = '';  # clear 
            if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
            $self->{work} .= "pal*pal*"; # add 
          }
          if ($self->{work} eq "char*char*") {
            $self->{work} = '';  # clear 
            $self->{work} .= $self->{tape}[$self->{cell}];  # get
            $self->increment();   # ++ 
            if ($self->{tape}[$self->{cell}] eq $self->{work}) {
              $self->increment();   # ++ 
              ${$self->{tape}}[$self->{cell}] = $self->{work};   # put 
              if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
              ${$self->{tape}}[$self->{cell}] = $self->{work};   # put 
              $self->{work} = '';  # clear 
              $self->{work} .= "list*"; # add 
              $self->pushToken();
              next PARSE;
            }
            $self->{work} = '';  # clear 
            if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
            $self->{work} .= "char*char*"; # add 
          }
          if ($self->{work} eq "list*char*") {
            $self->{work} = '';  # clear 
            $self->increment();   # ++ 
            $self->{work} .= $self->{tape}[$self->{cell}];  # get
            $self->increment();   # ++ 
            if ($self->{tape}[$self->{cell}] eq $self->{work}) {
              if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
              if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              ${$self->{tape}}[$self->{cell}] = $self->{work};   # put 
              $self->{work} = '';  # clear 
              $self->{work} .= "list*"; # add 
              $self->pushToken();
              next PARSE;
            }
            if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
            if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
            $self->{work} = '';  # clear 
            $self->{work} .= "list*char*"; # add 
          }
          $self->popToken();
          if (($self->{work} eq "list*list*list*") || ($self->{work} eq "char*list*char*") || ($self->{work} eq "list*char*list*") || ($self->{work} eq "list*pal*list*") || ($self->{work} eq "pal*list*pal*") || ($self->{work} eq "char*char*char*") || ($self->{work} eq "char*pal*char*") || ($self->{work} eq "pal*pal*pal*") || ($self->{work} eq "pal*char*pal*")) {
            $self->pushToken();
            $self->pushToken();
            $self->pushToken();
            if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
            $self->{work} .= $self->{tape}[$self->{cell}];  # get
            if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
            if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
            if ($self->{tape}[$self->{cell}] eq $self->{work}) {
              $self->{work} = '';  # clear 
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              $self->increment();   # ++ 
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              $self->increment();   # ++ 
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
              if ($self->{cell} > 0) { $self->{cell} -= 1; } # --
              ${$self->{tape}}[$self->{cell}] = $self->{work};   # put 
              $self->{work} = '';  # clear 
              $self->{work} .= "[palindrome found!] ends at line "; # add 
              $self->{work} .= $self->{linesRead}; # lines 
              $self->{work} .= ", char "; # add 
              $self->{work} .= $self->{charsRead}; # chars 
              $self->{work} .= ": "; # add 
              $self->{work} .= $self->{tape}[$self->{cell}];  # get
              $self->{work} .= "\n"; # add 
              $self->writeText(); # print  
              $self->{work} = '';  # clear 
              $self->increment();   # ++ 
              $self->increment();   # ++ 
              $self->increment();   # ++ 
              $self->popToken();
              $self->popToken();
              $self->popToken();
              $self->{work} = '';  # clear 
              $self->{work} .= "pal*"; # add 
              $self->pushToken();
              next PARSE;
            }
            $self->{work} = '';  # clear 
            $self->increment();   # ++ 
            $self->increment();   # ++ 
            $self->increment();   # ++ 
            $self->popToken();
            $self->popToken();
            $self->popToken();
          }
          $self->pushToken();
          $self->pushToken();
          $self->pushToken();
          if ($self->{eof}) {
            $self->popToken();
            $self->popToken();
            if ($self->{work} eq "pal*") {
              $self->{work} = '';  # clear 
              $self->{work} .= "[whole string is a complete palindrome!]\n"; # add 
              $self->writeText(); # print  
              last SCRIPT; # quit 
            }
            if ($self->{work} eq "list*") {
              $self->{work} = '';  # clear 
              $self->{work} .= "[a list]\n"; # add 
              $self->writeText(); # print  
              last SCRIPT; # quit 
            }
            $self->pushToken();
            $self->pushToken();
            $self->{work} .= "Whole string may not be a palindrome.\n"; # add 
            $self->writeText(); # print  
            $self->{work} = '';  # clear 
          }
           last PARSE;  # run-once parse loop 
         } # parse block 
      } # nom script loop 

     # close open files here? yes. use break, not return
     my $outputType = $self->{sinkType};
     if ($outputType eq "file") {
       $self->{output}->flush() or die "Error flushing output file: $!";
     } elsif ($outputType eq "stdout") {
       # STDOUT is typically flushed automatically
     } elsif ($outputType eq "string") {
       # Output is in the buffer
     } else {
       print STDERR "unsupported output type: ", $outputType, "\n";
     }
   } # sub parse


 sub printHelp {
   print <<EOF;

   Nom script translated to perl by www.nomlang.org/tr/ script 
   usage:
         echo "..sometext.." | ./script
         cat somefile.txt | ./script
         ./script -f <file>
         ./script -i <text>
   options:
     --file -f <file>
       run the script with <file> as input (not stdin)
     --input -i <text>
       run the script with <text> as input
     --filetest -F <filename>
       test the translated script with file input and output
     --filestream -S <filename>
       test the translated script with file-stream input
     --inputtest -I <text>
       test the translated script with string input and output
     --ifile -E <filename> 
       make the translated-translator act as an interpreter (interprets
       the nom script in the given file. Only works with the translated
       translator - eg: 
         pep -f nom.toperl.pss nom.toperl.pss > nomtoperl.pl
         chmod +x nomtoperl.pl
         echo "hannah" | ./nomtoperl.pl -E ../eg/palindrome.pss
     --help -h
       show this help

EOF

 }

 # display a message about a missing argument to the translated
 #    script 
 sub missingArgument {
   print "Missing argument.\n";
   printHelp();
   exit 1;
 }

 # display a message if an command line option is repeated
 sub duplicateSwitch {
   print "Duplicate switch found.\n";
   printHelp();
   exit 1;
 }

 sub checkTextFile {
   my ($filepath) = @_;
   eval {
     open my $fh, "<:utf8", $filepath;
     close $fh;
     return true;
   };
   if ($@) {
     if ($@ =~ /No such file or directory/) {
       print "File [$filepath] not found.\n";
     } elsif ($@ =~ /Permission denied/) {
       print "Permission denied to read file [$filepath]\n";
     } else {
       print "Error opening file $filepath: $@";
     }
     return false;
   }
   return true;
 }

# shows where the package ends.
1;

package main;

  my $mm = Machine->new();
  my $input = "";
  my $filename = "";

  GetOptions (
    "file|f=s"      => $filename,
    "input|i=s"     => $input,
    "filetest|F=s"  => sub {
      my ($opt_name, $value) = @_;
      if ($value) {
        if ($filename ne "") { $mm->duplicateSwitch(); }
        if (!$mm->checkTextFile($value)) { $mm->printHelp(); exit 1; }
        $mm->parseFile($value, "out.txt");
        my $output = do {
          local $/ = undef;
          open my $fh, "<:utf8", "out.txt" or die "Could not open out.txt: $!";
          <$fh>;
        };
        print $output;
        exit($mm->{accumulator});
      } else {
        $mm->missingArgument();
      }
    },
    "filestream|S=s" => sub {
      my ($opt_name, $value) = @_;
      if ($value) {
        if ($filename ne "") { $mm->duplicateSwitch(); }
        if (!$mm->checkTextFile($value)) { $mm->printHelp(); exit 1; }
        $mm->setFileStreamInput($value);
      } else {
        $mm->missingArgument();
      }
    },
    "inputtest|I=s" => sub {
      my ($opt_name, $value) = @_;
      if ($value) {
        if ($input ne "") { $mm->duplicateSwitch(); }
        my $text = $mm->parseString($value);
        print $text;
        exit($mm->{accumulator});
      } else {
        $mm->missingArgument();
      }
    },
    "ifile|E=s"  => sub {
      my ($opt_name, $ifile) = @_;
      if ($ifile) {
        if ($filename ne "") { $mm->duplicateSwitch(); }
        if (!$mm->checkTextFile($ifile)) { $mm->printHelp(); exit 1; }
        $mm->interpret($ifile);
        exit($mm->{accumulator});
      } else {
        $mm->missingArgument();
      }
    },
    "help|h"        => sub { $mm->printHelp(); exit 0; },
  ) or die "Error in command line arguments\n";

  if ($input ne "" && $filename ne "") {
    print <<EOF;

    Either use the --file/--filetest options or the --input/--inputtest
    options, not both

EOF
    printHelp();
    exit 0;
  }

  $mm->parse();
  # accumulator as exit code 
  exit($mm->{accumulator});
  # shows where the package ends.
  #1;

  
