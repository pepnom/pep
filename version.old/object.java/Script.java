/* Java code generated by 'compile.java.pss' */
import java.io.*; 
public class Script { 
  public static void main(String[] args) throws Exception { 
    Machine mm = new Machine(new InputStreamReader(System.in));
    script: 
    while (mm.eof() != true) {
      lex: { 
        mm.read();
        if (mm.workspace.toString().equals("+") || mm.workspace.toString().equals("-")) {
          mm.put();
          mm.clear();
          mm.add("opadd*");
          mm.push();
        }
        if (mm.workspace.toString().equals("*") || mm.workspace.toString().equals("/")) {
          mm.put();
          mm.clear();
          mm.add("opmul*");
          mm.push();
        }
        if (mm.workspace.toString().equals("(") || mm.workspace.toString().equals(")")) {
          mm.put();
          mm.add("*");
          mm.push();
        }
        if (mm.testClass("[0-9]")) {
          mm.whilePeep("[0-9]");
          mm.put();
          mm.clear();
          mm.add("number*");
          mm.push();
        }
        if (mm.testClass("[a-z]")) {
          mm.whilePeep("[a-z]");
          mm.put();
          mm.clear();
          mm.add("variable*");
          mm.push();
        }
        if (mm.testClass("[:space:]")) {
          mm.clear();
        }
        // a trick to catch bad characters. 
        // better would be a !"text" syntax but this is not implemented
        // yet (aug 2019)
        if (mm.workspace.toString().equals("")) {
          break lex;
        }
        mm.add(" << incorrect character (at character ");
        mm.chars();
        mm.add(" of input). \n");
        mm.print();
        break script;
      }
      parse: 
      while (true) { 
        // The parse/compile/translate/transform phase involves 
        // recognising series of tokens on the stack and "reducing" them
        // according to the required bnf grammar rules.
        mm.pop();
        // resolve numbers to expressions to simplify grammar rules
        // add a preceding space to numbers and variables.
        if (mm.workspace.toString().equals("number*") || mm.workspace.toString().equals("variable*")) {
          mm.clear();
          mm.add(" ");
          mm.get();
          mm.put();
          mm.clear();
          mm.add("exp*");
          mm.push();
          continue parse;
        }
        //-----------------
        // 3 tokens
        mm.pop();
        mm.pop();
        // we dont need any look ahead here because * and / have 
        // precedence.
        if (mm.workspace.toString().equals("exp*opmul*exp*")) {
          mm.clear();
          mm.add(" (");
          mm.increment();
          mm.get();
          mm.decrement();
          mm.get();
          mm.increment();
          mm.increment();
          mm.get();
          mm.add(")");
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("exp*");
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("(*exp*)*")) {
          mm.clear();
          mm.increment();
          mm.get();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("exp*");
          mm.push();
          continue parse;
        }
        if (mm.eof()) {
          if (mm.workspace.toString().equals("exp*opadd*exp*")) {
            mm.clear();
            mm.add(" (");
            mm.increment();
            mm.get();
            mm.decrement();
            mm.get();
            mm.increment();
            mm.increment();
            mm.get();
            mm.add(")");
            mm.decrement();
            mm.decrement();
            mm.put();
            mm.clear();
            mm.add("exp*");
            mm.push();
            continue parse;
          }
        }
        //-----------------
        // 4 tokens
        mm.pop();
        if (mm.workspace.toString().equals("exp*opadd*exp*opadd*")) {
          mm.clear();
          mm.add(" (");
          mm.increment();
          mm.get();
          mm.decrement();
          mm.get();
          mm.increment();
          mm.increment();
          mm.get();
          mm.add(")");
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("exp*opadd*");
          mm.push();
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("exp*opadd*exp*)*")) {
          mm.clear();
          mm.add(" (");
          mm.increment();
          mm.get();
          mm.decrement();
          mm.get();
          mm.increment();
          mm.increment();
          mm.get();
          mm.add(")");
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("exp*)*");
          mm.push();
          mm.push();
          continue parse;
        }
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        if (mm.eof()) {
          mm.pop();
          mm.pop();
          if (mm.workspace.toString().equals("exp*")) {
            mm.clear();
            // add "Yes, its an expression! \n";
            mm.add("lisp format: ");
            mm.get();
            mm.add("\n");
            mm.print();
            mm.clear();
            break script;
          }
          mm.push();
          mm.push();
          mm.add("No, it doesn't look like a valid 'in-fix' expression. \n");
          mm.add("The parse stack was: ");
          mm.print();
          mm.clear();
          mm.popall();
          mm.add("\n");
          mm.print();
          break script;
        }
        break parse;
      }
    }
  }
}
