/* Java code generated by 'compile.java.pss' */
import java.io.*; 
public class Compile { 
  public static void main(String[] args) throws Exception { 
    Machine mm = new Machine(new InputStreamReader(System.in));
    script: 
    while (mm.eof() != true) {
      lex: { 
        mm.read();
        //--------------
        if (mm.testClass("[:space:]")) {
          mm.clear();
          break lex;
        }
        //---------------
        // We can ellide all these single character tests, because
        // the stack token is just the character itself with a *
        // Braces {} are used for blocks of commands, ',' and '.' for concatenating
        // tests with OR or AND logic. 'B' and 'E' for begin and end
        // tests, '!' is used for negation, ';' is used to terminate a 
        // command.
        if (mm.workspace.toString().equals("{") || mm.workspace.toString().equals("}") || mm.workspace.toString().equals(";") || mm.workspace.toString().equals(",") || mm.workspace.toString().equals(".") || mm.workspace.toString().equals("!") || mm.workspace.toString().equals("B") || mm.workspace.toString().equals("E")) {
          mm.put();
          mm.add("*");
          mm.push();
          break lex;
        }
        //---------------
        // format: "text"
        if (mm.workspace.toString().equals("\"")) {
          // save the start line number (for error messages) in case 
          // there is no terminating quote character.
          mm.clear();
          mm.lines();
          mm.put();
          mm.clear();
          mm.add("\"");
          mm.until("\"");
          if (!mm.workspace.toString().endsWith("\"")) {
            mm.clear();
            mm.add("Unterminated quote (\") starting at line ");
            mm.get();
            mm.add(" !\n");
            mm.print();
            break script;
          }
          mm.put();
          mm.clear();
          mm.add("quote*");
          mm.push();
          break lex;
        }
        //---------------
        // format: 'text', single quotes are converted to double quotes
        // but we must escape embedded double quotes.
        if (mm.workspace.toString().equals("'")) {
          // save the start line number (for error messages) in case 
          // there is no terminating quote character.
          mm.clear();
          mm.lines();
          mm.put();
          mm.clear();
          mm.until("'");
          if (!mm.workspace.toString().endsWith("'")) {
            mm.clear();
            mm.add("Unterminated quote (') starting at line ");
            mm.get();
            mm.add("!\n");
            mm.print();
            break script;
          }
          mm.clip();
          mm.escapeChar("\"");
          mm.put();
          mm.clear();
          mm.add("\"");
          mm.get();
          mm.add("\"");
          mm.put();
          mm.clear();
          mm.add("quote*");
          mm.push();
          break lex;
        }
        //---------------
        // formats: [:space:] [a-z] [abcd] [:alpha:] etc 
        if (mm.workspace.toString().equals("[")) {
          mm.until("]");
          mm.put();
          mm.clear();
          // add quotes around the class
          mm.add("\"");
          mm.get();
          mm.add("\"");
          mm.put();
          mm.clear();
          mm.add("class*");
          mm.push();
          break lex;
        }
        //---------------
        // formats: (eof) (EOF) (==) etc. 
        if (mm.workspace.toString().equals("(")) {
          mm.clear();
          mm.until(")");
          mm.clip();
          mm.put();
          if (mm.workspace.toString().equals("eof") || mm.workspace.toString().equals("EOF")) {
            mm.clear();
            mm.add("eof*");
            mm.push();
            break lex;
          }
          if (mm.workspace.toString().equals("==")) {
            mm.clear();
            mm.add("tapetest*");
            mm.push();
            break lex;
          }
          mm.add(" << unknown test near line ");
          mm.lines();
          mm.add(" of script.\n");
          mm.add(" bracket () tests are \n");
          mm.add("   (eof) test if end of stream reached. \n");
          mm.add("   (==)  test if workspace is same as current tape cell \n");
          mm.print();
          mm.clear();
          break script;
        }
        //---------------
        // multiline and single line comments, eg #... and #* ... *#
        if (mm.workspace.toString().equals("#")) {
          mm.clear();
          mm.read();
          if (mm.workspace.toString().equals("\n")) {
            mm.clear();
            break lex;
          }
          // checking for multiline comments of the form "#* \n\n\n *#"
          // these are just ignored at the moment (deleted) 
          if (mm.workspace.toString().equals("*")) {
            // save the line number for possible error message later
            mm.clear();
            mm.lines();
            mm.put();
            mm.clear();
            mm.until("*#");
            if (mm.workspace.toString().endsWith("*#")) {
              // convert to /* ... */ java multiline comment
              mm.clip();
              mm.clip();
              mm.put();
              mm.clear();
              mm.add("/*");
              mm.get();
              mm.add("*/");
              // create a "comment" parse token
              mm.put();
              mm.clear();
              // comment-out this line to remove multiline comments from the 
              // compiled java.
              // add "comment*"; push; 
              break lex;
            }
            // make an unterminated multiline comment an error
            // to ease debugging of scripts.
            mm.clear();
            mm.add("unterminated multiline comment #* ... *# \n");
            mm.add("stating at line number ");
            mm.get();
            mm.add("\n");
            mm.print();
            mm.clear();
            break script;
          }
          // single line comments. some will get lost.
          mm.put();
          mm.clear();
          mm.add("//");
          mm.get();
          mm.until("\n");
          mm.clip();
          mm.put();
          mm.clear();
          mm.add("comment*");
          mm.push();
          break lex;
        }
        //----------------------------------
        // parse command words (and abbreviations)
        // legal characters for keywords (commands)
        if (!mm.workspace.testClass("[abcdefghijklmnopqrstuvwxyzBEKGPRUWS+-<>0^]")) {
          // error message about a misplaced character
          mm.put();
          mm.clear();
          mm.add("!! Misplaced character '");
          mm.get();
          mm.add("' in script near line ");
          mm.lines();
          mm.add(" (character ");
          mm.chars();
          mm.add(") \n");
          mm.print();
          mm.clear();
          break script;
        }
        // my testclass implementation cannot handle complex lists
        // eg [a-z+-] this is why I have to write out the whole alphabet
        mm.whilePeep("[abcdefghijklmnopqrstuvwxyzBEOFKGPRUWS+-<>0^]");
        //----------------------------------
        // KEYWORDS 
        // here we can test for all the keywords (command words) and their
        // abbreviated one letter versions (eg: clip k, clop K etc). Then
        // we can print an error message and abort if the word is not a 
        // legal keyword for the parse-edit language
        if (mm.workspace.toString().equals("a")) {
          mm.clear();
          mm.add("add");
        }
        if (mm.workspace.toString().equals("k")) {
          mm.clear();
          mm.add("clip");
        }
        if (mm.workspace.toString().equals("K")) {
          mm.clear();
          mm.add("clop");
        }
        if (mm.workspace.toString().equals("D")) {
          mm.clear();
          mm.add("replace");
        }
        if (mm.workspace.toString().equals("d")) {
          mm.clear();
          mm.add("clear");
        }
        if (mm.workspace.toString().equals("t")) {
          mm.clear();
          mm.add("print");
        }
        if (mm.workspace.toString().equals("p")) {
          mm.clear();
          mm.add("pop");
        }
        if (mm.workspace.toString().equals("P")) {
          mm.clear();
          mm.add("push");
        }
        if (mm.workspace.toString().equals("u")) {
          mm.clear();
          mm.add("unstack");
        }
        if (mm.workspace.toString().equals("U")) {
          mm.clear();
          mm.add("stack");
        }
        if (mm.workspace.toString().equals("G")) {
          mm.clear();
          mm.add("put");
        }
        if (mm.workspace.toString().equals("g")) {
          mm.clear();
          mm.add("get");
        }
        if (mm.workspace.toString().equals("x")) {
          mm.clear();
          mm.add("swap");
        }
        if (mm.workspace.toString().equals(">")) {
          mm.clear();
          mm.add("++");
        }
        if (mm.workspace.toString().equals("<")) {
          mm.clear();
          mm.add("--");
        }
        if (mm.workspace.toString().equals("m")) {
          mm.clear();
          mm.add("mark");
        }
        if (mm.workspace.toString().equals("M")) {
          mm.clear();
          mm.add("go");
        }
        if (mm.workspace.toString().equals("r")) {
          mm.clear();
          mm.add("read");
        }
        if (mm.workspace.toString().equals("R")) {
          mm.clear();
          mm.add("until");
        }
        if (mm.workspace.toString().equals("w")) {
          mm.clear();
          mm.add("while");
        }
        if (mm.workspace.toString().equals("W")) {
          mm.clear();
          mm.add("whilenot");
        }
        // we can probably omit tests and jumps since they are not
        // designed to be used in scripts (only assembled parse programs).
        if (mm.workspace.toString().equals("n")) {
          mm.clear();
          mm.add("count");
        }
        if (mm.workspace.toString().equals("+")) {
          mm.clear();
          mm.add("a+");
        }
        if (mm.workspace.toString().equals("-")) {
          mm.clear();
          mm.add("a-");
        }
        if (mm.workspace.toString().equals("0")) {
          mm.clear();
          mm.add("zero");
        }
        if (mm.workspace.toString().equals("c")) {
          mm.clear();
          mm.add("cc");
        }
        if (mm.workspace.toString().equals("l")) {
          mm.clear();
          mm.add("ll");
        }
        if (mm.workspace.toString().equals("^")) {
          mm.clear();
          mm.add("escape");
        }
        if (mm.workspace.toString().equals("v")) {
          mm.clear();
          mm.add("unescape");
        }
        if (mm.workspace.toString().equals("z")) {
          mm.clear();
          mm.add("delim");
        }
        if (mm.workspace.toString().equals("S")) {
          mm.clear();
          mm.add("state");
        }
        if (mm.workspace.toString().equals("q")) {
          mm.clear();
          mm.add("quit");
        }
        if (mm.workspace.toString().equals("Q")) {
          mm.clear();
          mm.add("bail");
        }
        if (mm.workspace.toString().equals("s")) {
          mm.clear();
          mm.add("write");
        }
        if (mm.workspace.toString().equals("o")) {
          mm.clear();
          mm.add("nop");
        }
        if (mm.workspace.toString().equals("rs")) {
          mm.clear();
          mm.add("restart");
        }
        if (mm.workspace.toString().equals("rp")) {
          mm.clear();
          mm.add("reparse");
        }
        // some extra syntax for testeof and testtape
        if (mm.workspace.toString().equals("<eof>") || mm.workspace.toString().equals("<EOF>")) {
          mm.put();
          mm.clear();
          mm.add("eof*");
          mm.push();
          break lex;
        }
        if (mm.workspace.toString().equals("<==>")) {
          mm.put();
          mm.clear();
          mm.add("tapetest*");
          mm.push();
          break lex;
        }
        if (mm.workspace.toString().equals("add") || mm.workspace.toString().equals("clip") || mm.workspace.toString().equals("clop") || mm.workspace.toString().equals("replace") || mm.workspace.toString().equals("clear") || mm.workspace.toString().equals("print") || mm.workspace.toString().equals("pop") || mm.workspace.toString().equals("push") || mm.workspace.toString().equals("unstack") || mm.workspace.toString().equals("stack") || mm.workspace.toString().equals("put") || mm.workspace.toString().equals("get") || mm.workspace.toString().equals("swap") || mm.workspace.toString().equals("++") || mm.workspace.toString().equals("--") || mm.workspace.toString().equals("mark") || mm.workspace.toString().equals("go") || mm.workspace.toString().equals("read") || mm.workspace.toString().equals("until") || mm.workspace.toString().equals("while") || mm.workspace.toString().equals("whilenot") || mm.workspace.toString().equals("jump") || mm.workspace.toString().equals("jumptrue") || mm.workspace.toString().equals("jumpfalse") || mm.workspace.toString().equals("testis") || mm.workspace.toString().equals("testclass") || mm.workspace.toString().equals("testbegins") || mm.workspace.toString().equals("testends") || mm.workspace.toString().equals("testeof") || mm.workspace.toString().equals("testtape") || mm.workspace.toString().equals("count") || mm.workspace.toString().equals("a+") || mm.workspace.toString().equals("a-") || mm.workspace.toString().equals("zero") || mm.workspace.toString().equals("cc") || mm.workspace.toString().equals("ll") || mm.workspace.toString().equals("escape") || mm.workspace.toString().equals("unescape") || mm.workspace.toString().equals("delim") || mm.workspace.toString().equals("state") || mm.workspace.toString().equals("quit") || mm.workspace.toString().equals("bail") || mm.workspace.toString().equals("write") || mm.workspace.toString().equals("nop") || mm.workspace.toString().equals("reparse") || mm.workspace.toString().equals("restart")) {
          mm.put();
          mm.clear();
          mm.add("word*");
          mm.push();
          break lex;
        }
        //------------ 
        // the .reparse command and "parse label" is a simple way to 
        // make sure that all shift-reductions occur. It should be used inside
        // a block test, so as not to create an infinite loop. There is
        // no "goto" in java so we need to use labelled loops to 
        // implement .reparse/parse>
        if (mm.workspace.toString().equals("parse>")) {
          mm.clear();
          mm.count();
          if (!mm.workspace.toString().equals("0")) {
            mm.clear();
            mm.add("script error:\n");
            mm.add("  extra parse> label at line ");
            mm.lines();
            mm.add(".\n");
            mm.print();
            break script;
          }
          mm.clear();
          mm.add("// parse>");
          mm.put();
          mm.clear();
          mm.add("parse>*");
          mm.push();
          // use accumulator to indicate after parse> label
          mm.accumulator++; // a+
          break lex;
        }
        // --------------------
        // implement "begin-blocks", which are only executed
        // once, at the beginning of the script (similar to awk's BEGIN {} rules)
        if (mm.workspace.toString().equals("begin")) {
          mm.put();
          mm.add("*");
          mm.push();
          break lex;
        }
        mm.add(" << unknown command on line ");
        mm.lines();
        mm.add(" (char ");
        mm.chars();
        mm.add(")");
        mm.add(" of source file. \n");
        mm.print();
        mm.clear();
        break script;
        // ----------------------------------
        // PARSING PHASE:
        // Below is the parse/compile phase of the script. Here we pop tokens off the
        // stack and check for sequences of tokens eg "word*semicolon*". If we find a
        // valid series of tokens, we "shift-reduce" or "resolve" the token series eg
        // word*semicolon* --> command*
        // At the same time, we manipulate (transform) the attributes on the tape, as
        // required. 
      }
      parse: 
      while (true) { 
        //-------------------------------------
        // 2 tokens
        //-------------------------------------
        mm.pop();
        mm.pop();
        // All of the patterns below are currently errors, but may not
        // be in the future if we expand the syntax of the parse
        // language. Also consider:
        //    begintext* endtext* quoteset* notclass*, !* ,* ;* B* E*
        // It is nice to trap the errors here because we can emit some
        // (hopefully not very cryptic) error messages with a line number.
        // Otherwise the script writer has to debug with
        //   pp -a asm.pp -I scriptfile 
        if (mm.workspace.toString().equals("word*word*") || mm.workspace.toString().equals("word*}*") || mm.workspace.toString().equals("word*begintext*") || mm.workspace.toString().equals("word*endtext*") || mm.workspace.toString().equals("word*!*") || mm.workspace.toString().equals("word*,*") || mm.workspace.toString().equals("quote*word*") || mm.workspace.toString().equals("quote*class*") || mm.workspace.toString().equals("quote*state*") || mm.workspace.toString().equals("quote*}*") || mm.workspace.toString().equals("quote*begintext*") || mm.workspace.toString().equals("quote*endtext*") || mm.workspace.toString().equals("class*word*") || mm.workspace.toString().equals("class*quote*") || mm.workspace.toString().equals("class*class*") || mm.workspace.toString().equals("class*state*") || mm.workspace.toString().equals("class*}*") || mm.workspace.toString().equals("class*begintext*") || mm.workspace.toString().equals("class*endtext*") || mm.workspace.toString().equals("class*!*") || mm.workspace.toString().equals("notclass*word*") || mm.workspace.toString().equals("notclass*quote*") || mm.workspace.toString().equals("notclass*class*") || mm.workspace.toString().equals("notclass*state*") || mm.workspace.toString().equals("notclass*}*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script (missing semicolon?) \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("{*;*") || mm.workspace.toString().equals(";*;*") || mm.workspace.toString().equals("}*;*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script: misplaced semi-colon? ; \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals(",*{*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script: extra comma in list? \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("command*;*") || mm.workspace.toString().equals("commandset*;*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script: extra semi-colon? \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("!*!*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script: \n double negation '!!' is not implemented \n");
          mm.add(" and probably won't be, because what would be the point? \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("!*{*") || mm.workspace.toString().equals("!*;*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script: misplaced negation operator (!)? \n");
          mm.add(" The negation operator precedes tests, for example: \n");
          mm.add("   !B'abc'{ ... } or !(eof),!'abc'{ ... } \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals(",*command*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script: misplaced comma? \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("!*command*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (at char ");
          mm.chars();
          mm.add(") \n");
          mm.add(" The negation operator (!) cannot precede a command \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals(";*{*") || mm.workspace.toString().equals("command*{*") || mm.workspace.toString().equals("commandset*{*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script: no test for brace block? \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("{*}*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" of script: empty braces {}. \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("B*class*") || mm.workspace.toString().equals("E*class*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" of script:\n  classes ([a-z], [:space:] etc). \n");
          mm.add("  cannot use the 'begin' or 'end' modifiers (B/E) \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("comment*{*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" of script: comments cannot occur between \n");
          mm.add(" a test and a brace ({). \n");
          mm.print();
          mm.clear();
          break script;
        }
        if (mm.workspace.toString().equals("}*command*")) {
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" of script: extra closing brace '}' ?. \n");
          mm.print();
          mm.clear();
          break script;
        }
        //------------ 
        // The .restart command jumps to the first instruction after the
        // begin block (if there is a begin block), or the first instruction
        // of the script.
        if (mm.workspace.toString().equals(".*word*")) {
          mm.clear();
          mm.increment();
          mm.get();
          mm.decrement();
          if (mm.workspace.toString().equals("restart")) {
            mm.clear();
            mm.add("continue script;");
            mm.put();
            mm.clear();
            mm.add("command*");
            mm.push();
            continue parse;
          }
          if (mm.workspace.toString().equals("reparse")) {
            mm.clear();
            mm.count();
            // check accumulator to see if we are in the "lex" block
            // or the "parse" block and adjust the .reparse compilation
            // accordingly.
            if (mm.workspace.toString().equals("0")) {
              mm.clear();
              mm.add("break lex;");
            }
            if (mm.workspace.toString().equals("1")) {
              mm.clear();
              mm.add("continue parse;");
            }
            mm.put();
            mm.clear();
            mm.add("command*");
            mm.push();
            continue parse;
          }
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script:  \n");
          mm.add(" misplaced dot '.' (use for AND logic or in .reparse/.restart \n");
          mm.print();
          mm.clear();
          break script;
        }
        //---------------------------------
        // Compiling comments so as to transfer them to the java 
        if (mm.workspace.toString().equals("comment*command*") || mm.workspace.toString().equals("command*comment*") || mm.workspace.toString().equals("commandset*comment*")) {
          mm.clear();
          mm.get();
          mm.add("\n");
          mm.increment();
          mm.get();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("command*");
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("comment*comment*")) {
          mm.clear();
          mm.get();
          mm.add("\n");
          mm.increment();
          mm.get();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("comment*");
          mm.push();
          continue parse;
        }
        // -----------------------
        // negated tokens.
        // This is a new more elegant way to negate a whole set of 
        // tests (tokens) where the negation logic is stored on the 
        // stack, not in the current tape cell. We just add "not" to 
        // the stack token.
        // eg: ![:alpha:] ![a-z] ![abcd] !"abc" !B"abc" !E"xyz"
        //  This format is used to indicate a negative test for 
        //  a brace block. eg: ![aeiou] { add "< not a vowel"; print; clear; }
        if (mm.workspace.toString().equals("!*quote*") || mm.workspace.toString().equals("!*class*") || mm.workspace.toString().equals("!*begintext*") || mm.workspace.toString().equals("!*endtext*") || mm.workspace.toString().equals("!*eof*") || mm.workspace.toString().equals("!*tapetest*")) {
          // a simplification: store the token name "quote*/class*/..."
          // in the tape cell corresponding to the "!*" token. 
          mm.replace("!*", "not");
          mm.push();
          // this was a bug?? a missing ++; ??
          // now get the token-value
          mm.get();
          mm.decrement();
          mm.put();
          mm.increment();
          mm.clear();
          continue parse;
        }
        //-----------------------------------------
        // format: E"text" or E'text'
        //  This format is used to indicate a "workspace-ends-with" text before
        //  a brace block.
        if (mm.workspace.toString().equals("E*quote*")) {
          mm.clear();
          mm.add("endtext*");
          mm.push();
          mm.get();
          mm.decrement();
          mm.put();
          mm.increment();
          mm.clear();
          continue parse;
        }
        //-----------------------------------------
        // format: B"sometext" or B'sometext' 
        //   A 'B' preceding some quoted text is used to indicate a 
        //   'workspace-begins-with' test, before a brace block.
        if (mm.workspace.toString().equals("B*quote*")) {
          mm.clear();
          mm.add("begintext*");
          mm.push();
          mm.get();
          mm.decrement();
          mm.put();
          mm.increment();
          mm.clear();
          continue parse;
        }
        //--------------------------------------------
        // ebnf: command := word, ';' ;
        // formats: "pop; push; clear; print; " etc
        // all commands need to end with a semi-colon except for 
        // .reparse and .restart
        if (mm.workspace.toString().equals("word*;*")) {
          mm.clear();
          // check if command requires parameter
          mm.get();
          if (mm.workspace.toString().equals("add") || mm.workspace.toString().equals("until") || mm.workspace.toString().equals("while") || mm.workspace.toString().equals("whilenot") || mm.workspace.toString().equals("mark") || mm.workspace.toString().equals("go") || mm.workspace.toString().equals("escape") || mm.workspace.toString().equals("unescape") || mm.workspace.toString().equals("delim") || mm.workspace.toString().equals("replace")) {
            mm.put();
            mm.clear();
            mm.add("'");
            mm.get();
            mm.add("'");
            mm.add(" << command needs an argument, on line ");
            mm.lines();
            mm.add(" of script.\n");
            mm.print();
            mm.clear();
            break script;
          }
          if (mm.workspace.toString().equals("clip")) {
            mm.clear();
            mm.add("mm.clip();");
            mm.put();
          }
          if (mm.workspace.toString().equals("clop")) {
            mm.clear();
            mm.add("mm.clop();");
            mm.put();
          }
          if (mm.workspace.toString().equals("clear")) {
            mm.clear();
            mm.add("mm.clear();");
            mm.put();
          }
          if (mm.workspace.toString().equals("print")) {
            mm.clear();
            mm.add("mm.print();");
            mm.put();
          }
          if (mm.workspace.toString().equals("pop")) {
            mm.clear();
            mm.add("mm.pop();");
            mm.put();
          }
          if (mm.workspace.toString().equals("push")) {
            mm.clear();
            mm.add("mm.push();");
            mm.put();
          }
          if (mm.workspace.toString().equals("unstack")) {
            mm.clear();
            mm.add("mm.popall();");
            mm.put();
          }
          if (mm.workspace.toString().equals("stack")) {
            mm.clear();
            mm.add("mm.pushall();");
            mm.put();
          }
          if (mm.workspace.toString().equals("put")) {
            mm.clear();
            mm.add("mm.put();");
            mm.put();
          }
          if (mm.workspace.toString().equals("get")) {
            mm.clear();
            mm.add("mm.get();");
            mm.put();
          }
          if (mm.workspace.toString().equals("swap")) {
            mm.clear();
            mm.add("mm.swap();");
            mm.put();
          }
          if (mm.workspace.toString().equals("++")) {
            mm.clear();
            mm.add("mm.increment();");
            mm.put();
          }
          if (mm.workspace.toString().equals("--")) {
            mm.clear();
            mm.add("mm.decrement();");
            mm.put();
          }
          if (mm.workspace.toString().equals("read")) {
            mm.clear();
            mm.add("mm.read();");
            mm.put();
          }
          // It might be useful to do, after each read() 
          //   ww = mm.workspace.toString(); 
          // we can omit tests and jumps since they are not
          // designed to be used in scripts (only assembled parse programs).
          if (mm.workspace.toString().equals("count")) {
            mm.clear();
            mm.add("mm.count();");
            mm.put();
          }
          if (mm.workspace.toString().equals("a+")) {
            mm.clear();
            mm.add("mm.accumulator++; // a+");
            mm.put();
          }
          if (mm.workspace.toString().equals("a-")) {
            mm.clear();
            mm.add("mm.accumulator--; // a-");
            mm.put();
          }
          if (mm.workspace.toString().equals("zero")) {
            mm.clear();
            mm.add("mm.accumulator = 0; // zero");
            mm.put();
          }
          if (mm.workspace.toString().equals("cc")) {
            mm.clear();
            mm.add("mm.chars();");
            mm.put();
          }
          // or use this
          // "ll" { clear; add "mm.workspace += mm.linesRead;"; put; }
          if (mm.workspace.toString().equals("ll")) {
            mm.clear();
            mm.add("mm.lines();");
            mm.put();
          }
          if (mm.workspace.toString().equals("state")) {
            mm.clear();
            mm.add("mm.state();");
            mm.put();
          }
          // use a labelled loop to quit script.
          if (mm.workspace.toString().equals("quit")) {
            mm.clear();
            mm.add("break script;");
            mm.put();
          }
          if (mm.workspace.toString().equals("bail")) {
            mm.clear();
            mm.add("break script;");
            mm.put();
          }
          if (mm.workspace.toString().equals("write")) {
            mm.clear();
            mm.add("mm.writeToFile();");
            mm.put();
          }
          // just eliminate since it does nothing.
          if (mm.workspace.toString().equals("nop")) {
            mm.clear();
            mm.add("// nop (eliminated)");
            mm.put();
          }
          mm.clear();
          mm.add("command*");
          mm.push();
          continue parse;
        }
        //-----------------------------------------
        // ebnf: commandset := command , command ;
        if (mm.workspace.toString().equals("command*command*") || mm.workspace.toString().equals("commandset*command*")) {
          mm.clear();
          mm.add("commandset*");
          mm.push();
          // format the tape attributes. Add the next command on a newline 
          mm.decrement();
          mm.get();
          mm.add("\n");
          mm.increment();
          mm.get();
          mm.decrement();
          mm.put();
          mm.increment();
          mm.clear();
          continue parse;
        }
        //-------------------
        // here we begin to parse "test*" and "ortestset*" and "andtestset*"
        // 
        //-------------------
        // eg: B"abc" {} or E"xyz" {}
        if (mm.workspace.toString().equals("begintext*{*") || mm.workspace.toString().equals("endtext*{*") || mm.workspace.toString().equals("quote*{*") || mm.workspace.toString().equals("class*{*") || mm.workspace.toString().equals("eof*{*") || mm.workspace.toString().equals("tapetest*{*")) {
          if (mm.workspace.toString().startsWith("begin")) {
            mm.clear();
            mm.add("mm.workspace.toString().startsWith(");
          }
          if (mm.workspace.toString().startsWith("end")) {
            mm.clear();
            mm.add("mm.workspace.toString().endsWith(");
          }
          if (mm.workspace.toString().startsWith("quote")) {
            mm.clear();
            mm.add("mm.workspace.toString().equals(");
          }
          if (mm.workspace.toString().startsWith("class")) {
            mm.clear();
            mm.add("mm.testClass(");
          }
          // clear the tapecell for testeof and testtape because
          // they take no arguments. 
          if (mm.workspace.toString().startsWith("eof")) {
            mm.clear();
            mm.put();
            mm.add("mm.eof(");
          }
          if (mm.workspace.toString().startsWith("tapetest")) {
            mm.clear();
            mm.put();
            mm.add("(mm.workspace == mm.tape[mm.tapePointer]");
          }
          mm.get();
          mm.add(")");
          mm.put();
          mm.clear();
          mm.add("test*{*");
          mm.push();
          mm.push();
          continue parse;
        }
        //-------------------
        // negated tests
        // eg: !B"xyz {} 
        //     !E"xyz" {} 
        //     !"abc" {}
        //     ![a-z] {}
        if (mm.workspace.toString().equals("notbegintext*{*") || mm.workspace.toString().equals("notendtext*{*") || mm.workspace.toString().equals("notquote*{*") || mm.workspace.toString().equals("notclass*{*") || mm.workspace.toString().equals("noteof*{*") || mm.workspace.toString().equals("nottapetest*{*")) {
          if (mm.workspace.toString().startsWith("notbegin")) {
            mm.clear();
            mm.add("!mm.workspace.toString().startsWith(");
          }
          if (mm.workspace.toString().startsWith("notend")) {
            mm.clear();
            mm.add("!mm.workspace.toString().endsWith(");
          }
          if (mm.workspace.toString().startsWith("notquote")) {
            mm.clear();
            mm.add("!mm.workspace.toString().equals(");
          }
          if (mm.workspace.toString().startsWith("notclass")) {
            mm.clear();
            mm.add("!mm.workspace.testClass(");
          }
          // clear the tapecell for testeof and testtape because
          // they take no arguments. 
          if (mm.workspace.toString().startsWith("noteof")) {
            mm.clear();
            mm.put();
            mm.add("!mm.eof(");
          }
          if (mm.workspace.toString().startsWith("nottapetest")) {
            mm.clear();
            mm.put();
            mm.add("(mm.workspace != mm.tape[mm.tapePointer]");
          }
          mm.get();
          mm.add(")");
          // the final jumpfalse + target will be added later
          // use the accumulator to store the incremented jump target
          mm.put();
          mm.clear();
          mm.add("test*{*");
          mm.push();
          mm.push();
          continue parse;
        }
        //-------------------
        // 3 tokens
        //-------------------
        mm.pop();
        //-----------------------------
        // some 3 token errors!!!
        // there are many other of these errors but I am not going
        // to write them all.
        if (mm.workspace.toString().equals("{*quote*;*") || mm.workspace.toString().equals("{*begintext*;*") || mm.workspace.toString().equals("{*endtext*;*") || mm.workspace.toString().equals("{*class*;*")) {
          mm.push();
          mm.push();
          mm.push();
          mm.add("error near line ");
          mm.lines();
          mm.add(" (char ");
          mm.chars();
          mm.add(")");
          mm.add(" of script (misplaced semicolon?) \n");
          mm.print();
          mm.clear();
          break script;
        }
        // to simplify subsequent tests, transmogrify a single command
        // to a commandset (multiple commands).
        if (mm.workspace.toString().equals("{*command*}*")) {
          mm.clear();
          mm.add("{*commandset*}*");
          mm.push();
          mm.push();
          mm.push();
          continue parse;
        }
        // rule 
        //',' ortestset ::= ',' test '{'
        // trigger a transmogrification from test to ortestset token
        // and 
        // '.' andtestset ::= '.' test '{'
        if (mm.workspace.toString().equals(",*test*{*")) {
          mm.clear();
          mm.add(",*ortestset*{*");
          mm.push();
          mm.push();
          mm.push();
          continue parse;
        }
        // trigger a transmogrification from "test" to "andtest" by
        // looking backwards in the stack
        if (mm.workspace.toString().equals(".*test*{*")) {
          mm.clear();
          mm.add(".*andtestset*{*");
          mm.push();
          mm.push();
          mm.push();
          continue parse;
        }
        // errors! mixing AND and OR concatenation
        if (mm.workspace.toString().equals(",*andtestset*{*") || mm.workspace.toString().equals(".*ortestset*{*")) {
          // push the tokens back to make debugging easier
          mm.push();
          mm.push();
          mm.push();
          mm.add(" error: mixing AND (.) and OR (,) concatenation in \n");
          mm.add(" in script near line ");
          mm.lines();
          mm.add(" (character ");
          mm.chars();
          mm.add(") \n");
          mm.print();
          mm.clear();
          break script;
        }
        //--------------------------------------------
        // ebnf: command := keyword , quoted-text , ";" ;
        // format: add "text";
        if (mm.workspace.toString().equals("word*quote*;*")) {
          mm.clear();
          mm.get();
          if (mm.workspace.toString().equals("replace")) {
            // error 
            mm.add("< command requires 2 parameters, not 1 \n");
            mm.add("near line ");
            mm.lines();
            mm.add(" of script. \n");
            mm.print();
            mm.clear();
            break script;
          }
          if (mm.workspace.toString().equals("add") || mm.workspace.toString().equals("until") || mm.workspace.toString().equals("while") || mm.workspace.toString().equals("whilenot") || mm.workspace.toString().equals("escape") || mm.workspace.toString().equals("mark") || mm.workspace.toString().equals("go") || mm.workspace.toString().equals("unescape") || mm.workspace.toString().equals("delim")) {
            mm.clear();
            mm.add("mm.");
            mm.get();
            if (mm.workspace.toString().equals("mm.escape") || mm.workspace.toString().equals("mm.unescape")) {
              mm.add("Char");
            }
            if (mm.workspace.toString().equals("mm.while") || mm.workspace.toString().equals("mm.whilenot")) {
              mm.add("Peep");
            }
            mm.add("(");
            mm.increment();
            mm.get();
            mm.decrement();
            mm.add(");");
            mm.put();
            mm.clear();
            mm.add("command*");
            mm.push();
            continue parse;
          }
          // error, superfluous argument
          mm.add(": command does not take an argument \n");
          mm.add("near line ");
          mm.lines();
          mm.add(" of script. \n");
          mm.print();
          mm.clear();
          //state
          break script;
        }
        //----------------------------------
        // format: "while [:alpha:] ;" or whilenot [a-z] ;
        if (mm.workspace.toString().equals("word*class*;*")) {
          mm.clear();
          mm.get();
          if (mm.workspace.toString().equals("while") || mm.workspace.toString().equals("whilenot")) {
            mm.clear();
            mm.add("mm.");
            mm.get();
            mm.add("Peep(");
            mm.increment();
            mm.get();
            mm.decrement();
            mm.add(");");
            mm.put();
            mm.clear();
            mm.add("command*");
            mm.push();
            continue parse;
          }
          // error 
          mm.add(" < command cannot have a class argument \n");
          mm.add("line ");
          mm.lines();
          mm.add(": error in script \n");
          mm.print();
          mm.clear();
          break script;
        }
        // arrange the parse> label loops
        if (mm.eof()) {
          if (mm.workspace.toString().equals("commandset*parse>*commandset*") || mm.workspace.toString().equals("command*parse>*commandset*") || mm.workspace.toString().equals("commandset*parse>*command*") || mm.workspace.toString().equals("command*parse>*command*")) {
            mm.clear();
            // indent both code blocks
            mm.add("  ");
            mm.get();
            mm.replace("\n", "\n  ");
            mm.put();
            mm.clear();
            mm.increment();
            mm.increment();
            mm.add("  ");
            mm.get();
            mm.replace("\n", "\n  ");
            mm.put();
            mm.clear();
            mm.decrement();
            mm.decrement();
            // add a block so that .reparse works before the parse> label.
            mm.add("lex: { \n");
            mm.get();
            mm.add("\n}\n");
            mm.increment();
            mm.increment();
            // indent code block
            // add "  "; get; replace "\n" "\n  "; put; clear;
            mm.add("parse: \n");
            mm.add("while (true) { \n");
            mm.get();
            mm.add("\n  break parse;\n}");
            mm.decrement();
            mm.decrement();
            mm.put();
            mm.clear();
            mm.add("commandset*");
            mm.push();
            continue parse;
          }
        }
        // -------------------------------
        // 4 tokens
        // -------------------------------
        mm.pop();
        //-------------------------------------
        // bnf:     command := replace , quote , quote , ";" ;
        // example:  replace "and" "AND" ; 
        if (mm.workspace.toString().equals("word*quote*quote*;*")) {
          mm.clear();
          mm.get();
          if (mm.workspace.toString().equals("replace")) {
            //---------------------------
            // a command plus 2 arguments, eg replace "this" "that"
            mm.clear();
            mm.add("mm.");
            mm.get();
            mm.add("(");
            mm.increment();
            mm.get();
            mm.add(", ");
            mm.increment();
            mm.get();
            mm.add(");");
            mm.decrement();
            mm.decrement();
            mm.put();
            mm.clear();
            mm.add("command*");
            mm.push();
            continue parse;
          }
          mm.add(" << command does not take 2 quoted arguments. \n");
          mm.add(" on line ");
          mm.lines();
          mm.add(" of script.\n");
          break script;
        }
        //-------------------------------------
        // format: begin { #* commands *# }
        // "begin" blocks which are only executed once (they
        // will are assembled before the "start:" label. They must come before
        // all other commands.
        // "begin*{*command*}*",
        if (mm.workspace.toString().equals("begin*{*commandset*}*")) {
          mm.clear();
          mm.increment();
          mm.increment();
          mm.get();
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("beginblock*");
          mm.push();
          continue parse;
        }
        // -------------
        // parses and compiles concatenated tests
        // eg: 'a',B'b',E'c',[def],[:space:],[g-k] { ...
        if (mm.workspace.toString().equals("begintext*,*ortestset*{*") || mm.workspace.toString().equals("endtext*,*ortestset*{*") || mm.workspace.toString().equals("quote*,*ortestset*{*") || mm.workspace.toString().equals("class*,*ortestset*{*") || mm.workspace.toString().equals("eof*,*ortestset*{*") || mm.workspace.toString().equals("tapetest*,*ortestset*{*")) {
          if (mm.workspace.toString().startsWith("begin")) {
            mm.clear();
            mm.add("mm.workspace.toString().startsWith(");
          }
          if (mm.workspace.toString().startsWith("end")) {
            mm.clear();
            mm.add("mm.workspace.toString().endsWith(");
          }
          if (mm.workspace.toString().startsWith("quote")) {
            mm.clear();
            mm.add("mm.workspace.toString().equals(");
          }
          if (mm.workspace.toString().startsWith("class")) {
            mm.clear();
            mm.add("mm.workspace.testClass(");
          }
          // put clears the tapecell since no arguments here 
          if (mm.workspace.toString().startsWith("eof")) {
            mm.clear();
            mm.put();
            mm.add("mm.eof(");
          }
          if (mm.workspace.toString().startsWith("tapetest")) {
            mm.clear();
            mm.put();
            mm.add("(mm.workspace == mm.tape[mm.tapePointer]");
          }
          mm.get();
          mm.add(") || ");
          mm.increment();
          mm.increment();
          mm.get();
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("ortestset*{*");
          mm.push();
          mm.push();
          continue parse;
        }
        // A collection of negated tests.
        if (mm.workspace.toString().equals("notbegintext*,*ortestset*{*") || mm.workspace.toString().equals("notendtext*,*ortestset*{*") || mm.workspace.toString().equals("notquote*,*ortestset*{*") || mm.workspace.toString().equals("notclass*,*ortestset*{*") || mm.workspace.toString().equals("noteof*,*ortestset*{*") || mm.workspace.toString().equals("nottapetest*,*ortestset*{*")) {
          if (mm.workspace.toString().startsWith("notbegin")) {
            mm.clear();
            mm.add("!mm.workspace.toString().startsWith(");
          }
          if (mm.workspace.toString().startsWith("notend")) {
            mm.clear();
            mm.add("!mm.workspace.toString().endsWith(");
          }
          if (mm.workspace.toString().startsWith("notquote")) {
            mm.clear();
            mm.add("!mm.workspace.toString().equals(");
          }
          if (mm.workspace.toString().startsWith("notclass")) {
            mm.clear();
            mm.add("!mm.workspace.testClass(");
          }
          // put clears the tapecell since no arguments here 
          if (mm.workspace.toString().startsWith("noteof")) {
            mm.clear();
            mm.put();
            mm.add("!mm.eof(");
          }
          if (mm.workspace.toString().startsWith("nottapetest")) {
            mm.clear();
            mm.put();
            mm.add("(mm.workspace != mm.tape[mm.tapePointer]");
          }
          mm.get();
          mm.add(") || ");
          mm.increment();
          mm.increment();
          mm.get();
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          // dont mix AND and OR concatenations 
          mm.add("ortestset*{*");
          mm.push();
          mm.push();
          continue parse;
        }
        // dont mix AND and OR concatenations 
        // -------------
        // AND logic 
        // parses and compiles concatenated AND tests
        // eg: 'a',B'b',E'c',[def],[:space:],[g-k] { ...
        // it is possible to elide this block with the negated block
        // for compactness but maybe readability is not as good.
        if (mm.workspace.toString().equals("begintext*.*andtestset*{*") || mm.workspace.toString().equals("endtext*.*andtestset*{*") || mm.workspace.toString().equals("quote*.*andtestset*{*") || mm.workspace.toString().equals("class*.*andtestset*{*") || mm.workspace.toString().equals("eof*.*andtestset*{*") || mm.workspace.toString().equals("tapetest*.*andtestset*{*")) {
          if (mm.workspace.toString().startsWith("begin")) {
            mm.clear();
            mm.add("mm.workspace.toString().startsWith(");
          }
          if (mm.workspace.toString().startsWith("end")) {
            mm.clear();
            mm.add("mm.workspace.toString().endsWith(");
          }
          if (mm.workspace.toString().startsWith("quote")) {
            mm.clear();
            mm.add("mm.workspace.toString().equals(");
          }
          // but need to quote the class text "..."
          if (mm.workspace.toString().startsWith("class")) {
            mm.clear();
            mm.add("mm.workspace.testClass(");
          }
          // put clears the tapecell since no arguments here 
          if (mm.workspace.toString().startsWith("eof")) {
            mm.clear();
            mm.put();
            mm.add("mm.eof(");
          }
          if (mm.workspace.toString().startsWith("tapetest")) {
            mm.clear();
            mm.put();
            mm.add("(mm.workspace == mm.tape[mm.tapePointer]");
          }
          mm.get();
          mm.add(") && ");
          mm.increment();
          mm.increment();
          mm.get();
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("andtestset*{*");
          mm.push();
          mm.push();
          continue parse;
        }
        // eg
        // negated tests concatenated with AND logic (.). The 
        // negated tests can be chained with non negated tests.
        // eg: B'http' . !E'.txt' { ... }
        if (mm.workspace.toString().equals("notbegintext*.*andtestset*{*") || mm.workspace.toString().equals("notendtext*.*andtestset*{*") || mm.workspace.toString().equals("notquote*.*andtestset*{*") || mm.workspace.toString().equals("notclass*.*andtestset*{*") || mm.workspace.toString().equals("noteof*.*andtestset*{*") || mm.workspace.toString().equals("nottapetest*.*andtestset*{*")) {
          if (mm.workspace.toString().startsWith("notbegin")) {
            mm.clear();
            mm.add("!mm.workspace.toString().startsWith(");
          }
          if (mm.workspace.toString().startsWith("notend")) {
            mm.clear();
            mm.add("!mm.workspace.toString().endsWith(");
          }
          if (mm.workspace.toString().startsWith("notquote")) {
            mm.clear();
            mm.add("!mm.workspace.toString().equals(");
          }
          if (mm.workspace.toString().startsWith("notclass")) {
            mm.clear();
            mm.add("!mm.workspace.testClass(");
          }
          // put clears the tapecell since no arguments here 
          if (mm.workspace.toString().startsWith("noteof")) {
            mm.clear();
            mm.put();
            mm.add("(mm.peep != null");
          }
          if (mm.workspace.toString().startsWith("nottapetest")) {
            mm.clear();
            mm.put();
            mm.add("(mm.workspace != mm.tape[mm.tapePointer]");
          }
          mm.get();
          mm.add(") && ");
          mm.increment();
          mm.increment();
          mm.get();
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("andtestset*{*");
          mm.push();
          mm.push();
          continue parse;
        }
        //-------------------------------------
        // we should not have to check for the {*command*}* pattern
        // because that has already been transformed to {*commandset*}*
        if (mm.workspace.toString().equals("test*{*commandset*}*") || mm.workspace.toString().equals("andtestset*{*commandset*}*") || mm.workspace.toString().equals("ortestset*{*commandset*}*")) {
          mm.clear();
          // indent the java code for readability
          mm.increment();
          mm.increment();
          mm.add("  ");
          mm.get();
          mm.replace("\n", "\n  ");
          mm.put();
          mm.decrement();
          mm.decrement();
          mm.clear();
          mm.add("if (");
          mm.get();
          mm.add(") {\n");
          mm.increment();
          mm.increment();
          mm.get();
          mm.add("\n}");
          mm.decrement();
          mm.decrement();
          mm.put();
          mm.clear();
          mm.add("command*");
          mm.push();
          // always reparse/compile
          continue parse;
        }
        // -------------
        // multi-token end-of-stream errors
        // not a comprehensive list of errors...
        if (mm.eof()) {
          if (mm.workspace.toString().endsWith("begintext*") || mm.workspace.toString().endsWith("endtext*") || mm.workspace.toString().endsWith("test*") || mm.workspace.toString().endsWith("ortestset*") || mm.workspace.toString().endsWith("andtestset*")) {
            mm.add("  Error near end of script at line ");
            mm.lines();
            mm.add(". Test with no brace block? \n");
            mm.print();
            mm.clear();
            break script;
          }
          if (mm.workspace.toString().endsWith("quote*") || mm.workspace.toString().endsWith("class*") || mm.workspace.toString().endsWith("word*")) {
            mm.put();
            mm.clear();
            mm.add("Error end of script! (line ");
            mm.lines();
            mm.add(") missing semi-colon? \n");
            mm.add("Parse stack: ");
            mm.get();
            mm.add("\n");
            mm.print();
            mm.clear();
            break script;
          }
          if (mm.workspace.toString().endsWith("{*") || mm.workspace.toString().endsWith("}*") || mm.workspace.toString().endsWith(";*") || mm.workspace.toString().endsWith(",*") || mm.workspace.toString().endsWith(".*") || mm.workspace.toString().endsWith("!*") || mm.workspace.toString().endsWith("B*") || mm.workspace.toString().endsWith("E*")) {
            mm.put();
            mm.clear();
            mm.add("Error: misplaced terminal character at end of script! (line ");
            mm.lines();
            mm.add("). \n");
            mm.add("Parse stack: ");
            mm.get();
            mm.add("\n");
            mm.print();
            mm.clear();
            break script;
          }
        }
        // put the 4 (or less) tokens back on the stack
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        if (mm.eof()) {
          mm.print();
          mm.clear();
          //---------------------
          // check if the script correctly parsed (there should only
          // be one token on the stack, namely "commandset*" or "command*").
          mm.pop();
          mm.pop();
          if (mm.workspace.toString().equals("commandset*") || mm.workspace.toString().equals("command*")) {
            mm.clear();
            // indent generated code (6 spaces) for readability.
            mm.add("      ");
            mm.get();
            mm.replace("\n", "\n      ");
            mm.put();
            mm.clear();
            mm.add("/* Java code generated by 'compile.java.pss' */\n");
            mm.add("import java.io.*; \n");
            // add "import java.util.regex.*; \n";
            // not necessary to import Machine class if in same folder
            mm.add("public class Script { \n");
            mm.add("  public static void main(String[] args) throws Exception { \n");
            mm.add("    Machine mm = new Machine(new InputStreamReader(System.in));\n");
            mm.add("    script: \n");
            mm.add("    while (mm.eof() != true) {\n");
            mm.get();
            mm.add("\n    }");
            mm.add("\n  }");
            mm.add("\n}\n");
            // put a copy of the final compilation into the tapecell
            // so it can be inspected interactively.
            mm.put();
            mm.print();
            mm.clear();
            break script;
          }
          if (mm.workspace.toString().equals("beginblock*commandset*") || mm.workspace.toString().equals("beginblock*command*")) {
            mm.clear();
            // indent main code for readability.
            mm.increment();
            mm.add("      ");
            mm.get();
            mm.replace("\n", "\n      ");
            mm.put();
            mm.clear();
            mm.decrement();
            mm.add("/* Assembled with the script 'compile.java.pss' */\n");
            mm.add("import java.io.*; \n");
            // add "import java.util.regex.*; \n";
            mm.add("public class Script { \n");
            mm.add("  public static void main(String[] args) throws Exception { \n");
            mm.add("    Machine mm = new Machine(new InputStreamReader(System.in));\n");
            mm.get();
            mm.add("\n");
            mm.increment();
            // a labelled loop for "quit" (but quit can just exit?)
            mm.add("    script: \n");
            mm.add("    while (mm.eof() != true) {\n");
            mm.get();
            mm.add("\n    }");
            mm.add("\n  }");
            mm.add("\n}\n");
            // put a copy of the final compilation into the tapecell
            // for interactive debugging.
            mm.put();
            mm.print();
            mm.clear();
            break script;
          }
          mm.push();
          mm.push();
          mm.clear();
          mm.add("After compiling with 'compile.java.pss' (at EOF): \n ");
          mm.add("  parse error in input script. \n ");
          mm.print();
          mm.clear();
          mm.popall();
          mm.put();
          mm.clear();
          mm.add("Parse stack: ");
          mm.get();
          mm.add("\n");
          mm.add("   * debug script ");
          mm.add("   >> pp -If script -i 'some input' \n ");
          mm.add("   *  debug compilation. \n ");
          mm.add("   >> pp -Ia asm.pp script' \n ");
          mm.print();
          mm.clear();
          break script;
        }
        // not eof
        // there is an implicit .restart command here (jump start)
        break parse;
      }
    }
  }
}
