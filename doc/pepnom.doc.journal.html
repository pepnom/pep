 

   <!DOCTYPE html>
   <html><head>
   <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
   <link rel='alternate' type='application/rss+xml'
     title='RSS Feed for Pep And Nom Blog' href='/rss.xml' />
   <title>Pep And Nom Blog</title>
   <!-- I will try to read this in with sed -->
   <style type='text/css'>
     


     body { 
       margin-left:5%; margin-right:5%; 
       padding:0; 

       /* need a darker grey color:gray; */
     }
     a { 
       text-decoration:none; 
       /* the wren.io link color */
       color: #3399cc;
       /* color:blue; */
     }
     a:hover { 
       color:darkblue; 
       border-bottom: 1px dashed blue; 
       /* border-top: 1px dashed blue; */
     }

     p { 
       margin-left:2em; margin-right:2em; 
       padding:0; 
     }

     /* used or 1st 2nd etc */

     sup.ordinal {
       text-decoration: underline;  
       color: darkgray;
       font-style: italic;
       text-transform: uppercase; 
     }

     h1.page-title { 
       text-align: center;
       color: peru; 
       /* brown colours: 
          siena,maroon,peru,goldenrod,chocolate,
          burlywood */
          
     }
     /* tan: a light brown */
     h1 { color: lightslategray; }
     /* make these headings capital case */
     h2 { 
       text-transform: capitalize; 
       color: lightslategray;
     }
     h3 { 
       text-transform: capitalize; 
       color: lightslategray; 
     }
     
     h3.blog-index-title { color: chocolate; }

     /* the date that is at the top of each blog post */
     h3.blog-post-date { color: darkkhaki; }
     
     div.footer { 
       text-align: center;
       color: goldenrod; 
       width: 100%;
       /* brown colours: 
          siena,maroon,peru,goldenrod,chocolate,
          burlywood */
     }

     /* a list of blog posts */
     dl.blog-index {
       margin-left: 2em;
     }

     /* a list of documents in a folder */
     dl.doc-index {
       margin-left: 2em;
     }
 
     /* a list within a list */
     ul.sublist {
       list-style-type: none;
     }
 
     /* an abbreviation like html, ast, xml */ 
     abbr.tek-acronym {
       border-bottom: 1px dashed purple; 
       text-decoration: none;
       text-transform: uppercase;
       /* font-style: italic; */
       font-size: 0.8em;
       *color: purple;
     }

     /* a one line description of a document  */
     em.doc-description {
       margin-left: 2em;
       color: lightslategray;
     }

     /* this is for pretty printing nom code. But I need lots 
        of span tags in the code. I copied this from the wren.io
        inspect element code snippet. <code> wrapped in <pre>
        in the html there is lots of 
          <span class="punctuation">.</span> etc
          and in the css .punctuation { color: #999; }

        Normal text is black/grey

        the pre has background color #f5f2f0 which is an offwhite
        here are the colours: 
          punctuation: #999 (grey)
          function eg 'print': #DD4A68 (red)
          string: #690 (green)
          keyword: #07A (aqua)
          operator eg '=' : #9a6e3a (brown)
        */

     /* start of pretty print css */

     pre.nom-code { 
       background-color: #f5f2f0;
       border-radius: 10px;
     }

     code.language-nom {
       font-family: Consolas, Monaco, monospace;
       text-align: left;
       white-space: pre;
       word-spacing: normal;
       word-break: normal;
       word-wrap: normal;
       line-height: 1.5;
     }

     span.nom-command { color: #9a6e3a;  /* brown */ }
     /* displaying unknown commands */
     span.nom-unknown { color: orange; }
     span.nom-error { color: red; } 
     span.nom-word { color: #09C; }
     span.nom-keyword { color: #07A; }
     span.nom-string { color: #690; }
     span.nom-class { color: #2A0; }
     span.nom-punct { color: #AAA; }
     span.nom-comment { color: gray; }
     
     /* end of pretty print css */

     /* displaying commands */
     code.nom-command {
       font-family: Consolas, Monaco, monospace;
       font-size: 0.9em;
     }

     /* This is used for file names as well */
     code {
       font-family: Consolas, Monaco, monospace;
       font-size: 0.9em;
     }

     /* used for parse tokens in documents (text ending in *) */
     code.nom-token { 
       color: gray;
       font-size: 0.9em;
       font-style: italic;
     }

     /* a single line of code */
     pre.codeline { 
       margin-left:2em; 
       padding:0; 
     }

     figcaption.code-caption { 
       color: white;
       /* background-color: lightslategray; */
       background-color: #DD8811; 
       border-radius: 4px;
       padding-left: 1em; padding-bottom: 4px; padding-top: 4px;
       font-weight: normal; 
       width: 90% 
       /* border-bottom: 1px solid lightgrey; */
     }

     /* a centred element or image */
     .center {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width: 50%;
     }

     /* an element which floats to the left */
     .float-left {
       float: left; 
       /*width: 10%; */
       text-align: center;
       font-style: italic;
       font-size: smaller;
       text-indent: 0;
       border-none;
       /* border: thin silver solid; */
       margin: 0.5em;
       padding: 0.5em;
     }

     /* an element which floats to the right */
    .float-right {
      float: right; 
      /*width: 10%; */
      text-align: center;
      font-style: italic;
      font-size: smaller;
      text-indent: 0;
      border: none;
      /* border: thin silver solid; */
      margin: 0.5em;
      margin-right: 3em;
      padding: 0.5em;
    }

    img.image-right {
      width: 100px;
    }
    img.image-left {
      width: 100px;
    }

    .chess-piece {
      /* background-color:#fff; */
      border:1px solid black;    
      border-radius:50%;
      font-size: 1.5em;
      padding: 5px;
    }

    /* this is for the big curly quotes before a <blockquote> quotation 
       html is <blockquote>text<cite>person</cite></blockquote> */
    blockquote.quotation {
      font-family: Georgia, serif;
      font-size: 18px;
      font-style: italic;
      width: 500px;
      margin: 0.25em 0;
      padding: 0.35em 40px;
      line-height: 1.45;
      position: relative;
      color: #383838;
    }

    blockquote.quotation:before {
      display: block;
      padding-left: 10px;
      content: "\201C";
      font-size: 80px;
      position: absolute;
      left: -20px;
      top: -20px;
      color: #7a7a7a;
    }

    blockquote.quotation cite {
      color: #999999;
      font-size: 14px;
      display: block;
      margin-top: 5px;
    }

    blockquote.quotation cite:before {
      content: "\2014 \2009";
    }
   </style></head>
   <body>

    


<p>
<!-- ------------ page title -------------------- -->
<h1 class='page-title'> Pep & Nom</h1>

<a href='http://www.nomlang.org/'>home </a> |
<a href='/doc/'>documentation </a> |
<a href='/eg/'>examples </a> |
<a href='/tr/'>translators </a> |
<a href='/download/'>download </a> |
<a href='/doc/pepnom.doc.journal.html'>journal </a> |
<a href='/post/index.html'>blog </a> |
<a href='/post/posts.html'>all blog posts </a> 
<img style='border-radius:50%;width:10em;' class='float-right'  title='/image/black.white/bw.biro.doodle.jpg' src='/image/black.white/bw.biro.doodle.jpg'/>



<p>


<blockquote class="quotation">
   Everything comes to its end at exactly the right moment,
   including us.
 
<cite>Saying </cite>
</blockquote>
<p>

<p>
<p>

<!-- doclist= -->
<!-- doc=./doc/pepnom.doc.journal.txt -->
<!-- ------------------------------- -->
<h2> a work journal about the pep/nom system</h2>

<p>
 A journal of work carried out on <em>pep</em> and nom.
<p>
 Here I make notes about work I am carrying out on the 
<abbr class='tek-acronym' 
      title='Parsing Engine for Patterns'>PEP</abbr> and 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> system.
 (September 2019 seems to be the date that I finally had a decent
 implementation in 'c'). This file shows a long litany of programming work
 carried out, a lot of it in Colombia probably because time goes slower in
 that country.
<p>
 Comments, suggestions and contributions to <em>mjb at nomlang.org</em>
<p>
 This document serves as a catch-all for 'to do' lists and lists of 
 ideas to implement.
<p>
<!-- ------------------------------- -->
<h3> 26 oct 2025</h3>

 <p>
 I have been working on a language phrase tutor in dart/flutter and 
 haven&apos;t done any more work on <em>pep</em> or nom. I did have the idea to 
 create a <em>nom</em> script to generate flutter apps. This would be a parsing 
 experiment where the input would be a json-like format (maybe with
 less quotation marks). The output would be a set of dart screens 
 each reflecting an object in the input format:
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 an example of the input format for the nom to flutter script
 </figcaption>
<pre class='codeblock'>

    screen.user-details {
      text: "Please enter your details below",
      textbox: ....
    }
  </pre>
</figure>
<p>
 But this is pretty similar to the flutter format any way.
<p>
<!-- ------------------------------- -->
<h3> 13 oct 2025</h3>

 <p>
 I haven&apos;t been working on the <em>nom</em> system but have been working on the 
 &ldquo;four apps&rdquo; in Dart and Flutter that I mentioned elsewhere. I will probably
 use <em>nom</em> parsers and renderers in those apps after translating them to 
 dart.
<p>
 My work on <em>nom</em> is currently stopped at the stage of creating the AI 
 code translation script which was only just begun. It would be handy to 
 create new <em>nom</em> translation scripts like those at <a href='http://www.nomlang.org/tr/'>www.nomlang.org/tr/</a> 
 Also, I would like to add the machine diagrams to the website. The 
 <a href='/eg/machine.tohtml.pss'><code>/eg/machine.tohtml.pss</code></a> script I think is reasonably good but it has to
 be integrated into <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> (using the same techniques as is 
 used for code listings).
<p>
 Also I would like to create a latex equivalent of <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> 
 so that I can actually create a printable book of some of the <em>nom</em> 
 documentation. I feel like if I am able to do that I will feel like I 
 have really &ldquo;achieved&rdquo; something with <em class='pep-and-nom'>Pep & Nom</em> . Also I could send the 
 books to people.
<p>
<!-- ------------------------------- -->
<h3> 28 sept 2025</h3>

<p>
 I have been having a mini-break from the nomlang system. But the 
 major tasks that I would like to finish are the AI translation helper
 script, which I have started by can&apos;t remember what I called it.
 The idea was just to allow easy AI (gemini etc) translations of the 
 translation scripts in <a href='/tr/'><code>/tr/</code></a> so that many other translation languages
 can be added to nomlang.
<p>
 Other important tasks for the advancement of <em>nom</em> and pep.
<p>
 <!---- list ----->
<ul>

<li> add machine diagrams to the documentation with 
 <a href='/eg/machine.tohtml.pss'><code>/eg/machine.tohtml.pss</code></a> 
 </li>
<li> make the <em>nom</em> → latex translator
 </li>
<li> make a <em>nom</em> book and print it off.
</li>
</ul>
<!-- ------------------------------- -->
<h3> 1 sept 2025</h3>

<p>
 Idea: A <em>nom</em> self-test script for example
 <pre class='nom-code'><code class='language-nom'>

    <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"abc"</span> <span class='nom-punct'>!</span><span class='nom-string'>"abc"</span> <span class='nom-punct'>{</span> <span class='nom-punct'>.</span><span class='nom-punct'>.</span><span class='nom-punct'>.</span><span class='nom-unknown'>error</span> <span class='nom-punct'>}</span>
    <span class='nom-command'>unescape</span> <span class='nom-string'>"a"</span><span class='nom-punct'>;</span> <span class='nom-punct'>!</span><span class='nom-string'>"abc"</span> <span class='nom-punct'>{</span> <span class='nom-unknown'>error</span> <span class='nom-punct'>}</span>
    <span class='nom-comment'># and so on.</span>
  </code></pre>

<p>
 This is called <a href='/eg/self.test.nom.pss'><code>/eg/self.test.nom.pss</code></a> at the moment and is in a very 
 incipient phase. It has the weakness that the script needs to assume 
 that some syntax or commands do initially work (such as <code class='nom-command'><a title='nom command reference: print' href='http://nomlang.org/doc/commands/nom.print.html'>print</a></code>
 and tests and <a title='nom syntax reference: block' href='http://nomlang.org/doc/syntax/nom.syntax.block.html'>block</a> s etc)
<p>
 Idea: a translation template that can be fed into an AI engine to 
 generate new <em>nom</em> translators. This would be based on the lua/perl
 or dart code, or which ever is the currently best translation script.
 And it would allow the automatic generation of the new translation
 script.
<p>
 This translation template consists of 2 parts: the code that needs 
 to be translated, including the <em>pep</em> machine class and methods and the 
 main() method with command line switches. This code also includes the 
 snippets that implement the commands such as <code class='nom-command'><a title='nom command reference: add' href='http://nomlang.org/doc/commands/nom.add.html'>add</a></code> Above each 
 snipped will be a special comment line, that will allow a <em>nom</em> script
 or bash script to extract that snippet from the (AI) translated code 
 and insert it into the template. This first file is the code that will
 be translated by an AI engine and the code will be based on a good 
 existing translation script (eg perl or dart).
<p>
 The second part is the template itself which contains place-holders for
 the snippets and the machine class and methods. Then we require some 
 script or code to combine the two parts to create the translated translator.
 The second part could just be a <em>nom</em> script but it would have to rely on
 the order of the snippets.
<p>
 Or I could rely on the <code class='nom-command'><a title='nom command reference: system' href='http://nomlang.org/doc/commands/nom.system.html'>system</a></code> command to insert the found translated
 snippets into the template file 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 how to parse the translated code with nom
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

    <span class='nom-comment'># read line by line or word by word</span>
    <span class='nom-comment'># the snippet file will have the format</span>
    <span class='nom-comment'>#   (comment syntax in target language) add-snippet:</span>
    <span class='nom-comment'>#   (code to add to workspace in target language) eg: this.work += '; get; </span>
    <span class='nom-comment'># so the previous line indicates what is coming next</span>
    <span class='nom-comment'># Tokens: line* lines* nl* snipname*</span>
    <span class='nom-word'>parse</span><span class='nom-punct'>></span>
      <span class='nom-command'>pop</span><span class='nom-punct'>;</span> <span class='nom-command'>pop</span><span class='nom-punct'>;</span>
      <span class='nom-string'>"line*line*"</span><span class='nom-punct'>,</span><span class='nom-string'>"lines*line*"</span> <span class='nom-punct'>{</span>
        <span class='nom-comment'># maybe add the nom <code class='nom-command'>add</code> command and quotes here ?</span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"lines*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
      <span class='nom-punct'>}</span>

      <span class='nom-string'>"nl*text*word*"</span><span class='nom-punct'>,</span><span class='nom-string'>"nl*word*word*"</span> <span class='nom-punct'>{</span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span>
        <span class='nom-string'>"snippet:"</span> <span class='nom-punct'>{</span>
          <span class='nom-command'>replace</span> <span class='nom-string'>"-snippet:"</span> <span class='nom-string'>""</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
          <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"snipname*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span> 
        <span class='nom-punct'>}</span>
      <span class='nom-punct'>}</span>
      <span class='nom-comment'># maybe need a lookahead token? so that we know when to call</span>
      <span class='nom-comment'># the system command to insert into the template file - </span>
      <span class='nom-comment'># or build the 'sed' command now ?</span>
      <span class='nom-punct'>B</span><span class='nom-string'>"snipname*line"</span><span class='nom-punct'>.</span><span class='nom-punct'>!</span><span class='nom-string'>"snipname*line*"</span><span class='nom-punct'>.</span><span class='nom-punct'>!</span><span class='nom-string'>"snipname*lines*"</span> <span class='nom-punct'>{</span>
        <span class='nom-command'>replace</span> <span class='nom-string'>"snipname*lines*"</span> <span class='nom-string'>""</span><span class='nom-punct'>;</span>  
        <span class='nom-command'>replace</span> <span class='nom-string'>"snipname*line*"</span> <span class='nom-string'>""</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span>
        <span class='nom-command'>--</span><span class='nom-punct'>;</span> 
        <span class='nom-command'>add</span> <span class='nom-string'>"sed -i 's/'"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"-snippet:/
        ++;
        # build a sed inline replace here? or build the new translator
        # I think build the new translator here in this script is better.
        # but the snippets need to appear in the correct order...
        # transfer the unknown token attrib here ...
      }
  </code></pre>
</figure>
<p>
 Made an inline interpret switch for the <code>nom.toperl.pss</code> translator.
<p>
<!-- ------------------------------- -->
<h3> 31 august 2025</h3>

<p>
 Made the interpret() method of <a href='/eg/nom.toperl.pss'><code>/eg/nom.toperl.pss</code></a> work, with 
 minimal testing. It is hard to believe that it works but it does.
<p>
 The important tasks for <em>pep</em> and <em>nom</em> seem to me to be: todo!
 <!---- list ----->
<ul>

<li> add self script interpretation to <a href='/eg/nom.tolua.pss'><code>/eg/nom.tolua.pss</code></a> as well as 
 the self help system. 
 </li>
<li> debug the perl translation of <a href='/eg/palindrome.pss'><code>/eg/palindrome.pss</code></a>
 </li>
<li> write a resetMachine() method for <a href='/eg/nom.toperl.pss'><code>/eg/nom.toperl.pss</code></a> and also the 
 other scripting languages, because it is handy for running in 
 interpreter mode. (done for nom.toperl.pss)
 </li>
<li> fix the segmentation fault bugs in the <em>pep</em> interpreter (done?)
 </li>
<li> rewrite the <em>nom</em> compiler <a href='/compile.pss'><code>/compile.pss</code></a> so that it uses the new 
 grammar and script organisation from the more recent translation 
 scripts.
 </li>
<li> write a better download script and a better way to update the 
 downloadable files
 </li>
<li> fix the old translators - or update them
 </li>
<li> add better self-help, self-translation and self-testing to the 
 <em>nom</em> translation scripts.
 </li>
<li> fix class illegal escape chars in the translators
 </li>
<li> write a text to latex translator
 </li>
<li> update and rewrite the <a href='/eg/toybnf.pss'><code>/eg/toybnf.pss</code></a> script so that it can 
 lex as well as parse
 </li>
<li> write a <code>tr/nom.toforth.pss</code> translator to translate <em>nom</em> scripts
 into the forth language (with DIY memory management).
 </li>
<li> write translators for zig, julia, R.
 </li>
<li> write an example type-checker, initially with no scope and 
 just a limited number of variables. This could form the basis
 of a more comprehensive and realistic type-checker which is an
 important hurdle for <em>nom</em> to be 'taken seriously' in the field of 
 programming language construction (or compiler construction).
 </li>
<li> revise the meaning of [:blank:] in <em>pep</em> and the translation scripts.
 This should mean any white-space character except the &ldquo;\\n&rdquo; newline
 character?. No, I think it is only space and tab. 
 This may be it&rsquo;s most useful definition because it allows
 easy line-by-line parsing. I think &ldquo;\\r&rdquo; can be safely ignored. 
</li>
</ul>
 This maybe a pathway to &ldquo;finishing&rdquo; my work on pep/nom, or at least getting
 to the stage where I feel that this system could be presented at a conference
 with some level of confidence. None of these tasks seems greatly
 insurmountable, but rewriting the older translation scripts (such as java,
 tcl, c, ruby, python) is a time-consuming task, even with the help of a LLM
 translator such as google gemini.
<p>
<!-- ------------------------------- -->
<h3> 30 august 2025</h3>

<p>
 Looking at the interpret() method in the <a href='/eg/nom.toperl.pss'><code>/eg/nom.toperl.pss</code></a> <em>nom</em> → perl
 translation script. Fixed a small bug in the input switches.
 <p>
 Probably would be good to add the help system to the translation scripts,
 which could also be used to create 2<sup class='ordinal'>nd</sup> Generation scripts with a help word
 like /gen2. This would create the parser parser, and maybe run the input
 script. This system could use the <a href='/eg/nom.to.pss'><code>/eg/nom.to.pss</code></a> script to generate the
 translator with itself.
<p>
<!-- ------------------------------- -->
<h3> done </h3>

<p>
 <!---- list ----->
<ul>

<li> made the interpret() method work in <a href='/tr/nom.toperl.pss'><code>/tr/nom.toperl.pss</code></a> This is 
 pretty remarkable.
 </li>
<li> changed the <code class='nom-command'><a title='nom command reference: quit' href='http://nomlang.org/doc/commands/nom.quit.html'>quit</a></code> command to return the number in the accumulator
 as the exit code. This allows scripts to act as pure 'recognisers' for 
 patterns and formal languages, meaning that they only return zero if 
 the input is a valid <em>sentence</em> in the given language, or a non-zero
 value, if not.
 </li>
<li> seemed to have fixed the <code class='nom-command'><a title='nom command reference: restart' href='http://nomlang.org/doc/commands/nom.restart.html'>.restart</a></code> and .reparse bug in <a title='nom syntax reference: begin' href='http://nomlang.org/doc/syntax/nom.syntax.begin.html'>begin</a>
 blocks for the perl translator.
 </li>
<li> added the <em>system</em> command to the <em>pep</em> interpreter. Need to add to the 
 translation scripts.
 </li>
<li> implemented <code class='nom-command'><a title='nom command reference: system' href='http://nomlang.org/doc/commands/nom.system.html'>system</a></code> command ...
</li>
</ul>
<!-- ------------------------------- -->
<h3> 29 august 2025</h3>

<p>
 Working on segmentation faults and memory leaks in the <em>pep</em> interpreter.
 The 'until' code in the interpreter is bad, but that may not be the 
 only problem. I may have fixed the <code class='nom-command'><a title='nom command reference: until' href='http://nomlang.org/doc/commands/nom.until.html'>until</a></code> code and <code class='nom-command'><a title='nom command reference: untiltape' href='http://nomlang.org/doc/commands/nom.untiltape.html'>untiltape</a></code>
 code but valgrind still complains about unitialised value at line 560
 in <a href='/object/machine.interp.c'><code>/object/machine.interp.c</code></a> in the strcmp() function. I think this is 
 because for some reason the instruction ii-&gt;a.text parameter is not 
 valid.
<p>
<!-- ------------------------------- -->
<h3> 26 august 2025</h3>

<p>
 Added the accumulator as an exit code for the <code class='nom-command'><a title='nom command reference: quit' href='http://nomlang.org/doc/commands/nom.quit.html'>quit</a></code> command to 
 the <em>pep</em> interpreter. Desultory testing.
<p>
<!-- ------------------------------- -->
<h3> 22 august 2025</h3>

<p>
 Working on <a href='/eg/machine.tohtml.pss'><code>/eg/machine.tohtml.pss</code></a> which is supposed to create a nice
 visual (html) representation of the <em>pep</em> machine, tape and (compiled)
 program listing.
<p>
 I am not sure of the point of this massive ongoing coding effort, but 
 the system still seems potentially revolutionary. 
<p>
<!-- ------------------------------- -->
<h3> 13 august 2025</h3>

<p>
 Did lots of interesting work on <a href='/eg/timeline.tohtml.pss'><code>/eg/timeline.tohtml.pss</code></a> Added self-testing
 and translation and reformed the grammar.
<p>
 The token reduction technique in <a href='/eg/timeline.tohtml.pss'><code>/eg/timeline.tohtml.pss</code></a> is really 
 quite amazingly good. It gets rid of, or 'evaporates' component parse
 tokens when they are out of context, meaning that they don&rsquo;t form
 part of the larger pattern. This technique is much more flexible and
 succinct than previous methods I have used, and will become a 
 standard parsing technique.
<p>
 It also means that there is no reason not to add lots of new parse tokens
 (eg for punctuation) because it is easy to get rid of them when they
 are not longer wanted.
<p>
 Started to add the self-help, self-translate and self-test to the 
 script <a href='/eg/grammar.en.pss'><code>/eg/grammar.en.pss</code></a> which is an adaptation of <a href='/eg/natural.language.pss'><code>/eg/natural.language.pss</code></a>
<p>
 Also, improved the self-testing in <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> but I am starting to
 get lots of segmentation faults when I add to this script (which is now
 pretty big). These are thrown by the <em>pep</em> interpreter (which is written
 in plain 'c' so that is probably not surprising). I need to hunt down
 what is happening.
<p>
 I tried to make file links appear as &lt;code&gt; style. So <a href='/eg/index.txt'><code>/eg/index.txt</code></a> should
 look use a code font and so should <a href='/tr/index.txt'><code>/tr/index.txt</code></a> 
 <p>
<!-- ------------------------------- -->
<h3> 11 august 2025</h3>

<p>
 Also adding all the selfs to <a href='/eg/maths.parse.pss'><code>/eg/maths.parse.pss</code></a> and it all seems to 
 work nicely, including creating and opening a pdf from a random 
 test input with the help word <a href='/test.line.pdf'><code>/test.line.pdf</code></a>
<p>
 Added self-translation, self-testing, and self-help to the old script
 <a href='/eg/json.check.pss'><code>/eg/json.check.pss</code></a> It seems to be working well and is now probably the 
 model to copy for adding this to other scripts. With a simple phrase like
<p>
 <pre class='codeline'>
 pep -f json.check.pss -i /toall 
</pre>

<p>
 We can translate this script to all the available <em>nom</em> translation languages
 (eg [nom:tr.links] ) But that is not all! We can also reformat to 
 latex/pdf/html with <em>pep -f json.check.pss -i /topdf etc</em> This is possible 
 because of the script <a href='/eg/nom.to.pss'><code>/eg/nom.to.pss</code></a> and because of the different translation
 scripts and formatting scripts in the <a href='/tr/'><code>/tr/</code></a> and <a href='/eg/'><code>/eg/</code></a> folders.
<p>
<!-- ------------------------------- -->
<h3> 10 august 2025</h3>

<p>
 working on the 'all' method for the script <a href='/eg/nom.to.pss'><code>/eg/nom.to.pss</code></a> which translates
 a <em>nom</em> script to all languages for which there is a translator. It 
 appears to be working.
<p>
<!-- ------------------------------- -->
<h3> 9 august 2025</h3>

<p>
 Some ideas for the system: 
 <!---- list ----->
<ul>

<li> <code class='nom-command'><a title='nom command reference: until' href='http://nomlang.org/doc/commands/nom.until.html'>until</a></code> with multiple end delimiters
 </li>
<li> a horizontal list format using css for succinct lists 
 </li>
<li> change the <em>nom</em> home page to &ldquo;what is nom?&rdquo; and &ldquo;what can nom do?
&rdquo; </li>
<li> change example script.
 </li>
</ul>
 <p>
<!-- ------------------------------- -->
<h3> 4 august 2025</h3>

<p>
<p>
 wrote the script <a href='/eg/tocfoot.tohtml.pss'><code>/eg/tocfoot.tohtml.pss</code></a> which demonstrates adding a 
 table-of-contents and a footnote list to a document using markers such
 as [toc] and [foot]. The script is a variant of <a href='/eg/toc.tohtml.pss'><code>/eg/toc.tohtml.pss</code></a> but 
 is much better because the index lists can be placed anyway in the 
 document with the markers, and they can also be repeated. The script 
 uses the same technique of building the lists in <code class='nom-command'><a title='nom command reference: mark' href='http://nomlang.org/doc/commands/nom.mark.html'>mark</a></code> ed taped cells
 at the top of the <a title='nom syntax reference: tape' href='http://nomlang.org/doc/machine/pep.tape.html'>tape</a> . 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 example to detect ## starting a line
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

    read;
    "</span><span class='nom-comment'>#" { </span>
      <span class='nom-command'>while</span> <span class='nom-class'>[#]</span><span class='nom-punct'>;</span> <span class='nom-punct'>B</span><span class='nom-string'>"##"</span> <span class='nom-punct'>{</span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>pop</span><span class='nom-punct'>;</span> <span class='nom-string'>"nl*"</span> <span class='nom-punct'>{</span>
          <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-command'>until</span> <span class='nom-string'>"\n"</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> 
          <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"heading*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
        <span class='nom-punct'>}</span>
        <span class='nom-comment'># '##' doesnt start the line, so its just a normal word.</span>
        <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-command'>whilenot</span> <span class='nom-class'>[:space:]</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"word*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
      <span class='nom-punct'>}</span>
    <span class='nom-punct'>}</span>
  </code></pre>
</figure>
<p>
 The <em>pep</em> interpreter still throws the occasional segmentation fault
 when adding stuff to the <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> file I wonder if that has 
 to do with program size limits? Because that script is pretty big 
 now.
 <p>
<!-- ------------------------------- -->
<h3> 3 august 2025</h3>

<p>
 I wrote the script <a href='/eg/nom.to.pss'><code>/eg/nom.to.pss</code></a> based on the code in 
 <a href='/eg/xml.parse.pss'><code>/eg/xml.parse.pss</code></a> . I could also make this a testing script as well
 using the existing code. This script responds to very simple sentences
 like 'translate <code>eg.pss</code> to ruby' or 'to ruby eg.pss'
<p>
 The advantage of having this script, is that I can now include it in 
 the help system of all other scripts in order to provide 'self-translation'
<p>
 Thinking about the etymologies idea for the text to html formatter, but I
 would like to style the pop up to display the etymologies in 2 columns.
<p>
 Ideas and things to do.
 <!---- list ----->
<ul>

<li> add multiple end delimiters for <code class='nom-command'><a title='nom command reference: until' href='http://nomlang.org/doc/commands/nom.until.html'>until</a></code> 
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 example
 </figcaption>
<pre class='codeline'>
 until ")","\n";
</pre>
</figure>
 This is useful when the end delimiter of a pattern is more 
 that one character. The <code class='nom-command'><a title='nom command reference: while' href='http://nomlang.org/doc/commands/nom.while.html'>while</a></code> command can do that but 
 then you have to <code class='nom-command'><a title='nom command reference: read' href='http://nomlang.org/doc/commands/nom.read.html'>read</a></code> the extra character and consume it.
 This introduces problems with <em>reading</em> on EOF (which will 
 exit silently and cause considerable head-scratching when you 
 are trying to debug).
 </li>
<li> write the <code class='nom-command'><a title='nom command reference: system' href='http://nomlang.org/doc/commands/nom.system.html'>system</a></code> command. This needs to be put into the 
 <em>pep</em> interpreter and all the translators
 </li>
<li> fix the perl translator <a href='/tr/nom.toperl.pss'><code>/tr/nom.toperl.pss</code></a> so that it can become
 an interpreter and then use that code as a model for ruby, python
 etc.
 </li>
</ul>
<!-- ------------------------------- -->
<h3> 2 august 2025</h3>

 <p>
 Added a ligature for æ words like æroplane or gynæcology.
 archæology,and julius cæsar.
<p>
 Experimenting with substituting ligatures for character sequences in 
 <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> not for any practical purpose I can think of.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 bandjalang words with the ng character
 </figcaption>
<pre class='codeblock'>

    "yolngu" "yolŋu" this is a phonetic spelling for the australian 
      language which is used in some texts..and Bandjalang.
    yuŋga - to go, to walk
    jaŋga - to sing
    muŋga - to sleep
    ŋuŋgi - to sit
    ŋali - we (dual, including the person being spoken to)
    ŋa:wih - a long way
    ŋari - a person, a man
    ŋami - a mother
 </pre>
</figure>
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 some greek etymologies
 </figcaption>
<pre class='codeblock'>

    Academy" "Ακαδημία"
   "Acoustics" "Ακουστική"
   "Acrobat" "Ακροβάτης"
   "Alphabet" "Αλφάβητο"
   "Angel" "Άγγελος"
   "Atmosphere" "Ατμόσφαιρα"
   "Catastrophe" "Καταστροφή"
   "Chaos" "Χάος"
   "Climate" "Κλίμα"
   "Cosmos" "Κόσμος"
   "Democracy" "Δημοκρατία"
   "Ecstasy" "Έκσταση"
   "Economy" "Οικονομία"
   "Genesis" "Γένεση"
   "Horizon" "Ορίζοντας"
   "Myth" "Μύθος"
   "Planet" "Πλανήτης"
   "Rhythm" "Ρυθμός"
   "Sphere" "Σφαίρα"
   "Telephone" "Τηλέφωνο"
 </pre>
</figure>
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 umlaut or diaresis words in English
 </figcaption>
<pre class='codeblock'>

  "cooperate" "coöperate"
  "naivete" "naïveté"
  "reelect" "reëlect"
  "aerie" "aërie"
  "Noel" "Noël"
  "Chloe" "Chloë"
  "Zoe" "Zoë"
  "Moeller" "Moëller"
  "Curacao" "Curaçao"

  Umlaut (in borrowed German words):
  "uber" "über"
  "doppelganger" "doppelgänger"
  "fuhrer" "Führer"
  "gemutlichkeit" "Gemütlichkeit"
  "schadenfreude" "Schadenfreude"

  </pre>
</figure>
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 ligature words for text.tohtml.pss
 </figcaption>
<pre class='codeblock'>

    ﬁ (f + i)
    ﬀ (f + f):

    unusual spellings
    "fairy" "faerie"
    "fairy" "færie"
    "eon" "æon"
    "aetiology" "ætiology"
    "encyclopaedia" "encyclopædia"
    "archaeology" "archæology"
    "mediaeval" "mediæval"
    "primaeval" "primæval"
    "caesura" "cæsura"
    "Caesarean" "Cæsarean"
    "anaemia" "anæmia"
    # just the base of the word
    "anaemi" "anæmi"
    "faec" "fæc"
    "faec" "fæc"
    "diaeresis" "diæresis"
    "diaresis" "diæresis"
    "dieresis" "diæresis"
    "leucaemia" "leucæmia"
    "paediatrics" "pædiatrics"
    "orthopaedic" "orthopædic"

    œ Ligature Words:

    "foetus" "fœtus"
    "foetid" "fœtid"
    "fetid" "fœtid"
    "gynaecology" "gynæcology"
    "homoeopathy" "homœopathy"
    "oesophagus" "œsophagus"
    # just the root of the word
    "oesophag" "œsophag"
    "Oedipus" "Œdipus"
    "diarrhoea" "diarrhœa"
    "oeconomics" "œconomics"
    "manoeuvre" "manœuvre"
    "phoenix" "phœnix"
    "amoeba" "amœba"

  </pre>
</figure>
<p>
 ideas:
 <!---- list ----->
<ul>

<li> style the title attribute <em>tool-tips</em> for etymologies and cognate
 words. Greek, latin, arabic, indonesian, spanish, portuguese.
 </li>
<li> these etymologies could be got from an external text file with 
 the <code class='nom-command'><a title='nom command reference: system' href='http://nomlang.org/doc/commands/nom.system.html'>system</a></code> command (1 aug 2025: not implemented).
 </li>
<li> what ligatures can be used in English words, and what unusual
 spellings.
 </li>
<li> make a &ldquo;drop-cap&rdquo; function for <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> so that the 
 pattern &lt;P&gt; at the start of a line will be converted to a 
 drop capital (within the paragraph text).
 </li>
<li> an example script showing footnotes and table of contents, and 
 showing how to include one or more [TOC] and [FOOT] markers in the 
 source text.
 </li>
<li> make <em>pep</em> -I output the machine state with program to a text file
 in the same way as now, but with no colours. This can be used as 
 input for the generated booklet about <em class='pep-and-nom'>Pep & Nom</em>
 </li>
<li> write <a href='/eg/machine.tohtml.pss'><code>/eg/machine.tohtml.pss</code></a> which converts a plain text 
 representation of the pep,nom machine (with a part program list)
 into html, or postscript or latex etc or EPUB.
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 pep parsing with the xml.parse.pss script 
 </figcaption>
<pre class='codeblock'>
 
        Partial Program Listing (size:1390 ip:106 cap:20000)
        103: testclass [class:alnum]
        104: jumpfalse [int:7]
        105:     while [class:alnum]
        106&gt;       put
        107:     clear
        108:       add [text:name*]
       --------- Machine State -----------
       (Buff:16/39 +r:0) Stack[starttag*&lt;/*] Work[book] Peep[&gt;]
       Acc:0 Flag:TRUE Esc:\ Delim:* Chars:12 Lines:1
       --------- Tape --------------------
       Tape Size: 500
          4/10 )  0  [book]
          4/10 )  1  [book]
          0/10 )  2&gt; []
          0/10 )  3  []
      </pre>
</figure>
</li>
</ul>
 <strong><em>Ideas for a [TOC] and [FOOT] script</em></strong>
 : This script would be a 
 development of <a href='/eg/toc.tohtml.pss'><code>/eg/toc.tohtml.pss</code></a> which creates an html table of 
 contents from a plain text document. The script would be called 
 <a href='/eg/tocfoot.tohtml.pss'><code>/eg/tocfoot.tohtml.pss</code></a> and would allow the inclusion of one or more
 [TOC] and [FOOT] markers in the source text. These markers would be converted 
 to a table of contents and a list of footnotes respectively.
 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 Here is a sketch of the script
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

     <span class='nom-comment'># name and reserve 2 cells at the top of the tape for </span>
     <span class='nom-comment'># the table of contents and footnote list.</span>
     <span class='nom-keyword'>begin</span> <span class='nom-punct'>{</span> <span class='nom-command'>mark</span> <span class='nom-string'>"toc"</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>mark</span> <span class='nom-string'>"foot"</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-punct'>}</span>
     <span class='nom-command'>whilenot</span> <span class='nom-class'>[:space:]</span><span class='nom-punct'>;</span> 
     <span class='nom-punct'>!</span><span class='nom-string'>""</span> <span class='nom-punct'>{</span> 
       <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>lower</span><span class='nom-punct'>;</span>
       <span class='nom-string'>"[toc]"</span> <span class='nom-punct'>{</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"toc*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span> <span class='nom-punct'>}</span>
       <span class='nom-string'>"[foot]"</span> <span class='nom-punct'>{</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"foot*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span> <span class='nom-punct'>}</span>
       <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"word*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
     <span class='nom-punct'>}</span>
     <span class='nom-comment'># .... here actually build the toc with headings and the </span>
     <span class='nom-comment'># .... foot with footnotes.</span>
     <span class='nom-command'>while</span> <span class='nom-class'>[:space:]</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> 
     <span class='nom-word'>parse</span><span class='nom-punct'>></span>
     <span class='nom-command'>pop</span><span class='nom-punct'>;</span> <span class='nom-command'>pop</span><span class='nom-punct'>;</span>
     <span class='nom-string'>"word*word*"</span><span class='nom-punct'>,</span><span class='nom-string'>"text*word*"</span> <span class='nom-punct'>{</span>
       <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>" "</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
       <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"text*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-command'>reparse</span>
     <span class='nom-punct'>}</span>
     <span class='nom-comment'># this code should allow multiple table-of-contents in one</span>
     <span class='nom-comment'># document.</span>
     <span class='nom-punct'>(</span><span class='nom-word'>eof</span><span class='nom-punct'>)</span> <span class='nom-punct'>{</span>
       <span class='nom-string'>"text*toc*"</span> <span class='nom-punct'>{</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>mark</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"toc"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"text*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
       <span class='nom-punct'>}</span>
       <span class='nom-string'>"toc*text*"</span> <span class='nom-punct'>{</span> 
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>mark</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"toc"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"text*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
       <span class='nom-punct'>}</span>
       <span class='nom-string'>"text*foot*"</span> <span class='nom-punct'>{</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>mark</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"foot"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"text*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
       <span class='nom-punct'>}</span>
       <span class='nom-string'>"foot*text*"</span> <span class='nom-punct'>{</span> 
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>mark</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"foot"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"text*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
       <span class='nom-punct'>}</span>
       <span class='nom-string'>"foot*toc*"</span> <span class='nom-punct'>{</span> 
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>mark</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"foot"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"toc"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"text*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
       <span class='nom-punct'>}</span>
       <span class='nom-string'>"toc*foot*"</span> <span class='nom-punct'>{</span> 
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>mark</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"toc"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"foot"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>go</span> <span class='nom-string'>"here"</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
         <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"text*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
       <span class='nom-punct'>}</span>
     <span class='nom-punct'>}</span>
     <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span>
   </code></pre>
</figure>
<p>
<p>
<!-- ------------------------------- -->
<h3> 1 august 2025</h3>

<p>
 Working on <a href='/eg/timeline.tohtml.pss'><code>/eg/timeline.tohtml.pss</code></a> which seems to work without any
 huge amount of testing. It can also test itself with:
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 test the timeline script
 </figcaption>
<pre class='codeline'>
 pep -f timeline.tohtml.pss -i /test | bash
</pre>
</figure>
<p>
 But this script doesn&apos;t have any self-translation facilities (unlike
 the <code>xml.parse.pss</code> script). I wrote a separate script that 
 translates scripts to different languages (based on the code in 
 <a href='/eg/xml.parse.pss'><code>/eg/xml.parse.pss</code></a> ) and then calls that from within the script help-words
 This is called <a href='/eg/script.translation.pss'><code>/eg/script.translation.pss</code></a>
<p>
<!-- ------------------------------- -->
<h3> 31 july 2025</h3>

<p>
 script ideas
<p>
 <!---- list ----->
<ul>

<li> the machine.todiagram script for displaying the machine state
 with a program
 </li>
<li> timeline for formatting a timeline: <a href='/eg/timeline.tohtml.pss'><code>/eg/timeline.tohtml.pss</code></a>
 </li>
<li> index.parser for showing how to parse a table of contents or
 index This is called <a href='/eg/toc.pss'><code>/eg/toc.pss</code></a> and seems to work. 
</li>
</ul>
 Also, I wrote <a href='/eg/toc.tohtml.pss'><code>/eg/toc.tohtml.pss</code></a> which converts a list of headings
 into a html table of contents with links. This is somewhat useful and 
 it contradicts what I have assumed for a few years: That if I use
 the 1<sup class='ordinal'>st</sup> few cells of the tape as a kind of buffer array for saving 
 values, then the normal script operation will interfer with, or 
 overwrite those cells.
<p>
 But this, I think, <em>isnt true</em> because basically, the <code class='nom-command'><a title='nom command reference: pop' href='http://nomlang.org/doc/commands/nom.pop.html'>pop</a></code> and 
 <code class='nom-command'><a title='nom command reference: push' href='http://nomlang.org/doc/commands/nom.push.html'>push</a></code> commands are designed to do nothing on an empty <a title='nom syntax reference: stack' href='http://nomlang.org/doc/machine/pep.stack.html'>stack</a>
 and an empty <a title='nom syntax reference: workspace' href='http://nomlang.org/doc/machine/pep.workspace.html'>workspace</a> buffer respectively. This is important in
 the context of writing a <em>type-checking</em> parser, where the parser
 is trying to verify that a variable is being assigned the correct
 type of variable for example
 <pre class='codeline'>
 x = "hello";
</pre>

 Now if 'x' has been defined as an integer, our language may wish to 
 complain bitterly about trying to sausage-in a piece of text (string)
 into our 32/64 (whatever) bit piece of memory. 
<p>
 The key to this, when using <em class='pep-and-nom'>Pep & Nom</em> as a parser, is maybe to save the type of
 each variable in the top tape cells. However there are some significant
 additional problems: <em>scope</em> (which maybe doable with some kind of dot
 notation) and also the fact we have no idea how many variables need to be
 checked (unless we do 2 passes) and therefore don't know how many tape-cells
 to allocate for this purpose. 
<p>
<!-- ------------------------------- -->
<h3> 28 july 2025</h3>

<p>
 the /to&lt;lang&gt; word seems to work for rust/dart/go/java and compiles, and 
 the translated script can be tested with /testone&lt;lang&gt;. Also with
 lua/ruby.
<p>
 I have been working on the /testone &lt;lang&gt; help word in the 
 <a href='/eg/xml.parse.pss'><code>/eg/xml.parse.pss</code></a> (limited) xml recogniser. This word, combined with
 the /to &lt;lang&gt; help word (which translates the script to another language)
 tests the script, or a translation of the script with some sample xml
 input. The system seems very useful and transferable to other scripts.
 It is probably even worth-while extracting it to a separate <em>nom</em> script
 which I will call something like <a href='/eg/discuss.nom.pss'><code>/eg/discuss.nom.pss</code></a>
<p>
 The <code>discuss.nom.pss</code> script is supposed to be a &ldquo;Tiny Language Model
&rdquo; (a TLM) which can receive phrases like 
 <p>
 <!---- list ----->
<ul>

<li> 'translate the file <code>xml.parse.pss</code> into ruby' 
 </li>
<li> 'translate that to python'
 </li>
<li> 'test the translation'
 </li>
<li> 'test it'
</li>
</ul>
 (Actually the script <a href='/eg/nom.to.pss'><code>/eg/nom.to.pss</code></a> can do this but not 
 with the 'it' words, at least not yet)
 <p>
 So, the TLM, powered by <em class='pep-and-nom'>Pep & Nom</em> will accept simple English sentences
 and parse them into actions or queries. Words like 'it' 'that' 'this'
 require some <em>state</em> to be saved and this will be done by <em>nom</em> using 
 the <code class='nom-command'><a title='nom command reference: system' href='http://nomlang.org/doc/commands/nom.system.html'>system</a></code> command (or maybe read!) which will execute a system
 command and read the result of the command into the workspace.
<p>
<!-- ------------------------------- -->
<h3> 27 july 2025</h3>

 <p>
 Fixed a couple of bugs in <a href='/eg/xml.parse.pss'><code>/eg/xml.parse.pss</code></a>
<p>
 I seem to have fixed the &ldquo;.reparse with begin block&rdquo; bug. But only for the
 lua and rust translators. Now I have to fix it for the other translators.
 My help system in the scripts often uses a .reparse within a begin block to
 trigger the help system when an empty document is found, or an invalid first
 character.
<p>
<!-- ------------------------------- -->
<h3> 26 july 2025</h3>

<p>
 Discovered that the <code class='nom-command'><a title='nom command reference: reparse' href='http://nomlang.org/doc/commands/nom.reparse.html'>.reparse</a></code> command does not work within the begin
 blocks for some translators. This is because .reparse either
 uses a goto or a break; or continue; command. The break; command won&apos;t work
 because the begin {} block is completely separate to the lex and parse
 blocks.
<p>
<!-- ------------------------------- -->
<h3> 25 july 2025</h3>

<p>
 found bugs in <a href='/tr/nom.tolua.pss'><code>/tr/nom.tolua.pss</code></a> and <a href='/tr/nom.torust.pss'><code>/tr/nom.torust.pss</code></a> when translating
 <a href='/eg/xml.parse.pss'><code>/eg/xml.parse.pss</code></a> and <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> This was caused by 
 the <code class='nom-command'><a title='nom command reference: restart' href='http://nomlang.org/doc/commands/nom.restart.html'>.restart</a></code> and <code class='nom-command'><a title='nom command reference: reparse' href='http://nomlang.org/doc/commands/nom.reparse.html'>.reparse</a></code> commands in a <a title='nom syntax reference: begin' href='http://nomlang.org/doc/syntax/nom.syntax.begin.html'>begin</a> block
<p>
 Scripts could also test themselves.
<p>
<!-- ------------------------------- -->
<h3> 24 july 2025</h3>

<p>
 done:
 <!---- list ----->
<ul>

<li> <a href='/eg/nom.to.pss'><code>/eg/nom.to.pss</code></a> a <em>nom</em> script that accepts instructions like 
 &ldquo;translate file.pss to ruby&rdquo; and will carry out the instruction or 
 else just print out the necessary commands.
 </li>
<li> <a href='/eg/timeline.tohtml.pss'><code>/eg/timeline.tohtml.pss</code></a> the same but for an historical timeline.(done)
 </li>
<li> not much.
</li>
</ul>
 Some ideas: 
 <!---- list ----->
<ul>

<li> read! or <code class='nom-command'><a title='nom command reference: system' href='http://nomlang.org/doc/commands/nom.system.html'>system</a></code> command which is a new command that reads a 
 shell process into the workspace. (not implemented)
 </li>
<li> a 'BB' and 'EE' test: test if the workspace ends with or start with 
 the current <a title='nom syntax reference: tape' href='http://nomlang.org/doc/machine/pep.tape.html'>tape</a> cell.
 </li>
<li> self translation: in the help system in any script (implemented by the 
 <em><code class='nom-token'>help*</code></em> token) it is possible to put a /to&lt;lang&gt; help word that will 
 translate the current script into another language. (DONE)
 </li>
<li> <code>faq.pss</code> translate a simple FAQ text format into html
 </li>
<li> <code>text.toman.pss</code> create a man page for a document
 </li>
<li> /toprint helpword to create a printable version of the script.
</li>
</ul>
 I made some progress adding self translation to the <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a>
 This seems very promising and could be added to any significant script.
<p>
 I seem to have abandoned the ideas and todo files of this documentation and
 will probably just put everything here.
<p>
<!-- ------------------------------- -->
<h3> 23 july 2025</h3>

<p>
 Added the beginnings of a help system to <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> 
 Had the idea of a TLM a &ldquo;Tiny Language Model&rdquo; , which is just a 
 <em>nom</em> script which parses simple commands and then possibly executes
 it. Also, a &ldquo;random&rdquo; command, which selects a random section of text
 between 2 delimiters.
<p>
<!-- ------------------------------- -->
<h3> 22 july 2025</h3>

<p>
 I like the idea of implementing help/error tokens in even simple
 scripts. These help systems can also be triggered by keywords at the 
 start of the 'document', possibly wrapped in comment syntax for the 
 output language. I will try to add such a help system to 
 <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a>
<p>
<!-- ------------------------------- -->
<h3> 21 july 2025</h3>

<p>
 Added some ideas to the <a href='/eg/natural.language.pss'><code>/eg/natural.language.pss</code></a> script and also
 add an example phrase grammar to the comment section. 
 <p>
 I had the idea that a simple natural language parser could be used to
 generate frequently used bash commands such as &ldquo;reducing the size of an&rdquo; image", &ldquo;making an image black and white&rdquo; , and so forth. But this would
 probably have to be combined with some repl loop written in dart/rust/ruby or
 anything else to actually execute the commands. So the <em>nom</em> script would 
 parse the input and generate the bash command or commands, and then the 
 script written in ruby would actually execute the commands. The ruby 
 script could also handle reference words like &ldquo;that&rdquo; or &ldquo;this&rdquo; which would 
 refer to filenames that have previously been mentioned. This requires
 remembering state in a way that would be difficult, if not impossible in 
 pep/nom.
 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 some example commands
 </figcaption>
<pre class='codeblock'>

     choose an image to edit
     choose image
     show it's dimensions
     show dimensions
     shrink it by half. Shrink by 50% 
     make this black and white.
   </pre>
</figure>
<p>
 This idea came from a simpler one: given a command like &ldquo;translate to ruby
&rdquo; a <em>nom</em> script will generate the bash commands necessary to translate a 
 <em>nom</em> script into the ruby language. From there is seems an easy step to 
 actually execute the commands...
<p>
<!-- ------------------------------- -->
<h3> 20 july 2025</h3>

<p>
 revised the <a href='/eg/flyer.typewriter.tohtml.pss'><code>/eg/flyer.typewriter.tohtml.pss</code></a> script to include an
 <em><code class='nom-token'>error*</code></em> and <em><code class='nom-token'>help*</code></em> token. Thought about presenting the idea of <em class='pep-and-nom'>Pep & Nom</em>
 at some language conference. O'reilly's &ldquo;Emerging Languages&rdquo; Conference
 would have been ideal (even though <em>nom</em> is not emerging anywhere) but 
 that conference is no longer. 
<p>
<!-- ------------------------------- -->
<h3> 18 july 2025</h3>

<p>
 I wrote a simple letter-to-html formatting script called
 <a href='/eg/letter.typewriter.tohtml.pss'><code>/eg/letter.typewriter.tohtml.pss</code></a> which may be interesting because it 
 includes it&rsquo;s own help system with documentation. This seems a nice 
 way for the script to be &ldquo;self-documenting&rdquo;.

<p>
<!-- ------------------------------- -->
<h3> 13 july 2025</h3>

<p>
 I haven&apos;t been doing any work on the <a title='nom syntax reference: nom' href='http://nomlang.org/doc/machine/pep.nom.html'>nom</a> system except to write a 
 somewhat dodgy script at <a href='/eg/script.tag.pss'><code>/eg/script.tag.pss</code></a> which is supposed to remove 
 html &lt;script&gt; tags from an html document. It could be described (charitably)
 as &ldquo;naive&rdquo;.
 Also, it alerted me to the problem of trying to use 
 the <code class='nom-command'><a title='nom command reference: until' href='http://nomlang.org/doc/commands/nom.until.html'>until</a></code> command in a case-insensitive manner: i.e. it is not 
 possible and makes the <em>until</em> command not very useful for case 
 insensitive language patterns.
<p>
 I have been looking again at Dart/Flutter with the idea to create a kind of
 &ldquo;sociedad&rdquo; in the spanish sense of the word. Or a &ldquo;company&rdquo; of Colombian
 programmers for the creation of apps. 2 app ideas that seem useful to me
 are: A language learning app with an emphasis on listening to phrases and
 only viewing the transcription and translation occasionally. So the app would
 be &ldquo;audio-biased&rdquo; and would implement several of my ideas for language
 learning. The other app idea is &ldquo;LocalPaper&rdquo; which is a kind of simple-ish
 blog and writing app which would allow the creation of a local paper or
 newsheet. This would include the usual sort of blog or writing functions but
 also a way to produce a printable (pdf/ps) newsheet that could be put in
 local cafes. The newsheet could contain local events, local education
 courses, local classifieds and some news and articles. The local paper could
 also be published to the web, if desired so the rendering engine would
 support html and pdf/ps/LaTeX
<p>
 I like these ideas. The local paper app could include a compiled 
 <a title='nom syntax reference: nom' href='http://nomlang.org/doc/machine/pep.nom.html'>nom</a> script which would render to html and pdf/ps (via latex 
 possibly).
<p>
<!-- ------------------------------- -->
<h3> 15 june 2025</h3>

<p>
 NOTE: I abandoned the 'flag' register idea, because I can just use 
 a <code class='nom-command'><a title='nom command reference: mark' href='http://nomlang.org/doc/commands/nom.mark.html'>mark</a></code> ed tape cell as the 'flag' and then access it with
 <code class='nom-command'><a title='nom command reference: mark' href='http://nomlang.org/doc/commands/nom.mark.html'>mark</a></code> 'here'; <code class='nom-command'><a title='nom command reference: go' href='http://nomlang.org/doc/commands/nom.go.html'>go</a></code> 'flag'; <code class='nom-command'><a title='nom command reference: get' href='http://nomlang.org/doc/commands/nom.get.html'>get</a></code> ; <code class='nom-command'><a title='nom command reference: go' href='http://nomlang.org/doc/commands/nom.go.html'>go</a></code> 'here' ; 
 etc etc. This works fine in <a href='/eg/toc.tohtml.pss'><code>/eg/toc.tohtml.pss</code></a> and in fact I don't 
 know why I thought it wasn&apos;t going to work. The top <a title='nom syntax reference: tape' href='http://nomlang.org/doc/machine/pep.tape.html'>tape</a> cell is 
 protected from being overwritten after <code class='nom-command'><a title='nom command reference: pop' href='http://nomlang.org/doc/commands/nom.pop.html'>pop</a></code> by the design of 
 the <em>pop</em> command.
<p>
 it would be nice for <code>text.tohtml.pss</code> to be able to include a float
 right map, or map-tile image. I could use the same format as for 
 images but the image would be an OSM map.
<p>
 <strong><em>NO gave up this idea, see above</em></strong>

<p>
 Also, I think a &ldquo;flag&rdquo; register would be good, which could be 
 used for states like &ldquo;in.comment&rdquo; etc. It could work like this
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 example flag register use
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

    <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"in.comment"</span><span class='nom-punct'>;</span> <span class='nom-unknown'>flag</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span>
    <span class='nom-comment'># now check the text in the flag register</span>
    <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-unknown'>tell</span><span class='nom-punct'>;</span> <span class='nom-string'>"in.comment"</span> <span class='nom-punct'>{</span>
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> 
      <span class='nom-comment'># do parsing specific to comment blocks</span>
    <span class='nom-punct'>}</span>
  </code></pre>
</figure>
<p>
 At the moment I use the accumulator register with the <code class='nom-command'><a title='nom command reference: zero' href='http://nomlang.org/doc/commands/nom.zero.html'>zero</a></code>
 etc commands. But the accumulator was really designed for 
 counting stuff, not keeping track of parsing state.
<p>
<!-- ------------------------------- -->
<h3> 14 june 2025</h3>

<p>
 I think I will try to read some compiler books to give me some 
 context for my work on pep/nom: Here is the list from 
 Bob Nystrom's twitter post
<p>
 <!---- list ----->
<ul>

<li> The Art of the Metaobject protocol: Gregor Kiczales et al
 </li>
<li> Structure and Interpretation of Computer Programs: 
 Harold Abelson and Gerald Jay Sussman
 </li>
<li> The Ruby Programming Language: Flanagan and Matsumoto
 </li>
<li> The Design and Evolution of C++: Stroustrup
 </li>
<li> Build your own Lisp: Holden
 </li>
<li> Algorithms + Data Structures = Programs: Wirth
 </li>
<li> Compilers: Aho et al
 </li>
<li> Writing an Interpreter in Go: Thorsten Ball
 </li>
<li> Writing Compilers and Interpreters: Ronald Mak
 </li>
<li> Lisp in Small Pieces: Queinecc
 </li>
<li> Programming Language Pragramatics: Scott
 </li>
<li> Engineering a Compiler: Cooper and Torczon
 </li>
<li> Types and Programming Languages: Pierce
 </li>
<li> the Garbage Collection Handbook: Jones, Hosking et al.
</li>
</ul>
<!-- ------------------------------- -->
<h3> 25 may 2025</h3>

<p>
 Just started working on the <em>nom</em> ↦ zig translator. I used an automatic
 translation from google gemini to translate the rust machine struct and
 methods into zig. I am not sure how accurate it will be. Zig could be 
 a quite big learning curve because all memory is explicitly allocated
 and deallocated. I still haven&apos;t fixed the interpret() method in 
 the <em>nom</em> ==&gt; perl compiler but will get round to it at some stage. 
 The Ruby and Python translators could also have an interpret() method
 because, apparently, they can both execute a string as code.
<p>
<!-- ------------------------------- -->
<h3> 21 may 2025</h3>

<p>
 fixed the escape and unescape methods in <a href='/tr/nom.tolua.pss'><code>/tr/nom.tolua.pss</code></a> <a href='/tr/nom.torust.pss'><code>/tr/nom.torust.pss</code></a>
 and <a href='/tr/nom.toperl.pss'><code>/tr/nom.toperl.pss</code></a> so that the escape character is escaped properly.
 Also, in <a href='/object/machine.interp.c'><code>/object/machine.interp.c</code></a> and <a href='/object/machine.methods.c'><code>/object/machine.methods.c</code></a>
<p>
<!-- ------------------------------- -->
<h3> 20 may 2025</h3>

<p>
 rewrote the escapeChar() method in the perl translator to fix a 
 bug where the escape character (by default \\) was not being escaped
 properly. This code needs to go into all the translators and 
 the interpreter and also probably into unescapeChar method.
<p>
<!-- ------------------------------- -->
<h3> 18 may 2025</h3>

<p>
 All first generation tests in the perl translator are now working.
 But this script probably just works on code points not grapheme 
 clusters using utf8
<p>
<!-- ------------------------------- -->
<h3> 17 may 2025</h3>

<p>
 working on the perl translator <a href='/tr/dev.nom.toperl.pss'><code>/tr/dev.nom.toperl.pss</code></a> or <a href='/tr/nom.toperl.pss'><code>/tr/nom.toperl.pss</code></a>
 which is based on the rust one.
<p>
<!-- ------------------------------- -->
<h3> 12 may 2025</h3>

<p>
 The rust translator is now working well with first and second generation
 tests all working as well as being able to translate big scripts 
 in the <a href='/eg/'>example </a> folder. The translator is still a unicode 
 <em>code-point</em> translator (not grapheme clusters) so that is a limitation,
 but converting to grapheme clusters is not a big job using a rust
 crate (external library).
 <p>
 I am always surprised when second generation tests actually work, but
 they do, and it always seems remarkable.
<p>
 Also, I discovered that the google gemini AI engine can actually 
 translate the <em>pep</em> machine very well into other languages if it is 
 given a good script to work with (eg the rust translator) and I will
 use it to speed up the work of translating to other languages like 
 perl, haskell, swift, R, julia, and lisp.
<p>
<!-- ------------------------------- -->
<h3> 4 may 2025</h3>

<p>
 Working on the rust translator <a href='/tr/nom.torust.pss'><code>/tr/nom.torust.pss</code></a> I am writing it as a
 unicode code-point parser. If I get it working well I will write another
 version for unicode grapheme clusters. The rust version has taken a bit more
 time because the compiler is strict and there is lots of &ldquo;illegal borrowing
&rdquo; marlarkey. 
<p>
<!-- ------------------------------- -->
<h3> 2 may 2025</h3>

<p>
 Adding some utf8 support to the <a href='/tr/nom.tolua.pss'><code>/tr/nom.tolua.pss</code></a> translator.
 Also, the <a href='https://www.lua.org/manual/5.1/manual.html#7.1'>lua reference manual </a>
 has a complete ebnf syntax for the language which may be interesting
 for me to try to implement in nom.
<p>
<!-- ------------------------------- -->
<h3> 1 may 2025</h3>

<p>
 Some debugging of the lua translation script which seems to be 
 working quite well.
<p>
<!-- ------------------------------- -->
<h3> 30 april 2025</h3>

 <p>
 <a href='/tr/nom.tolua.pss'><code>/tr/nom.tolua.pss</code></a> is working for tests in <a href='/tr/translate.test.txt'><code>/tr/translate.test.txt</code></a>
<p>
<!-- ------------------------------- -->
<h3> 27 april 2025</h3>

<p>
 <!---- list ----->
<ul>

<li> Added links to translation script documents (but not all) in 
 &ldquo;[nom:translation.links]&rdquo; in the <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> script
 which should render like this 
       <a href='/tr/nom.torust.pss' 
          title='nom to rust translation script'>rust</a> |
       <a href='/tr/nom.todart.pss' 
          title='nom to dart translation script'>dart</a> |
       <a href='/tr/nom.toperl.pss' 
          title='nom to perl translation script'>perl</a> |
       <a href='/tr/nom.tolua.pss' 
          title='nom to lua translation script'>lua</a> |
       <a href='/tr/translate.go.pss' 
          title='nom to go translation script'>go</a> |
       <a href='/tr/nom.tojava.doc.html' 
          title='nom to java translation script'>java</a> |
       <a href='/tr/translate.js.pss' 
          title='nom to javascript translation script'>javascript</a> |
       <a href='/tr/translate.ruby.pss' 
          title='nom to ruby translation script'>ruby</a> |
       <a href='/tr/translate.python.pss' 
          title='nom to python translation script'>python</a> |
       <a href='/tr/translate.tcl.pss' 
          title='nom to python translation script'>tcl</a> |
       <a href='/tr/translate.c.pss' 
          title='nom to c translation script'>c</a>
        
 </li>
<li> read about the LLVM system and considered using it as a 
 target for <em>nom</em> scripts. I should at least try to compile the 
 c code with <strong><em>clang</em></strong>
 so that it is compatible with LLVM
 </li>
</ul>
<!-- ------------------------------- -->
<h3> 26 april 2025</h3>

<p>
 Wrote <a href='/eg/text.snippet.tohtml.pss'><code>/eg/text.snippet.tohtml.pss</code></a> which can work with <a href='/eg/nom.tohtml.pss'><code>/eg/nom.tohtml.pss</code></a>
 to render a <em>nom</em> script into html with the doc header rendered as a 
 document in the same format as these pages. also wrote a bash
 function which assembles this into a page, which is in the 
 <code>blog.sh</code> script 
<p>
 I just realised that a simple way to ensure there are at least 
 2 parse tokens in the workspace is:
 <pre class='codeline'>
 E"*word*",E"*text*" {...}
</pre>

<p>
 The leading &ldquo;*&rdquo; in the ends-with test means that there must be 
 at least 2 tokens.
<p>
<!-- ------------------------------- -->
<h3> 24 april 2025</h3>

<p>
 Doing some work on the documents in <a href='/doc/'><code>/doc/</code></a> Added the &ldquo;echar&rdquo; command
 to the machine, but not tested and not added to <a href='https://bumble.sf.net/books/pars/asm.pp'>bumble.sf.net/books/pars/asm.pp</a> 
 (but has been added to <a href='https://bumble.sf.net/books/pars/compile.pss'>bumble.sf.net/books/pars/compile.pss</a> ). Fixed very minor 
 issues in <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> with quotes and emphasised text.
<p>
 need to check the <code class='nom-command'><a title='nom command reference: stack' href='http://nomlang.org/doc/commands/nom.stack.html'>stack</a></code> and <code class='nom-command'><a title='nom command reference: unstack' href='http://nomlang.org/doc/commands/nom.unstack.html'>unstack</a></code> commands in the 
 file <a href='/object/machine.interp.c'><code>/object/machine.interp.c</code></a> to make sure that they update the 
 tape pointer. 
<p>
<!-- ------------------------------- -->
<h3> 20 april 2025</h3>

 <p>
 I have been editing some documents in the <a href='/doc/'><code>/doc/</code></a> folder and created
 a system for including random quotes at the beginning of each page.
 This uses the <a href='/eg/quotes.tolua.html.pss'><code>/eg/quotes.tolua.html.pss</code></a> which extracts all the 
 quotes from <a href='/doc/misc.quotes.txt'><code>/doc/misc.quotes.txt</code></a> and creates a lua &ldquo;table&rdquo; (associative
 array) and a short lua script to get one random quote from the 
 array. The blog.rq function in <a href='/webdev/copy.blog.sh'><code>/webdev/copy.blog.sh</code></a> will make this 
 lua script from the quote file. 
<p>
 This is a pretty convoluted way to achieve this, but it seems to 
 work.
<p>
<!-- ------------------------------- -->
<h3> 16 april 2025</h3>

<p>
 The lua translator is getting better but I have some difficulties
 with how to read or consume the input-stream/file/string etc. 
 I have been splitting files into lines but it is probably better 
 just to read the whole file into a variable and then read the
 input buffer 'character' by 'character'. One problem is that there 
 is no such thing as a character, at least in the view of unicode.
 A unicode character can consist of a sequence of codepoints which
 is a base character or glyph combined with 'combining marks' (diacritics
 emoji characters etc).
<p>
<!-- ------------------------------- -->
<h3> 14 april 2025</h3>

<p>
 The script <a href='/eg/brainfork.c.pss'><code>/eg/brainfork.c.pss</code></a> seems to be working well with 
 multiple commands reduced to one with parsing techniques and 
 using the accumulator register. 'Brainfork' is my name for the 
 brainf**k esoteric language.
<p>
<!-- ------------------------------- -->
<h3> 13 april 2025</h3>

<p>
 May have finally fixed the escape/unescape bug in
 <a href='https://bumble.sf.net/books/pars/object/machine.interp.c'>bumble.sf.net/books/pars/object/machine.interp.c</a> where a character was escaped by the
 <code class='nom-command'><a title='nom command reference: escape' href='http://nomlang.org/doc/commands/nom.escape.html'>escape</a></code> command even when it was already escaped. Also, updated in
 <a href='https://bumble.sf.net/books/pars/object/machine.methods.c'>bumble.sf.net/books/pars/object/machine.methods.c</a> but not tested. Also added mark; and go;
 syntax to <code>machine.interp.c</code> without testing need to add the same to
 <code>machine.methods.c</code>
<p>
<!-- ------------------------------- -->
<h3> 12 april 2025</h3>

<p>
 having another look at <a href='/eg/brainfork.c.pss'><code>/eg/brainfork.c.pss</code></a> which is an experiment in
 reducing multiple brainfork commands to one. Eg <em>+++----</em>
 can become <em>-</em> or <em>&gt;&gt;&gt;&gt;&lt;&lt;</em> can become <em>&gt;&gt;</em> . This is a simple 
 optimisation in the code production phase of the <em>nom</em> script.
 I use list tokens to do this but it complicates the script grammar
 because you have to lookahead to see what the next token is.
<p>
<!-- ------------------------------- -->
<h3> 11 april 2025</h3>

 <p>
 still working on the lua translator, simple scripts working. 
 Decided I need a 'reserve' command for the machine which will reserve
 a section at the top of the <a title='nom syntax reference: tape' href='http://nomlang.org/doc/machine/pep.tape.html'>tape</a> array for use as a kind
 of symbol table. Type checking, scope, type inference etc seems to 
 be the last big hurdle that <em>nom</em> has in order to be a fully fledged
 compiler compiler or parser parser.
<p>
<!-- ------------------------------- -->
<h3> 9 april 2025</h3>

<p>
 Starting to work on the <em>nom</em> ↦ lua translator . I built and installed
 lua from source which was easy and fast. At the moment the 
 dart translator seems to work well, but still has a bug with the 
 output when parsing a string. Some dart StringBuffer issue.
<p>
<!-- ------------------------------- -->
<h3> 5 april 2025</h3>

<p>
 All first generation tests are working with <a href='/eg/nom.todart.pss'><code>/eg/nom.todart.pss</code></a> 
 from stdin input. I would like to allow file and string input and 
 output as well, to make the script useable from within other 
 dart code. I will start to work on <a href='/eg/dev.nom.torust.pss'><code>/eg/dev.nom.torust.pss</code></a> at least 
 to try to get something to compile.
<p>
<!-- ------------------------------- -->
<h3> 2 april 2025</h3>

 <p>
 Working on the dart translator <code>nom.todart.pss</code> or <code>dev.nom.todart.pss</code>
 Adding unicode categories,scripts, blocks to RegExp matching 
 with <code class='nom-command'><a title='nom command reference: while' href='http://nomlang.org/doc/commands/nom.while.html'>while</a></code> <code class='nom-command'><a title='nom command reference: whilenot' href='http://nomlang.org/doc/commands/nom.whilenot.html'>whilenot</a></code> and class tests 
 eg: [:Greek:] will match greek letters. Dart seems to support all 
 categories, scripts etc. But do they clash?
<p>
<!-- ------------------------------- -->
<h3> 31 mar 2025</h3>

<p>
 Have been struggling with getting some rust code to compile in
 the <a href='/eg/nom.torust.pss'><code>/eg/nom.torust.pss</code></a> Will probably have to comment out a lot of 
 things.
<p>
<p>
<!-- ------------------------------- -->
<h3> 29 mar 2025</h3>

<p>
 Doing work on the rust translator <a href='/tr/nom.torust.pss'><code>/tr/nom.torust.pss</code></a>
<p>
<!-- ------------------------------- -->
<h3> 28 mar 2025</h3>

<p>
 Looking again at the remarkable work of <a href='https://bellard.org'>fabrice bellard </a>
 and his refreshingly simple html. Life is too short for html and css. But
 I do it anyway.
<p>
 Had the idea that <em>nom</em> could also be used for binary files. Matching 
 binary patterns it also useful. For example UTF8 text.
<p>
 Also, I need to rethink the whole approach to Unicode and grapheme
 clusters, which are sets of Unicode code points that amalgamate to
 form one visible character (eg certain letters with accents). 
 This is a tricky issue. <em>Nom</em> should normally <code class='nom-command'><a title='nom command reference: read' href='http://nomlang.org/doc/commands/nom.read.html'>read</a></code> one cluster at 
 a time, <em>not</em> one Unicode code point at a time. But there may be 
 rare cases where we want to get one Unicode char at a time.
<p>
 So the default behaviour of <code class='nom-command'><a title='nom command reference: read' href='http://nomlang.org/doc/commands/nom.read.html'>read</a></code> should be read one cluster
 like the dart characters api. But there could be a variant <code class='nom-command'>read</code> command 
 that reads one Unicode character (Rune?) and also maybe 
 one byte char. The byte-<code class='nom-command'>read</code> command could be used for parsing
 binary files....
<p>
 Have been reading about PEG parsing expression grammars which seems
 to be what <em>nom</em> is good at parsing, with some caveats.
 Playing with more formats in <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> eg N<sup style='text-decoration:underline; text-decoration-thickness:2px; font-style:bold; vertical-align:0.30em;'>o</sup> 123
 and maybe horizontal bar-charts. which could just go in lists.But 
 you probably need a table to line up the starts of the bars.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 example bar-chart format
 </figcaption>
<pre class='codeblock'>

    - [bar:nom:42/100:%]
    - [bar:lua:12/100:%]
    - [bar:wren:54/100:%]
  </pre>
</figure>
<p>
 The % is a unit name and the 42/100 is a bar width. This number 
 should be printed inside the bar at the end. &ldquo;nom&rdquo; lua etc are 
 the labels printed before the bar. Need to calculate width in 
 <em>em</em> or <em>ex</em> as below. But percent is relative to container.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 css calc expressions
 </figcaption>
<pre class='codeblock'>

    /* calc(expression) */
    calc(100% - 80px)

    /* Expression with a CSS function */
    calc(100px * sin(pi / 2))

    /* Expression containing a variable */
    calc(var(--hue) + 180)

    /* Expression with color channels in relative colors */
    lch(from aquamarine l c calc(h + 180))
  </pre>
</figure>
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 example html for a barchar from wren.io
 </figcaption>
<pre class='codeblock'>

    &lt;table class="chart"&gt;
      &lt;tr&gt;
        &lt;th&gt;wren&lt;/th&gt;&lt;td&gt;
        &lt;div class="chart-bar wren" style="width: 14%;"&gt;0.12s&nbsp;&lt;/div&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;luajit (-joff)&lt;/th&gt;&lt;td&gt;
        &lt;div class="chart-bar" style="width: 18%;"&gt;0.16s&nbsp;&lt;/div&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;ruby&lt;/th&gt;&lt;td&gt;
        &lt;div class="chart-bar" style="width: 23%;"&gt;0.20s&nbsp;&lt;/div&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;python3&lt;/th&gt;&lt;td&gt;
        &lt;div class="chart-bar" style="width: 91%;"&gt;0.78s&nbsp;&lt;/div&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
   </pre>
</figure>
<p>
<!-- ------------------------------- -->
<h3> 27 mar 2025</h3>

<p>
 still working on the <a href='/eg/nom.todart.pss'><code>/eg/nom.todart.pss</code></a> which is now working with
 about 3 commands and &lt;stdin&gt; Added N<sup style='text-decoration:underline; text-decoration-thickness:2px; font-style:bold; vertical-align:0.30em;'>o</sup> abbrevation to text.tohtml
 <p>
<!-- ------------------------------- -->
<h3> 21 mar 2025</h3>

 <p>
 The script <a href='/eg/nom.tolatex.pss'><code>/eg/nom.tolatex.pss</code></a> is now working more or less ok. 
 The colours are not great, but that is easy to change. I invented
 a new and interesting parsing technique for escaping special 
<abbr class='tek-acronym' 
      title='The LaTeX text processing system'>L<sup><small>A</small></sup>T<sub>E</sub>X</abbr>
 characters and styling each component of a 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> script.
<p>
 Added some abbreviations to vim about translation to go, and 
 also a shortcut in <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a> for links to translation scripts 
 like this 
       <a href='/tr/nom.torust.pss' 
          title='nom to rust translation script'>rust</a> |
       <a href='/tr/nom.todart.pss' 
          title='nom to dart translation script'>dart</a> |
       <a href='/tr/nom.toperl.pss' 
          title='nom to perl translation script'>perl</a> |
       <a href='/tr/nom.tolua.pss' 
          title='nom to lua translation script'>lua</a> |
       <a href='/tr/translate.go.pss' 
          title='nom to go translation script'>go</a> |
       <a href='/tr/nom.tojava.doc.html' 
          title='nom to java translation script'>java</a> |
       <a href='/tr/translate.js.pss' 
          title='nom to javascript translation script'>javascript</a> |
       <a href='/tr/translate.ruby.pss' 
          title='nom to ruby translation script'>ruby</a> |
       <a href='/tr/translate.python.pss' 
          title='nom to python translation script'>python</a> |
       <a href='/tr/translate.tcl.pss' 
          title='nom to python translation script'>tcl</a> |
       <a href='/tr/translate.c.pss' 
          title='nom to c translation script'>c</a>
        and also a list 
 like this [nom:translation.list]
<p>
<!-- ------------------------------- -->
<h3> 20 mar 2025</h3>

<p>
 working on the <a href='/eg/nom.tolatex.pss'><code>/eg/nom.tolatex.pss</code></a> script which has proved tricky
 because I couldn&apos;t use the listing package nor the minted package
 for code listings so I had to write my own formatter. which seems to
 be working.
<p>
 The script <a href='/eg/nom.tolatex.notunicode.pss'><code>/eg/nom.tolatex.notunicode.pss</code></a> does print nice 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr>
 code listings but can&apos;t handle any unicode characters in the 
 source, which is silly.
<p>
<!-- ------------------------------- -->
<h3> 19 mar 2025</h3>

<p>
 Finished the script <a href='/eg/nom.tohtml.pss'><code>/eg/nom.tohtml.pss</code></a> which prints colourised 
 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> in 
<abbr class='tek-acronym' 
      title='Hyper-text Markup Language'>HTML</abbr> using &lt;span&gt; tags. Also wrote <a href='/eg/nom.snippet.tohtml.pss'><code>/eg/nom.snippet.tohtml.pss</code></a>
 which only pretty prints withing &lt;code class='nom-lang'&gt; tags.
 This allows it to work with <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a>
<p>
 I reformatted most of the documentation with the new pretty printed
 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> example code. Also just plain file names that start with 
 <em>/</em> get linked in html now. Also made a new codeblock syntax
 starting with ---+ and ending ,,, which is specifically for <em>nom</em> 
 code.
<p>
<!-- ------------------------------- -->
<h3> 18 mar 2025</h3>

<p>
 Added unordered lists to <code>eg/text.tohtml.pss</code> . The parsing was sort of 
 bizarre because there is no start token for an unordered list in my
 quirky plain-text document <a href='/eg/text.tohtml.format.html'>format </a> 
 Lists are just started with a list-item indicator which is a dash word
 '-' which starts a line. Lists are terminated with a blank line or 
 the end of the document, so I reduce the lists in reverse: that is,
 when I find the end of the list I add an <em><code class='nom-token'>endlist*</code></em> token and then
 reduce all the <em><code class='nom-token'>item*text*endlist*</code></em> sequences and keep <a title='nom command reference: reparse' href='http://nomlang.org/doc/commands/nom.reparse.html'>reparsing
 </a> until there are none left. 
<p>
 I was sort of surprised that it works, but it seems to.
<p>
 <!---- list ----->
<ul>

<li> More things to do with lists:
 </li>
<li> Add a definition list. I think that I can live without 
 <em>ordered</em> lists, but def lists are pretty handy.
 </li>
<li> Test the list rendering code in <a href='/eg/text.tohtml.pss'><code>/eg/text.tohtml.pss</code></a>
 </li>
<li> Try to find bugs in the renderer, like test empty items
 </li>
<li> use the lists to make documents nicer and clearer,
 not just for no reason.
 </li>
<li> Add a <em>caption</em> element to the list so that there is a 
 kind of &ldquo;heading&rdquo;.
 But this might required some kind of start
 token. 
 </li>
<li> Or I could let the <em><code class='nom-token'>list*</code></em> token live for a bit longer and 
 parse <em>starline*list</em> sequences, just like I do for block
 quotations.
</li>
</ul>
<!-- ------------------------------- -->
<h3> 17 mar 2025</h3>

<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 image format reminder, width 4 is 20em ie n*5em
 </figcaption>
<pre class='codeline'>
 &lt;:0:4:&gt;&gt;:/image/name.gif&gt; or &lt;name.gif&gt;
</pre>
</figure>
<p>
 Added <em><code class='nom-token'>equationset*</code></em> token to <code>maths.tolatex.pss</code> This script is producing 
 really nice output from simple ascii arithmetic expressions (Unicode
 symbolic expressions should work when the 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> script is translated
 to go or 
<abbr class='tek-acronym' 
      title='Java Programming Language'>JAVA</abbr> etc. add more 
<abbr class='tek-acronym' 
      title='The LaTeX text processing system'>L<sup><small>A</small></sup>T<sub>E</sub>X</abbr> symbols like greek letters.
 Still don&rsquo;t have derivative and partial derivative symbols.
 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 An example of using eg/maths.tolatex.pss with the quadratic equation
 </figcaption>
<pre class='codeblock'>

   pep -f eg/maths.tolatex.pss \
       -i 'x == (-b :plusminus sqrt(b^2-4*a*c))/(2*a);' &gt; test.tex
   pdflatex test.tex; 
   # see below for rendering
 </pre>
</figure>
<p>
 <img style='border-radius:5%;width:15em;' class='center'  title='/image/maths/formula.quadratic.png' src='/image/maths/formula.quadratic.png'/>

<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 another example 
 </figcaption>
<pre class='codeblock'>

   pep -f eg/maths.tolatex.pss \
       -i ' cuberoot(:Theta + x/(x+1))/(x^-0.5 + 1/2) '
   # see below for rendering with pdflatex
 </pre>
</figure>
<p>
 <img style='border-radius:5%;width:10em;' class='center'  title='/image/maths/formula.cuberoot.png' src='/image/maths/formula.cuberoot.png'/>

<p>
 made abbreviation code in <code>eg/nom.syntax.reference.pss</code> much better. also
 added a help system (but still need to write it)
<p>
 Made a template script <code>eg/nom.template.pss</code> which has an error and help
 token and a parse-stack watch and some common parsing code
 <p>
<!-- ------------------------------- -->
<h3> 16 mar 2025</h3>

<p>
 Looking at making some html colourized output. The css is in 
 <a href='/site.blog.css'><code>/site.blog.css</code></a> I inspected elements at the wren.io site for ideas.
<p>
 Added comments in documents (lines that start with #: ) in 
 <code>eg/text.tohtml.pss</code>
<p>
<!-- ------------------------------- -->
<h3> 15 mar 2025 (saturday)</h3>

<p>
 Yesterday, I created <code>eg/maths.to.latex.pss</code> which transforms 
 formulas like <em>x:=sqrt(x^2+y^2)/(2*x^-1.23) </em> into really nice 
 
<abbr class='tek-acronym' 
      title='The LaTeX text processing system'>L<sup><small>A</small></sup>T<sub>E</sub>X</abbr> formatted mathematics. I am impressed with my own 
 work. It works.
<p>
 I also invented the following lookahead rule which does a lot
 of work. This is a <em>positive</em> grammar lookahead rule, because 
 it reduces a set of token sequence if any of the sequences 
 <em>IS</em> followed by ) or , or ; Because it is a positive rule I 
 can combine several sequences into one rule. 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 the equivalent xbnf (expr* is 'e' here for brevity)
 </figcaption>
<pre class='codeblock'>

    e := e op.compare e | e op.and e | e op.or e 
         (LOOKAHEAD 1: ')' | ',' | ';' ) 
  </pre>
</figure>
<p>
 The bracketed expression means only perform the reductions if
 the following parse token - in this case a 'literal' value - is
 one of the 3 alternatives.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 an advanced "positive" look ahead rule
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

  <span class='nom-comment'># when surrounded by brackets or terminated with ; or ,</span>
  <span class='nom-comment'># eg: (x^2 != y) or x && y, </span>
  <span class='nom-punct'>B</span><span class='nom-string'>"expr*op.compare*expr*"</span><span class='nom-punct'>,</span><span class='nom-punct'>B</span><span class='nom-string'>"expr*op.and*expr*"</span><span class='nom-punct'>,</span><span class='nom-punct'>B</span><span class='nom-string'>"expr*op.or*expr*"</span> <span class='nom-punct'>{</span>
    <span class='nom-punct'>!</span><span class='nom-string'>"expr*op.compare*expr*"</span><span class='nom-punct'>.</span><span class='nom-punct'>!</span><span class='nom-string'>"expr*op.and*expr*"</span><span class='nom-punct'>.</span><span class='nom-punct'>!</span><span class='nom-string'>"expr*op.or*expr*"</span> <span class='nom-punct'>{</span>
      <span class='nom-punct'>E</span><span class='nom-string'>")*"</span><span class='nom-punct'>,</span><span class='nom-punct'>E</span><span class='nom-string'>",*"</span><span class='nom-punct'>,</span><span class='nom-punct'>E</span><span class='nom-string'>";*"</span> <span class='nom-punct'>{</span>
        <span class='nom-command'>replace</span> <span class='nom-string'>"expr*op.and*expr*"</span> <span class='nom-string'>"expr*"</span><span class='nom-punct'>;</span>
        <span class='nom-command'>replace</span> <span class='nom-string'>"expr*op.or*expr*"</span> <span class='nom-string'>"expr*"</span><span class='nom-punct'>;</span>
        <span class='nom-command'>replace</span> <span class='nom-string'>"expr*op.compare*expr*"</span> <span class='nom-string'>"expr*"</span><span class='nom-punct'>;</span>
        <span class='nom-command'>push</span><span class='nom-punct'>;</span><span class='nom-command'>push</span><span class='nom-punct'>;</span>
        <span class='nom-comment'># assemble attribs for new exp token,</span>
        <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>" "</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>" "</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
        <span class='nom-comment'># transfer unknown token attrib </span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span>
        <span class='nom-comment'># realign tape pointer </span>
        <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
      <span class='nom-punct'>}</span>
    <span class='nom-punct'>}</span>
  <span class='nom-punct'>}</span>
  </code></pre>
</figure>
<p>
<!-- ------------------------------- -->
<h3> 14 mar 2025</h3>

<p>
 I have been reforming and developing the arithmetic expression 
 parser which is now called <code>eg/maths.parse.pss</code> It now includes 
 good error handling and a help-text system (for explaining the 
 syntax of the expression parser). I also added an assignment operator
 (:=) logic operators (&& || AND OR) comparison operators
 (== != &lt; &lt;= &gt; &gt;= etc) and functions like sqrt(...) 
 It is now basically a template for how to write a language with 
 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> and it also forms a reasonably big chunk of any kind of 
 computer language parser/compiler. It can be more or less 
 cut-and-paste into other scripts.
<p>
<!-- ------------------------------- -->
<h3> 13 mar 2025</h3>

<p>
 Things to do on the 
<abbr class='tek-acronym' 
      title='Parsing Engine for Patterns'>PEP</abbr> and 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> system. 
 <!---- list ----->
<ul>

<li> rewrite <code>translate.perl.pss</code> using the new syntax at 
 <code>eg/nom.syntax.reference.pss</code>
 </li>
<li> make script <code>nom.syntax.recognise.pss</code> based on script above 
 which just says &ldquo;yes: nom syntax ok&rdquo; or &ldquo;no: etc&rdquo; This script would 
 become the basis of an non-error checking <em>nom</em> parser.
 </li>
<li> add help system to <code>eg/drawbasic.pss</code> 
 </li>
<li> add upper case headings to <code>text.tohtml.pss</code>
 </li>
<li> generate headers in <code>eg/</code> to html with <code>text.tohtml.pss</code>
 </li>
<li> make a new script <code>text.tolatex.pss</code> for printing a book
 </li>
<li> revise the docs at nomlang.org/doc to generate printed material
 </li>
</ul>
<!-- ------------------------------- -->
<h3> 11 mar 2025</h3>

<p>
 Starting to write the parser for a simple 
<abbr class='tek-acronym' 
      title='The turtle drawing language'>LOGO</abbr> <em>ish</em> drawing 
 language. The language is <a href='/eg/drawbasic.pss'><code>/eg/drawbasic.pss</code></a> but I hope 
 to change that name if the language gets good. <big><abbr class='chess-piece'><span class='chess-piece'>♛</span></abbr></big>
<p>
 Also, I was working today on <a href='/eg/nom.to.listing.pss'><code>/eg/nom.to.listing.pss</code></a>
 which is supposed to be a simple precursor to a 
 <em>nom.to.html.pss</em> html pretty-printer.
<p>
<!-- ------------------------------- -->
<h3> 8 mar 2025</h3>

<p>
 Have uploaded some solutions to problems at the <a href='http://www.rosettacode.org'>www.rosettacode.org</a>
 site. The 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> syntax checker <em>nom.syntax.reference.pss</em> is close
 to complete. I will use this script as a <em><code class='nom-token'>"reference*</code></em> for what 
 the syntax of <em>nom</em> is and should be. 
<p>
<!-- ------------------------------- -->
<h3> 7 march 2025</h3>

 <p>
 Need to think about the <code class='nom-command'><a title='nom command reference: mark' href='http://nomlang.org/doc/commands/nom.mark.html'>mark</a></code> and <code class='nom-command'><a title='nom command reference: go' href='http://nomlang.org/doc/commands/nom.go.html'>go</a></code> syntax. It might 
 be better to use the workspace value as the <em>mark</em> I am not sure.
<p>
 I will no longer permit ridiculous ranges in classes 
 <em>silly ranges: [\n-\f]</em> I think in the 
<abbr class='tek-acronym' 
      title='Parsing Engine for Patterns'>PEP</abbr> interpreter these 
 are currently accepted, but what does it even mean? I will just 
 allow simple ranges like [a-g] Also, I need to remove '&lt;' and 
 '&gt;' as abbreviations for <code class='nom-command'><a title='nom command reference: ++' href='http://nomlang.org/doc/commands/nom.plusplus.html'>++</a></code> and <code class='nom-command'><a title='nom command reference: --' href='http://nomlang.org/doc/commands/nom.minusminus.html'>--</a></code> because they
 clash with &lt;eof&gt; etc. Also, remove 'll' and 'cc' as aliases for 
 <code class='nom-command'><a title='nom command reference: chars' href='http://nomlang.org/doc/commands/nom.chars.html'>chars</a></code> and <code class='nom-command'><a title='nom command reference: lines' href='http://nomlang.org/doc/commands/nom.lines.html'>lines</a></code> . 
<p>
 Have been working on the <a href='/eg/nom.syntax.reference.pss'><code>/eg/nom.syntax.reference.pss</code></a> which is a syntax
 checker for the 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> script language. I have made good progress 
 and have added some new parse tokens, such as <em><code class='nom-token'>statement*</code></em> and 
 <em><code class='nom-token'>statementset*</code></em> (for a list of statements). And <em><code class='nom-token'>command*</code></em> is now just 
 the command word like <code class='nom-command'><a title='nom command reference: add' href='http://nomlang.org/doc/commands/nom.add.html'>add</a></code> or <code class='nom-command'><a title='nom command reference: push' href='http://nomlang.org/doc/commands/nom.push.html'>push</a></code> and not the 
 whole statement. &ldquo;eof&rdquo; and &ldquo;reparse&rdquo; are parsed as the <em><code class='nom-token'>word*</code></em> grammar
 token and reduced later to <em><code class='nom-token'>test*</code></em> and <em><code class='nom-token'>statement*</code></em> later.
<p>
<!-- ------------------------------- -->
<h3> 6 march 2025</h3>

<p>
 Trying to write an <em>nom</em> error checking script without adapting 
 an existing <a href='/tr/'>translation </a> script. So I am writing it
 from scratch and in the process I am discovering strange things about 
 the existing grammar that I have been using. For example I use
 '&gt;' and '&lt;' as abbreviations for <code class='nom-command'><a title='nom command reference: ++' href='http://nomlang.org/doc/commands/nom.plusplus.html'>++</a></code> and <code class='nom-command'><a title='nom command reference: --' href='http://nomlang.org/doc/commands/nom.minusminus.html'>--</a></code> but this 
 clashes with the <em>&lt;eof&gt;</em> syntax . So I will remove these abbreviations
 and also the '+' '-' abbreviations for <code class='nom-command'><a title='nom command reference: a+' href='http://nomlang.org/doc/commands/nom.aplus.html'>a+</a></code> and <code class='nom-command'><a title='nom command reference: a-' href='http://nomlang.org/doc/commands/nom.aminus.html'>a-</a></code> 
 because it is really silly to have 1 character abbreviations for 
 2 characters commands. 
<p>
 Also, I should have a <em><code class='nom-token'>command*</code></em> token for <code class='nom-command'><a title='nom command reference: add' href='http://nomlang.org/doc/commands/nom.add.html'>add</a></code> <code class='nom-command'><a title='nom command reference: clear' href='http://nomlang.org/doc/commands/nom.clear.html'>clear</a></code> 
 <code class='nom-command'><a title='nom command reference: upper' href='http://nomlang.org/doc/commands/nom.upper.html'>upper</a></code> for example and then a <em><code class='nom-token'>statement*</code></em> token for 
<p>
 <pre class='codeline'>
 add "hi"; replace "x" ""; clear;
</pre>

 <p>
 Also just use a <em><code class='nom-token'>word*</code></em> token for &ldquo;eof&rdquo; reparse etc. Things that are 
 not valid commands or tests but part of.
<p>
<!-- ------------------------------- -->
<h3> 4 march 2025</h3>

<p>
 I made symlinks for the <a href='https://bumble.sf.net/books/pars/tr'>bumble.sf.net/books/pars/tr</a> and <a href='https://bumble.sf.net/books/pars/eg'>bumble.sf.net/books/pars/eg</a> folders on this site
 so that the example scripts and translators will also be available here.
 And I will create a document index for them.
<p>
 Yesterday I wrote quite a large chunk of an 
<abbr class='tek-acronym' 
      title='Extensible Markup Language'>XML</abbr> <a href='/doc/scripts/nom.xml.html'>parser
 </a> (it is still in a documentation page). I was
 surprised how easy it was. I thought xml parsing was going to be difficult
 because it seemed to have multiple levels of <em>nesting</em> Firstly on an internal
 tag-level (a list of attributes withing the tag) etc. 
 <p>
 I also discovered some new techniques for error checking and reporting. For
 example: look for a parse-token which is at the end of a sub-pattern, in the
 case of 
<abbr class='tek-acronym' 
      title='Extensible Markup Language'>XML</abbr> an example is
 <em><code class='nom-token'>&gt;*</code></em> and <em><code class='nom-token'>/&gt;*</code></em> (literal tokens). These should always resolve to a 
 <em><code class='nom-token'>tag*</code></em> parse token, so if you check for this token followed by anything else
 you will trap a lot of errors.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 trapping errors with a 'last' token
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

    <span class='nom-comment'># a fragment</span>
    <span class='nom-command'>pop</span><span class='nom-punct'>;</span><span class='nom-command'>pop</span><span class='nom-punct'>;</span>
    <span class='nom-punct'>B</span><span class='nom-string'>">*"</span><span class='nom-punct'>,</span><span class='nom-punct'>B</span><span class='nom-string'>"/>*"</span> <span class='nom-punct'>{</span>
      <span class='nom-comment'># error, the tag* token didn't resolve or reduce as </span>
      <span class='nom-comment'># it should have.</span>
    <span class='nom-punct'>}</span>
    <span class='nom-command'>push</span><span class='nom-punct'>;</span><span class='nom-command'>push</span><span class='nom-punct'>;</span>
  </code></pre>
</figure>
<p>
 Also, I realised that you can just create the error message and 
 then print it with line number etc at the end of the error block. 
 I now favour putting all errors in a big block just after the 
 parse label (although 
<abbr class='tek-acronym' 
      title='End-Of-File (input-stream)'>EOF</abbr> errors will probably still need to 
 go at the end of the script). Also, 2 token error checking seems to
 be the most useful in general. Also, it&rsquo;s a good idea to have a 
 list of tokens at the start of your script, and then just look
 at them to see which ones can follow others.
<p>
<!-- ------------------------------- -->
<h3> 2 mar 2025</h3>

<p>
 I have been doing a lot of work on the <a href='http://nomlang.org'>nomlang.org</a> site (where this
 file is) including writing a quite useful 
<abbr class='tek-acronym' 
      title='Unix [B]ourne [A]gain [Sh]ell'>BASH</abbr> <a href='/webdev/copy.blog.sh'>script
 </a> which manages this website. This site <em>nomlang.org</em> is
 now the sort-of &ldquo;home&rdquo; of the <em class='pep-and-nom'>Pep & Nom</em> system, or at least of all the
 <a href='/doc/'>documentation </a>
<p>
 While writing the primitive-but-good static site generator in 
<abbr class='tek-acronym' 
      title='Unix [B]ourne [A]gain [Sh]ell'>BASH</abbr> I also
 wrote a new 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> script to format the <em>plain-text</em> into 
<abbr class='tek-acronym' 
      title='Hyper-text Markup Language'>HTML</abbr> . This
 script is called <a href='https://bumble.sf.net/books/pars/eg/text.tohtml.pss'>eg/text.tohtml.pss </a> and it
 works remarkably well as far as I can see. I actually started off with
 very humble aims for the script in fact I just wanted to do something
 like this
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 text-to-html
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

     <span class='nom-keyword'>begin</span> <span class='nom-punct'>{</span> <span class='nom-command'>add</span> <span class='nom-string'>"&lt;html>&lt;body>\n"</span><span class='nom-punct'>;</span> <span class='nom-command'>print</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-punct'>}</span>
     <span class='nom-command'>until</span> <span class='nom-string'>"\n"</span><span class='nom-punct'>;</span>
     <span class='nom-command'>replace</span> <span class='nom-string'>"&lt;"</span> <span class='nom-string'>"&lt;"</span><span class='nom-punct'>;</span> <span class='nom-command'>replace</span> <span class='nom-string'>">"</span> <span class='nom-string'>"&gt;"</span><span class='nom-punct'>;</span> <span class='nom-command'>replace</span> <span class='nom-string'>"&"</span> <span class='nom-string'>"&amp;"</span><span class='nom-punct'>;</span>
     <span class='nom-class'>[:space:]</span> <span class='nom-punct'>{</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"&lt;p>\n"</span><span class='nom-punct'>;</span> <span class='nom-punct'>}</span>
     <span class='nom-punct'>B</span><span class='nom-string'>"###"</span> <span class='nom-punct'>{</span> 
       <span class='nom-command'>clop</span><span class='nom-punct'>;</span><span class='nom-command'>clop</span><span class='nom-punct'>;</span><span class='nom-command'>clop</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span>
       <span class='nom-command'>add</span> <span class='nom-string'>"&lt;h3>"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"&lt;/h3>\n"</span><span class='nom-punct'>;</span>
     <span class='nom-punct'>}</span>
     <span class='nom-punct'>B</span><span class='nom-string'>"##"</span> <span class='nom-punct'>{</span> 
       <span class='nom-command'>clop</span><span class='nom-punct'>;</span><span class='nom-command'>clop</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span>
       <span class='nom-command'>add</span> <span class='nom-string'>"&lt;h3>"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"&lt;/h2>\n"</span><span class='nom-punct'>;</span>
     <span class='nom-punct'>}</span>
     <span class='nom-punct'>B</span><span class='nom-string'>"#"</span> <span class='nom-punct'>{</span> 
       <span class='nom-command'>clop</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span>
       <span class='nom-command'>add</span> <span class='nom-string'>"&lt;h3>"</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"&lt;/h1>\n"</span><span class='nom-punct'>;</span>
     <span class='nom-punct'>}</span>
     <span class='nom-command'>print</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span>
     <span class='nom-punct'>(</span><span class='nom-word'>eof</span><span class='nom-punct'>)</span> <span class='nom-punct'>{</span> <span class='nom-command'>add</span> <span class='nom-string'>"&lt;/body>&lt;/html>\n"</span><span class='nom-punct'>;</span> <span class='nom-command'>print</span><span class='nom-punct'>;</span> <span class='nom-command'>quit</span><span class='nom-punct'>;</span> <span class='nom-punct'>}</span>
   </code></pre>
</figure>
<p>
 In other words, it would just mark paragraphs and sort-of
 
<abbr class='tek-acronym' 
      title='non-distracting text documents'>MARKDOWN</abbr> headings. But it just grew and grew and it has been 
 really successful because I can just add <em>syntax</em> to it 
 willy-nilly and if it breaks I can easily fix it. So I will almost 
 certainly never use <a href='https://bumble.sf.net/books/pars/eg/mark.html.pss'>eg/mark.html.pss </a> again
 because it is hard to debug.
<p>
<!-- ------------------------------- -->
<h3> 1 mar 2025</h3>

<p>
 Wrote a <em>nom</em> script <a href='/eg/bash.show.functions.pss'>eg/bash.show.functions.pss 
 </a> which prints bash functions in a file 
 and the comments above them.
<p>
<!-- ------------------------------- -->
<h3> 19 feb 2025</h3>

<p>
 I am revisiting this system after almost 3 years of not doing anything on
 it. It still seems like a remarkably new way of parsing and compiling and
 worth pursuing. I updated the website at nomlang.org and improved some
 example scripts (like <a href='https://bumble.sf.net/books/pars/eg/exp.tolisp.pss)'>bumble.sf.net/books/pars/eg/exp.tolisp.pss)</a> and created a new
 text-to-html formatter <a href='https://bumble.sf.net/books/pars/eg/text.tohtml.pss'>bumble.sf.net/books/pars/eg/text.tohtml.pss</a> which is much simpler to
 maintain than <a href='https://bumble.sf.net/books/pars/eg/mark.html.pss'>bumble.sf.net/books/pars/eg/mark.html.pss</a> because it uses a less complex
 grammar.
<p>
<!-- ------------------------------- -->
<h3> 28 aug 2022</h3>

<p>
 Working on the <code>mark.latex.pss</code> script which now supports most 
 syntax including images. The script is quite complex. It should 
 be strait-forward to translate it to other targets such as 
 &ldquo;markdown&rdquo;,
 html, man 
<abbr class='tek-acronym' 
      title='Old unix typesetting system'>GROFF</abbr> etc.
<p>
<!-- ------------------------------- -->
<h3> 19 aug 2022</h3>

<p>
 Made a magical interpret() method in the perl translator which 
 will allow running of scripts.
<p>
 Working on a simplified grammar for <code>tr/translate.perl.pss</code> which
 I hope to use in all the translator scripts. So far so good. Also
 introducing a new expression grammar for tests eg:
 <pre class='codeline'>
 (B"a",B"b").E"z" { ... } 
</pre>

<p>
 This allows mixing AND and OR logic in tests. 
 Also, a <em>nom</em> script that extracts all unique tokens from a script 
 would be useful.
<p>
<!-- ------------------------------- -->
<h3> 17 aug 2022</h3>

<p>
 Looking at 
<abbr class='tek-acronym' 
      title='Another Tool for Language Recognition'>ANTLR</abbr> example grammars, for ideas of simple languages
 such as &ldquo;logo&rdquo;,
 &ldquo;abnf&rdquo;,
 
<abbr class='tek-acronym' 
      title='Backus-Naur Form'>BNF</abbr> , &ldquo;lambda&rdquo;,
 &ldquo;tiny basic
&rdquo; Reforming grammars of the translators, writing good &ldquo;unescape
&rdquo; and &ldquo;escape&rdquo; functions that actually walk and transform the 
 workspace string. Converting perl translator to a parse method
 Need an &ldquo;esc&rdquo; command to change the escape char in all translators.
 The perl translator is almost ready to be an interpreter.
<p>
<!-- ------------------------------- -->
<h3> 13 august 2022</h3>

<p>
 Debugged the 
<abbr class='tek-acronym' 
      title='Tool Control Language'>TCL</abbr> translator- appears to be working well except
 for second generation scripts.
<p>
 Current tasks: finish translators, perl/c++/rust/tcl 
 start translators: lisp/haskell/R (maybe)
 Write a new command &ldquo;until&rdquo; with no arguments.(done in some translators)
 Make the translators use a &ldquo;run&rdquo; or &ldquo;parse&rdquo; method, which
 can read and write to a variety of sources.
 Make the tape in <code>object/pep.c</code> dynamically allocated.
 See if begin { ++; } create space for a variable. And use this
 strategy for variable scope.
<p>
<!-- ------------------------------- -->
<h3> 28 july 2022</h3>

<p>
 Starting to create date-lists in <code>eg/mark.latex.pss</code> to render lists
 such as this one. Also, had the idea of a new test
 <pre class='codeline'>
 F:file.txt:"int" { ... }
</pre>

 This would test if the file &ldquo;file.txt&rdquo; contain a line starting
 with &ldquo;int&rdquo; and ending with &ldquo;:&rdquo; + workspace. This test would allow
 checking variable types and declarations. It would also allow better
 natural language parsing, because a list of nouns/adj/verbs etc
 could be stored in a simple text file and looked up.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 Also, variable scope could be included in the file e.g.
 </figcaption>
<pre class='codeblock'>

     int.global:x
     int.fn:x
     string.global:name
     string.local:name
     etc
   </pre>
</figure>
 Also, another test
 <pre class='codeline'>
 F:name.txt: { ... }
</pre>

 Would check the file <code>name.txt</code> for a line which begins with the tape
 and ends with the workspace.
<p>
<!-- ------------------------------- -->
<h3> 21 july 2022</h3>

<p>
 A lot of work on the Javascript translator <code>tr/translate.js.pss</code>
 1<sup class='ordinal'>st</sup> gen tests are working. Working on the rust translator and 
 the <code>eg/sed.tojava.pss</code> translator.
<p>
<!-- ------------------------------- -->
<h3> 13 july 2022</h3>

<p>
 New ideas: create a lisp parser, create a <em><code class='nom-token'>brainf***</code></em> compiler 
 (done see: <a href='/eg/brainfork.c.pss'><code>/eg/brainfork.c.pss</code></a> )
 create a &ldquo;commonmark&rdquo; markdown translator. This should be 
 not too hard, using the ideas in <a href='https://bumble.sf.net/books/pars/eg/mark.latex.pss'>bumble.sf.net/books/pars/eg/mark.latex.pss</a>
 will create a 'date list' format for <code>mark.latex.pss</code> and <code>mark.html.pss</code>
<p>
<!-- ------------------------------- -->
<h3> 7 july 2022</h3>

<p>
 Started a lisp parser <code>eg/lisp.pss</code>
 Worked on <code>eg/mark.latex.pss</code> which is now producing 
 reasonable pdf output (from <code>.tex</code> via pdflatex). Also realised
 that the accumulator could be used to simplify the grammar
 by counting words.
<p>
<!-- ------------------------------- -->
<h3> 5 july 2022</h3>

<p>
 Developed a 
<abbr class='tek-acronym' 
      title='Text Stream Editor'>SED</abbr> to java script, &ldquo;eg/sed.tojava.pss&rdquo; which has 
 progressed well. Still lacking branching commands and some other
 gnu sed extensions.
<p>
<!-- ------------------------------- -->
<h3> 30 june 2022</h3>

<p>
 Wrote a simple 
<abbr class='tek-acronym' 
      title='Text Stream Editor'>SED</abbr> parser and formatter/explainer at
 <code>eg/sed.parse.pss</code> (commands a,i,c not parsed yet).
<p>
<!-- ------------------------------- -->
<h3> 24 june 2022</h3>

<p>
 Some work on the javascript and perl translators. 
<p>
<!-- ------------------------------- -->
<h3> 18 june 2022</h3>

<p>
 Introducing an 'increment' method into the various machine classes
 in the target languages. This allows the 'tape' and 'marks' arrays
 to grow if required.
<p>
<!-- ------------------------------- -->
<h3> 17 june 2022</h3>

<p>
 Looking at translation scripts. Changing tape and mark arrays 
 to be dynamically growable in various target languages. 
<p>
<!-- ------------------------------- -->
<h3> 14 sept 2021</h3>

<p>
 reviewing documentation, tidying.
<p>
<!-- ------------------------------- -->
<h3> 9 sept 2021</h3>

<p>
 Working on the pl/0 scripts. <code>eg/plzero.pss</code> and <code>eg/plzero.ruby.pss</code>
 <code>eg/plzero.pss</code> now checks and formats a valid pl/0 program.
<p>
<!-- ------------------------------- -->
<h3> 4 sept 2021</h3>

<p>
 Working on the palindrome scripts <code>eg/pal.words.pss</code> and 
 <code>eg/palindrome.pss</code> . Both are working well and can be translated
 to various languages (go, ruby, python, c, java)
 I would like to add hyphen lists to <code>mark.latex.pss</code> and date
 lists (such as this one)
<p>
<!-- ------------------------------- -->
<h3> 28 aug 2021</h3>

<p>
 Go translator now working well. I would like to write a 
 translator for the Kotlin, R (the statistical language), swift
 rust. The script function pep.tt (in helpers.pars.txt) greatly 
 helps debugging translation scripts.
<p>
<!-- ------------------------------- -->
<h3> 20 aug 2021</h3>

<p>
 More progress. A number of the translation scripts are now 
 quite bug free and can be tested with the helper function 
 pep.tt &lt;langname&gt; This script also tests 2<sup class='ordinal'>nd</sup> generation 
 script translation, which is very useful where the original
 <em>pep</em> engine is not available (for example, on a server). 
<p>
<!-- ------------------------------- -->
<h3> 15 july 2021</h3>

<p>
 Continuing work. Starting many translation scripts such as
 <code>tr/translate.cpp.pss</code> and trying to debug and complete others.
<p>
<!-- ------------------------------- -->
<h3> 14 july 2021</h3>

<p>
 working on <code>tr/translate.c.pss</code> good progress. simple scripts translating 
 and compiling and running. Did not eliminate dependencies so that 
 scripts need to be compiled with <code>libmachine.a</code> in the <code>object/</code> folder.
<p>
<!-- ------------------------------- -->
<h3> 5 july 2021</h3>

 working on the Ruby translator in <code>tr/translate.ruby.pss</code>
 Should try to make a 'brew' package with ruby for pep.
<p>
<!-- ------------------------------- -->
<h3> 17 june 2021</h3>

 Some work on the Makefile. Renamed <code>gh.c</code> to <code>pep.c</code>
 Made <em>pep</em> look for <code>asm.pp</code> in the current folder or else in the 
 folder pointed to by the &ldquo;ASMPP&rdquo; environment variable.
 Need to add &ldquo;upper&rdquo; lower and &ldquo;cap&rdquo; to the translation scripts
 in <code>pars/tr/</code>
<p>
<!-- ------------------------------- -->
<h3> 15 june 2021</h3>

<p>
 Things done:
<p>
 <!---- list ----->
<ul>

<li> implemented &ldquo;nochars&rdquo; nolines &ldquo;upper&rdquo; lower &ldquo;cap&rdquo; (capital case 
 for workspace) in machine.interp.c. nochars and nolines are already
 in a number of translation scripts.
 </li>
<li> clean up the pars folder (get rid of stray <code>gh.c</code> files etc).
 </li>
<li> fixed the add &ldquo;\\&rdquo; bug which was cause by a bad implementation of 
 until in <code>machine.interp.c</code> (need to count preceding escape chars)
 Need to fix the same in the translation scripts
</li>
</ul>
 Here are some immediate tasks to make the <em>pep</em> engine more complete. 
<p>
 <!---- list ----->
<ul>

<li> write a &ldquo;make configure&rdquo; script to install <em>pep</em> somewhere
 </li>
<li> fix up the website at <a href='http://www.peptool.org'>www.peptool.org</a> and include some docs there 
 </li>
<li> try to write an html translator for the commonmark spec and contact
 jgm - the pandoc guy to try to generate some interest in pep.
 </li>
<li> write some code on rosettacode site. (done) Send to linguists.
 </li>
<li> write a go translator for a modern compiled script engine. (done)
 </li>
<li> finish tcl translator
</li>
</ul>
<!-- ------------------------------- -->
<h3> 8 june 2021</h3>

<p>
 Have made some more good progress over the last few days. Modified
 the script <a href='https://bumble.sf.net/books/pars/eg/json.check.pss'>bumble.sf.net/books/pars/eg/json.check.pss</a> so that it recognises
 all 
<abbr class='tek-acronym' 
      title='Javascript object notation'>JSON</abbr> numbers (scientific etc)
<p>
 Fixed <a href='/books/pars/tr/translate.py.pss'><code>/books/pars/tr/translate.py.pss</code></a> so that it can translate scripts as
 well as itself. Started to fix /books/pars/tr/translate.tcl.pss. Still
 have an infinite loop when .restart is translated, and this is a general
 problem with the &ldquo;run-once&rdquo; loop technique (for languages that don&rsquo;t have
 labelled loops or <em>goto</em> statements, for implementing .reparse and .restart).
 The solution is a flag variable that gets set by .restart before the 
 parse&gt; label (see translate.ruby.pss)
 <p>
 The script <code>eg/mark.latex.pss</code> is progressing well. It transforms a 
 markdown-ish format (like the current doc) into LaTeX. Need to do
 lists/images/tables/dates
<p>
<!-- ------------------------------- -->
<h3> 18 april 2021</h3>

<p>
 Having another look at this system. I still see enormous potential
 for the system, but don&rsquo;t know how to attract anyones attention!
 I updated the <code>eg/json.check.pss</code> script to provide helpful
 error messages with line+character numbers. Also, that script 
 incorporates the scientific number format (crockford) in 
 eg/json.number.pss. However, Crockfords grammer for scientific numbers
 seems much stricter than what is often allowed by json parsers
 such as the &ldquo;jq&rdquo; utility.
<p>
 I became distracted by a bootable x86 forth stack-machine system
 I was coding at /books/osdev/os.asm That was also interesting, and
 I had the idea of somehow combining it with this. Hopefully these ideas 
 will come to fruition.
<p>
 I think the best idea would be to edit the <a href='/books/pars/pars-book.txt'><code>/books/pars/pars-book.txt</code></a>
 document, generate a pdf, print it out, and send it to someone
 who might be interested. This parsing/compiling system is 
 revolutionary (I think), but nobody knows about it!!
<p>
<!-- ------------------------------- -->
<h3> 15 december 2020</h3>

<p>
 I have not done any work on this project since about August 2020 but the
 idea remains interesting. Finishing the &ldquo;translate.c.pss&rdquo; script would be
 good (done: sept 2021), make &ldquo;translate.go.pss&rdquo; for a more modern audience
 (done: sept 2021).
<p>
<!-- ------------------------------- -->
<h3> 27 august 2020</h3>

<p>
 Working on the script &ldquo;translate.c.pss&rdquo; to create c code from a 
 <em>pep</em> script. I may try to eliminate dependency files and include
 all the required structures and functions in the script. That
 should facilitate converting the output to wide chars &ldquo;wchar&rdquo;.

<p>
<!-- ------------------------------- -->
<h3> 11 august 2020</h3>

 Ideas: write a bash script to test each script 
 translator (such as <code>translate.tcl.pss</code> <code>translate.java.pss</code> ....)
 [done: the pep.tt function]
<p>
 In the java <a href='https://bumble.sf.net/books/pars/tr/translate.java.pss'>translator </a> , make the
 parse/compile script a method of the class, with the input stream as a
 parameter. So that the same method can be used to parse/compile a string, a
 file, or [stdin], among other things. (note: not yet done: march 2025)
<p>
 This technique can be used for any language but is easier with
 languages that support data-structures/classes/objects.
<p>
<!-- ------------------------------- -->
<h3> 7 august 2020</h3>

<p>
 Continuing to work on the scripts <code>translate.py.pss</code> and translate.tcl.pss.
 Had the idea to split the <code>pars-book.txt</code> into separate 
<abbr class='tek-acronym' 
      title='Unix Manual (Doc) Pages'>MAN</abbr> pages just like
 the 
<abbr class='tek-acronym' 
      title='Tool Control Language'>TCL</abbr> system &ldquo;man 3tcl string&rdquo; etc. (could generate man pages from 
 the command documentation at <a href='http://nomlang.org/doc/commands/'>nomlang.org/doc/commands/</a> )
<p>
<!-- ------------------------------- -->
<h3> 24 july 2020</h3>

<p>
 Made great progress on the script <a href='https://bumble.sf.net/books/pars/tr/translate.java.pss'>translate.java.pss
 </a> which could become a template for a whole set
 of scripts for translating to other languages.
<p>
<!-- ------------------------------- -->
<h3> 23 july 2020</h3>

<p>
 Continuing to work on <code>translate.java.pss</code>
 Still need to convert the <code class='nom-command'><a title='nom command reference: push' href='http://nomlang.org/doc/commands/nom.push.html'>push</a></code> <code class='nom-command'><a title='nom command reference: pop' href='http://nomlang.org/doc/commands/nom.pop.html'>pop</a></code> code and test and debug.
 Many methods have been in-lined and the Machine class code 
 is now in the script. 
 <p>
<!-- ------------------------------- -->
<h3> 22 july 2020</h3>

<p>
 Rethinking the translation scripts <a href='https://bumble.sf.net/books/pars/tr/translate.java.pss'>bumble.sf.net/books/pars/tr/translate.java.pss</a> and
 <a href='https://bumble.sf.net/books/pars/tr/translate.js.pss'>bumble.sf.net/books/pars/tr/translate.js.pss</a> These scripts can be greatly simplified. I will
 remove all trivial methods from the Machine object and use the script to
 emit code instead. Hopefully <em>translate.java.pss</em> will become a template for
 other similar scripts. Also, I will include the Machine object within the
 script output so that there will be no dependency on external code.
<p>
<!-- ------------------------------- -->
<h3> 20 july 2020</h3>

<p>
 Wrote the script <a href='/books/pars/eg/json.number.pss'><code>/books/pars/eg/json.number.pss</code></a> which parses
 and checks numbers in json scientific format (Eg -0.00012e+012)
 This script can be included in the script <code>eg/json.parse.pss</code> to 
 provide a reasonable complete json parser/checker.
<p>
<!-- ------------------------------- -->
<h3> 3 july 2020</h3>

<p>
 Working on the script <a href='/books/pars/eg/mark.html.pss'><code>/books/pars/eg/mark.html.pss</code></a> The script is working
 reasonably well for transforming the <code>pars-book.txt</code> file into html. 
 It can be run with:
 <pre class='codeline'>
 pep -f eg/mark.html.pss pars-book.txt &gt; pars-book.html
</pre>

<p>
<!-- ------------------------------- -->
<h3> 15 june 2020</h3>

<p>
 Cleaning up the files in the <a href='/books/pars/'><code>/books/pars/</code></a> folder tree. 
 Renaming the executable to &ldquo;pep&rdquo; from &ldquo;pp&rdquo;.
 I think &ldquo;pep&rdquo; will be
 the tools definitive name.
<p>
<!-- ------------------------------- -->
<h3> 14 june 2020</h3>

<p>
 I will rename the tool and executable to &ldquo;pep&rdquo; which would stand for &ldquo;parsing&rdquo; engine for patterns". I think it is a better name than &ldquo;pp&rdquo; and only seems to
 conflict with &ldquo;python enhancement process&rdquo; in the unix/linux world.
<p>
 Wrote a substantial part of the script 
 <a href='/books/pars/eg/json.parse.pss'><code>/books/pars/eg/json.parse.pss</code></a> which can parse and check the 
 json file format. However, the parser is incomplete because at 
 the moment it only accepts integer numbers. Recursive object 
 and array parsing is working.
 <p>
 I will try to improve the <code>mark.html.pss</code> &ldquo;markdown&rdquo; transform 
 script. I would still like to promote this parsing VM since
 I think it is a good and original idea.
<p>
<!-- ------------------------------- -->
<h3> 23 august 2019</h3>

 <p>
 Did some work on <code>mark.html.pss</code> 
<p>
<!-- ------------------------------- -->
<h3> 20 august 2019</h3>

<p>
 Cleaned up memory leaks (with valgrind). Also some
 one-off errors and invalid read/writes. The double-free segmentation
 fault seems to be fixed. Still need to fix a couple of memory bugs
 in interpret() (one is in the UNTIL command).
<p>
<!-- ------------------------------- -->
<h3> 17 august 2019</h3>

<p>
 Trying to clean up the <code>pars-book.txt</code> file which is the primary 
 documentation file for the project. 
<p>
 Posted on comp.compilers and <code>comp.lang.c</code> to see if anyone might
 find this useful or interesting...
<p>
<!-- ------------------------------- -->
<h3> 16 august 2019</h3>

 <p>
 The implementation at <a href='http://bumble.sourceforge.net/books/pars/object'>bumble.sourceforge.net/books/pars/object</a>
 has arrived at a usable <em>beta</em> stage (barring a segmentation fault
 when running big scripts).
<p>
<!-- ------------------------------- -->
<h3>  22 feb 2015 </h3>

 (approximately)
<p>
 Started the current implementation in the c language. I created
 a simple loop to test each new command as it was added to the 
 machine, and this proved a successful strategy as it motivated
 me to keep going and debug as I went.
<p>
<p>
<!-- ------------------------------- -->
<h3>  2009 </h3>

<p>
 Wrote an incomplete c version of this machine called &ldquo;chomski&rdquo;.

<p>
<!-- ------------------------------- -->
<h3> 2006 - 2014</h3>

<p>
 Wrote incomplete versions in c++ and java. The java Machine object at
 <a href='/books/pars/object.java/'><code>/books/pars/object.java/</code></a> got to a useful stage and will be a useful target
 for a script, very similar to <a href='/books/pars/tr/translate.c.pss'><code>/books/pars/tr/translate.c.pss</code></a> (and will be
 called &ldquo;translate.java.pss&rdquo; ). This script creates compilable java code
 using the java Machine object. In fact, we will be able to run this script
 on itself (!). In other words we can run:
 <pre class='codeline'>
 pep -f tr/translate.java.pss tr/translate.java.pss
</pre>

 The output will be compilable java code that can compile any parse machine
 script into compilable java code. Having this java system we are
 able to use unicode characters in scripts. 
<p>
 It will be interesting to see how much slower the java version is.
<p>
<!-- ------------------------------- -->
<h3> 2005</h3>

<p>
 Started to think about a tape/stack parsing machine.
<p>
<p>
 The coding of this version was begun around mid-2014. A number of other
 versions have been written in the past but none was successful or
 complete. 
<p>
<!-- ------------------------------- -->
<h3> 20 aug 2022</h3>

 will try to add a new until command (until ends with tape)
 also &ldquo;w filename;&rdquo; also &ldquo;quit &lt;code&gt;;
&rdquo; <!-- ------------------------------- -->
<h3> 15 june 2021</h3>

<p>
 Trying to get this to look for ASMPP env variable to find the &ldquo;asm.pp
&rdquo; file which it needs to actually compile and run scripts, here is a 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 code snippet
 </figcaption>
<pre class='codeblock'>
 
      printf("test\n");
      const char* s = getenv("PATH");
      printf("PATH :%s\n",(s!=NULL)? s : "getenv returned NULL");
      printf("end test\n");
   </pre>
</figure>
<p>
<!-- ------------------------------- -->
<h3> 23 april 2021</h3>

<p>
 First new code for a while. I will add a switch that prints the stack when
 .reparse is called. (note: no, we can just print the stack after the
 <a title='nom syntax reference: parse&gt;' href='http://nomlang.org/doc/syntax/nom.syntax.parselabel.html'>parse&gt;</a> label with the <code class='nom-command'><a title='nom command reference: stack' href='http://nomlang.org/doc/commands/nom.stack.html'>stack</a></code> and <code class='nom-command'><a title='nom command reference: unstack' href='http://nomlang.org/doc/commands/nom.unstack.html'>unstack</a></code> commands) This
 should help in debugging complex grammars (such as <code>mark.html.pss</code> or
 newmark.pss) But it may be easier to add this to the <code>compile.pss</code> script
 since .reparse is just a jump to the parse label.
<p>
<!-- ------------------------------- -->
<h3> 14 march 2020</h3>

<p>
 Trying to use an environment variable to locate 'asm.pp'
 <p>
<!-- ------------------------------- -->
<h3> 6 september 2019</h3>

 <p>
 Added <code class='nom-command'><a title='nom command reference: stack' href='http://nomlang.org/doc/commands/nom.stack.html'>stack</a></code> and <code class='nom-command'><a title='nom command reference: unstack' href='http://nomlang.org/doc/commands/nom.unstack.html'>unstack</a></code> commands. But they don't update
 the tape pointer (yet).
<p>
<!-- ------------------------------- -->
<h3> 28 august 2019</h3>

<p>
 Small adjustments to &ldquo;compile.pss&rdquo;.
 Starting to rewrite <code>compilable.c.pss</code> to
 convert back to a single class test and also convert to changes made to
 <code>compile.pss</code> (eg negation and &ldquo;ortestset*&rdquo; compilation). This is a
 maintainance problem trying to keep <code>compile.pss</code> and <code>compilable.c.pss</code> in sync
 so that they recognise the same syntax. (note: the translation scripts don't
 really need to use the grammar as the <a href='https://bumble.sf.net/books/pars/compile.pss'>bumble.sf.net/books/pars/compile.pss</a> compiler with
 <em>ortestset</em> etc because they don't have to compile assembly-style 
 &ldquo;jumps&rdquo;.
 )
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 a simpler way to reduce test* tokens 
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

     <span class='nom-comment'># fragment.</span>
     <span class='nom-comment'># we use a leading or trailing comma to make a test*</span>
     <span class='nom-comment'># parse-token. This is sort-of "context parsing"</span>
     <span class='nom-command'>pop</span><span class='nom-punct'>;</span><span class='nom-command'>pop</span><span class='nom-punct'>;</span> 
     <span class='nom-string'>"quoted*,*"</span><span class='nom-punct'>,</span><span class='nom-string'>"class*,*"</span><span class='nom-punct'>,</span><span class='nom-string'>",*quoted*"</span><span class='nom-punct'>,</span><span class='nom-string'>",*class*"</span> <span class='nom-punct'>{</span>
       <span class='nom-command'>replace</span> <span class='nom-string'>"quoted*"</span> <span class='nom-string'>"test*"</span><span class='nom-punct'>;</span> <span class='nom-command'>replace</span> <span class='nom-string'>"class*"</span> <span class='nom-string'>"test*"</span><span class='nom-punct'>;</span>
       <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
     <span class='nom-punct'>}</span>
     <span class='nom-command'>pop</span><span class='nom-punct'>;</span>    
     <span class='nom-string'>"test*,*test*"</span> <span class='nom-punct'>{</span>
     <span class='nom-command'>push</span><span class='nom-punct'>;</span><span class='nom-command'>push</span><span class='nom-punct'>;</span><span class='nom-command'>push</span><span class='nom-punct'>;</span>
   </code></pre>
</figure>
<p>
 All the &ldquo;,*&rdquo; comma tokens above get confusing to look at when
 in a test with commas, so it could be better to actually make a 
 &ldquo;comma*&rdquo; token.
<p>
<!-- ------------------------------- -->
<h3> 24 august 2019</h3>

<p>
 Added the <code class='nom-command'><a title='nom command reference: delim' href='http://nomlang.org/doc/commands/nom.delim.html'>delim</a></code> command which changes the stack token delimiter
 for <code class='nom-command'><a title='nom command reference: push' href='http://nomlang.org/doc/commands/nom.push.html'>push</a></code> and <code class='nom-command'><a title='nom command reference: pop' href='http://nomlang.org/doc/commands/nom.pop.html'>pop</a></code> commands.
<p>
<!-- ------------------------------- -->
<h3> 23 august 2019</h3>

<p>
 Rewrote <em>quoteset</em> parsing in <a href='https://bumble.sf.net/books/pars/compile.pss'>bumble.sf.net/books/pars/compile.pss</a> Much better now, doesn&apos;t
 use &ldquo;hops&rdquo;.
 Also, replaced <a href='https://bumble.sf.net/books/pars/asm.pp'>bumble.sf.net/books/pars/asm.pp</a> with an <code>asm.pp</code> generated 
 the <em>nom</em> compiler. 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 generate a new 'candidate' compiler with the nom script compiler
 </figcaption>
<pre class='codeline'>
 pep -f compile.pss compile.pss &gt; asm.test.pp
</pre>
</figure>
<p>
 This means that 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>NOM</abbr> is now <em>self-hosting</em> yaaaay.
 Thought it would be nice to have a javascript machine object ...
 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 create a javascript script parser/compiler 
 </figcaption>
<pre class='codeline'>
 pep -f translate.js.pss translate.js.pss &gt; pep.js
</pre>
</figure>
<p>
 (not implemented, need to write the machine object and command
 methods, and the convert script. The convert script is a 
 straightforward conversion of the &ldquo;compilable.c.pss&rdquo; script,
 but the machine object will take a little longer to write -
 but presumable, much less time than writing the struct machine
 object in c). 
<p>
 Once we have these things we will be able to run scripts in a browser which
 will be nice for testing. And we will also be able to use 
<abbr class='tek-acronym' 
      title='The Universal Language Code'>UNICODE</abbr>
 characters!!
<p>
<!-- ------------------------------- -->
<h3> 20 august 2019: sunny</h3>

<p>
 Writing a man page for pep. But I will use the asciidoc system and convert
 to html and troff. Also wrote ghman in the bash <a href='https://bumble.sf.net/books/pars/helpers.pars.sh'>helper
 </a> functions file which installs the page 
 (in 
<abbr class='tek-acronym' 
      title='The successor to minix'>LINUX</abbr> at least).
<p>
 Cleaning up memory leaks with valgrind. Still one problem in UNTIL in
 execute() function in <code>machine.interp.c</code> Also an initialised value bug in
 TESTIS (need a newParameter func?) But TESTIS should not be called unless
 the parameter .text value is set...
<p>
<!-- ------------------------------- -->
<h3> 19 august 2019: public holiday, bogota.</h3>

 <p>
 Fixed a &ldquo;one-off&rdquo; bug. Also, found a bug in &ldquo;until&rdquo; in the execute()
 function in <code>machine.interp.c</code> (via valgrind). Can fix with endsWith() in
 buffer.c. Memory leaks when growing cells and buffer needs to be fixed. 
 Valgrind on osx doesn' work properly so I need to use 
<abbr class='tek-acronym' 
      title='The successor to minix'>LINUX</abbr> for
 this job.
<p>
 Discovered many memory leaks and &ldquo;one-off&rdquo; errors and other more obvious
 bugs using valgrind.
<p>
<!-- ------------------------------- -->
<h3> 14 august 2019</h3>

<p>
 Bogota, Colombia - raining
 <p>
 Added begin-blocks to compile.pss, <code>asm.pp</code> and <code>compilable.c.pss</code>
 These work in a similar way to awk's begin {} rules.
 Added negated text tests to <code>compile.pss</code> and compilable but 
 not to <code>asm.pp</code> . So now we can do 
 <pre class='codeline'>
 pep -f compile.pss -i ' !""{a"not empty!!";}t;d;'
</pre>

 to check if the workspace is empty
<p>
 made the script <code>eg/exp.recogniser.pss</code> work and also
 <code>eg/exp.tolist.pss</code>
<p>
 Need to deal with a segmentation fault. I think it has to 
 do with &ldquo;scriptFile&rdquo; not being closed properly, but am not 
 sure. Also, when we do the &ldquo;quit&rdquo; command we should free
 the machine and inputstreams no?
<p>
 Changed the enum boolean because true and false were back to 
 front.
<p>
 Can compile <code>test/test.natural.language.pss</code> with the 
 script <code>compilable.c.pss</code> (see the &ldquo;pepcl&rdquo; helper bash function)
 and it runs as a standalone.
<p>
 Compiled the files in the <code>object/</code> folder to a static library
 <code>libmachine.a</code> and then compiled the output of <code>translate.c.pss</code>
 successfully with &ldquo;gcc -o test test.c -Lobject/ -lmachine
<p>
&rdquo; So, we can generate standalone executable parsing/transforming
 programs from a script with
 <em>pep</em> -f <code>translate.c.pss</code> <code>script.pss</code> &gt; <code>script.c</code>
 gcc -o scriptx <code>script.c</code> <code>-Lobject/</code> -lmachine
<p>
<!-- ------------------------------- -->
<h3> 13 august 2019</h3>

<p>
 Continued to separate the code in <code>pep.c</code> into separate 'object' 
 files in the <code>pars/object/</code> folder. Currently up to <code>machine.c</code> 
 now will do <code>machine.interp.c</code> The code is compiling with the bash 
 function ppco which is in the file <code>pars/helpers.pars.sh</code> . I am
 not using 'make' to compile, currently.
<p>
<!-- ------------------------------- -->
<h3> 12 august 2019</h3>

<p>
 Reorganising the source code files. The main c file is now
 <code>pars/object/pep.c</code> and this includes the other 'object' files which
 are in this directory. Moved the old <code>pep.c</code> source code files 
 to the folder Monolith.gh (because everything was in the one
 file).
<p>
 Made the files in the pars/object folder the canonical source code for
 the machine. This means I need to make ppc etc compile with these
 files.
<p>
 Discovered a bug in classtests. An empty workspace returns
 true for a range test. 
<p>
 Because <code>eg/expression.pss</code> to parse arithmetic expressions such as &ldquo;(7 + 100)&rdquo;  -100". Need to arrange the grammar so that it has a "lookahead" of 1 token
 so that operator precedence can be handled. Also thought that &ldquo;/&rdquo; would be a
 better token delimiter. Need a command to set the token delimiter character
 on the machine. Also need a way to give statements to a script that are only
 executed once, when the script starts. Perhaps the (eof) section/test should
 work in the same way (be a script section, rather than a state-test).
<p>
 Also, thought that the machine needs a &ldquo;testhas&rdquo; test, which 
 would return true if the workspace currently contains the 
 text in the current tapecell. This would allow parsing strings
 such as &ldquo;eeee&rdquo;,
 &ldquo;fffff&rdquo;.
 Also a &ldquo;testtapeend&rdquo; which returns true
 if the workspace currently ends with the text in the current 
 tapecell.
<p>
 Also, maybe need a &ldquo;untiltape&rdquo; command which reads until the 
 workspace ends with the text in the current tape cell. 
 This would allow parsing 
<abbr class='tek-acronym' 
      title='Text Stream Editor'>SED</abbr> syntax &ldquo;s#...##&rdquo; or &ldquo;s/...//&rdquo; where
 the delimiter character can be anything which occurs after 
 the &ldquo;s&rdquo; character.
<p>
<!-- ------------------------------- -->
<h3> 10 august 2019</h3>

<p>
 trying to organise the <a href='https://bumble.sf.net/books/pars/pep.c'>bumble.sf.net/books/pars/pep.c</a> source code into separate objects
 in the <code>pars/object/</code> folder.
<p>
<!-- ------------------------------- -->
<h3> 8 august 2019</h3>

 Continued working on <code>translate.c.pss</code>
 split the <em><code class='nom-token'>class*</code></em> token into charclass*, <em><code class='nom-token'>range*</code></em> and <em><code class='nom-token'>list*</code></em> 
 with corresponding negated classes.
<p>
<!-- ------------------------------- -->
<h3> 7 august 2019</h3>

<p>
 Worked on <code>translate.c.pss</code>
<p>
<!-- ------------------------------- -->
<h3> 6 august 2019</h3>

<p>
 would be handy to have multiline quotes.... (implemented)
 working on <code>compile.ccode.pss</code> (note: this was the ancestor of 
 <a href='https://bumble.sf.net/books/pars/tr/translate.c.pss'>bumble.sf.net/books/pars/tr/translate.c.pss</a> and the other translation scripts)
<p>
<!-- ------------------------------- -->
<h3> 4 august 2019</h3>

<p>
 I think I finally tracked down the &ldquo;until&rdquo; bug, which was
 actually a bug in readc(). A character pointer lastc was
 assigned before a growBuffer() call (which calls realloc()).
 When realloc() assigned a new memory block the character
 pointer was no longer valid.
<p>
<!-- ------------------------------- -->
<h3> 3 august 2019</h3>

 <p>
 Still looking at the &ldquo;until&rdquo; bug. Basically the problem
 occurs when the text read with until is greater than
 about 950 bytes. This is caused because &lt;950 bytes realloc()
 basically did nothing, hence no problem!
<p>
<!-- ------------------------------- -->
<h3> 30 july 2019</h3>

<p>
 A useful command for calculating jumps: &ldquo;+int&rdquo; which
 will add the given integer to all integers in the workspace.
 This command may be necessary when certain forward jumps are 
 not known during compilation.
<p>
 Maybe, it could be useful to have a very basic pattern matching syntax for
 tests. Similar to a filename match: eg <em><code class='nom-token'>/word*?\*\*</code></em> <a href='/'><code>/</code></a> where ? matches any one
 character, * matches multiple, and <em><code class='nom-token'>\*</code></em> is a literal asterix. This could be
 useful in error handling blocks, so as not to have to write out every single
 combination of tokens. However, it would not be very readable.
<p>
 <a href='https://bumble.sf.net/books/pars/compile.pss'>bumble.sf.net/books/pars/compile.pss</a> appears to be working. It is more readable and
 maintainable than <a href='https://bumble.sf.net/books/pars/asm.pp'>bumble.sf.net/books/pars/asm.pp</a> but in the case of <em><code class='nom-token'>quoteset*</code></em> it
 compiles not very efficient code (multiple jumps where 
 <code>asm.pp</code> compiles only one). See the <code>asm.pp</code> file for a much
 better error handling idea.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 comparison of compile.pss and asm.pp
 </figcaption>
<pre class='codeblock'>

     compile.pss 664 lines
         asm.pp 1485 lines
   </pre>
</figure>
<p>
 Had the idea for an &ldquo;expand&rdquo; command in which the machine will
 convert an abbreviated command into it&rsquo;s full form in the 
 workspace. Probably not.
<p>
 Converting <code>asm.pp</code> into <code>compile.pss</code> which is much more compact
 and readable. Finished converting, but not debugged. 
<p>
 Creating <em><code class='nom-token'>notclass*</code></em> syntax in asm.pp. eg ![a-z] { nop; }
<p>
 Realised that I can just directly translate <code>asm.pp</code> into
 a compiling script. It will be convenient to have ![class] {}
 syntax. We can implement this in <code>asm.pp</code> quite easily.eg:
 <em><code class='nom-token'>notclass*</code></em> ⇽ <em><code class='nom-token'>!*class*</code></em>
 <em><code class='nom-token'>command*</code></em> ⇽ <em><code class='nom-token'>notclass*{*commandset*}*</code></em>
 Started translating <code>asm.pp</code> into parse-script language. It seems
 quite straight forward. Also, we could write a script that
 compiles &ldquo;recognisers&rdquo;,
 just like the 2 bnf grammar rules above
 eg:
 notclass ⇽ ! class
 command ⇽ notclass { commandset } 
<p>
<!-- ------------------------------- -->
<h3> 29 july 2019</h3>

<p>
 Continued converting execute() into functions in <code>machine.methods.c</code>
 Realised that I have to modify how jumps and tests work when
 creating executable scripts. In fact it may be necessary to use
 the c &ldquo;goto&rdquo; instruction in order to implement &ldquo;.reparse&rdquo; and
 &ldquo;.restart&rdquo;.

 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 file sizes: 
 </figcaption>
<pre class='codeblock'>

       pep.c 187746 bytes
       pep    99432 bytes
       machine.methods.c 16761 bytes
   </pre>
</figure>
<p>
<p>
<!-- ------------------------------- -->
<h3> 28 july 2019</h3>

 <p>
 created some machine methods in <code>machine.methods.c</code> by copying 
 code from execute(). The process seems straight forward.
<p>
 Added an &ldquo;-i&rdquo; switch to make it easier to provide input
 when running interactively. (we will be able to do
 echo &ldquo;abcd&rdquo; | <em>pep</em> -f <code>palindrome.pss</code> eventually)
 Looking again at the <code>test.palindrome.pss</code> script, which doesn&apos;t
 quite work because of &ldquo;.restart&rdquo; on eof.
<p>
<!-- ------------------------------- -->
<h3> 27 july 2019, in bogota, colombia</h3>

<p>
 Wrote a palindrome detector which seems very complicated for the simple
 task that it does, and also it does not actually work in all cases. 
 <p>
 I implemented &ldquo;quotesets&rdquo; with a few nifty tricks. quotesets allow
 multiple equals tests for a given block. The difficulty is that they are
 parsed before the braces are encountered in the stream, so it is not
 possible to resolve the forward jump. But there was a solution to this,
 best understood by looking at the source code in &ldquo;asm.pp&rdquo;.
 So multiple
 tests for one block are possible with &ldquo;quotesets&rdquo; which are implemented
 in <code>asm.pp</code> and resolve into tests for blocks. They are very useful
 because they allow syntax like this:
<p>
 &ldquo;noun*verb*object*&rdquo;,
 
 &ldquo;article*verb*object*&rdquo;,

 &ldquo;verb*object&rdquo; {
 <!-- ------------------------------- -->
<h1> translate here </h1>

 }
 <p>
<!-- ------------------------------- -->
<h3> 26 july 2019</h3>

<p>
 Discovered that the &ldquo;until&rdquo; instruction was not growing the 
 workspace buffer properly, leading to bugs. The same bug will
 apply to &ldquo;while&rdquo;.
 See the bugs: section for more information.
 For some reason readc() is not growing the workspace properly
 at the right time. The bug become apparent when parsing 
 <code>test.commands.pss</code> and trying to read past a large multi-line
 comment block. eg:
 <pre class='codeline'>
 pep -If test.commands.pss input.txt
</pre>

 <p>
<!-- ------------------------------- -->
<h3> 25 july 2019</h3>

<p>
 Worked on <code>test.commands.pss</code> which acts like a kind of syntax check
 and demonstration for all commands and structures implemented in
 <code>asm.pp</code>
<p>
 working on the <code>asm.pp</code> compiler. wrote the .reparse keyword and 
 the &ldquo;parse&gt;&rdquo; parse label. Finished end- and beginstest and blocks.
<p>
 Implemented the &ldquo;replace&rdquo; machine instruction but not really debugged.
 Added replace to the <code>asm.pp</code> compiler so that it can be used in
 scripts as well.
 <p>
<!-- ------------------------------- -->
<h3> 24 july 2019</h3>

<p>
 Writing the parameterFromText() function. This will allow parsing
 multiple parameters to an instruction. The tricky bit is that 
 parameterFromText() has to return the last character scanned 
 to that the next call to it, will start and the current scan
 position. Once I have multiple parameters, then I can write the 
 &ldquo;replace&rdquo; command: eg replace &ldquo;one&rdquo; two";<p>
 Realised that I need a replace command, and this requires the use of 2
 parameters. Maybe a bit of infrastructure will have to be written. An
 example of the use of &ldquo;replace&rdquo; is converting c multi-line comments into
 bash style comments. It would be possible to parse line by line and
 achieve this without &ldquo;replace&rdquo; but it is a lot more work.
<p>
<!-- ------------------------------- -->
<h3> 23 july 2019</h3>

<p>
 various bits of tidying up. Still can&apos;t accept input from standard-in 
 for some reason (program hangs and waits for console input)
<p>
<!-- ------------------------------- -->
<h3> 22 july 2019</h3>

<p>
 Implemented the swap instruction (x) to swap current tape cell
 and the workspace buffer.
<p>
 Fixed a bug in the get command which did not allocate
 enough memory for the stack/workspace buffer.
<p>
<!-- ------------------------------- -->
<h3> 20 july 2019</h3>

<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 Its all working more or less!. We can write
 </figcaption>
<pre class='codeline'>
 pep -f script.pss input.txt
</pre>
</figure>
<p>
 and the system compiles the script to assembler, loads it, and runs it
 against the input stream in input.txt. No doubt there are a number of bugs,
 but the general idea works.
<p>
 Made progress with &ldquo;asm.pp&rdquo;.
 Class blocks seem to be working.
 Some nested blocks now work. <code>Asm.pp</code> is at a useful stage. It
 can now compile many scripts. Still need to work out how
 to implement the -f switch (segmentation fault at the moment).
 In theory the process is simple... load asm.pp, run it on
 the script file (-f), then load <code>sav.pp</code> (output of asm.pp) and
 run it on the inputstream.
<p>
<!-- ------------------------------- -->
<h3> 19 july 2019</h3>

<p>
 Bug! When the program grows during loading a segmentation fault
 occurs.
<p>
 Created <code>test.commands.pss</code> which contains simple commands which
 can be parsed and compiled by the <code>asm.pp</code> script.
 <p>
 Also, realised that the compilation from assembler should stop
 with errors when an undefined instruction is found. Dealt with
 a great many warnings that arise when one uses &ldquo;gcc -Wall
<p>
&rdquo; implemented:
<p>
 command 'cc' adds the input stream character count to the 
 workspace buffer
 Also made an automatic newline counter, which is incremented
 every time a \n character is encountered. And the 'll'
 command which appends the newline counter as a string onto the 
 end of the workspace buffer.
<p>
 Since the main function of this parse-machine is to compile &ldquo;languages&rdquo; from
 a text source, the commands above are very useful because they allow the
 compilation script to give error messages when the source document is not in
 the correct format (with line number and possibly character count).
<p>
 Did some work on &ldquo;asm.pp&rdquo; which is the assembler file which 
 compiles scripts. Sounds very circular but it works.
 Realised that after applying bnf rules, need to jump back to
 the &ldquo;parse:&rdquo; label in case other previous rules apply.
<p>
<!-- ------------------------------- -->
<h3> 18 july 2019</h3>

<p>
 Discovered a bug when running <a href='https://bumble.sf.net/books/pars/asm.pp'>bumble.sf.net/books/pars/asm.pp</a> in 
<abbr class='tek-acronym' 
      title='The Unix Operating System'>UNIX</abbr> filter mode
 &ldquo;Abort trap: 6&rdquo; which means writing to some memory location
 that I should not be. Strangely, when I run the same script
 interactively (with &ldquo;rr") it works and doesnt cause the &rdquo; abort.
<p>
 Created a &ldquo;write&rdquo; command, on the machine, which writes the
 current workspace to a file called &ldquo;sav.pp&rdquo;.
 This has a parallel
 in sed (which also has a 'w' write command). This command 
 should be useful when compiling scripts and then running them
 (since they are compiled to an intermediate &ldquo;assembler&rdquo; phase,
 and then loaded into the machine).
<p>
 Made some progress to use the pattern-machine as a unix-style filter
 program. Added some command line options with getopt(). 
 The parser should be usable (in the future) like sed: eg
 <pre class='codeline'>
 cat somefile | pep -sf script.pp &gt; result.txt
</pre>

 or 
 <pre class='codeline'>
 cat somefile | pep -sa script.ppa &gt; result.txt
</pre>

<p>
 where script.ppa is an &ldquo;assembler&rdquo; listing which can be loaded into
 the machine.
<p>
<!-- ------------------------------- -->
<h3> 16 july 2019</h3>

 <p>
 Working on parsing with asm.pp. Seem to have basic commands 
 parsing and compiling eg: add &ldquo;this"; pop; push; etc&rdquo; Simple blocks are parsing and compiling.
 There are still some complications concerning the order of 
 shift-reductions.
 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 Made execute() have a return value e.g:
 </figcaption>
<pre class='codeblock'>

     0: success no problems
     1: end of stream reached
     2: undefined instruction
     3: quit/crash executed (exit script)
     4: write command could not open file sav.pp for writing
   </pre>
</figure>
<p>
 More work. Some æsthetic fixes to make it easier to see what 
 the machine is doing. Wrote showMachineTapeProgram() to give a nice
 view of pretty much everything that is going on in the machine at once.
 Working on how to collate &ldquo;attributes&rdquo; in the tape array register.
 Made an optional parameter to printSomeTape() that escapes \n \r etc
 in the tape cells which makes the output less messy.
<p>
<!-- ------------------------------- -->
<h3> 15 july 2019 </h3>

<p>
 A lot of progress. Starting to work on <code>asm.pp</code> again. Have
 basic shift-reduction of stack tokens working. Now to get
 the tape &ldquo;compiling&rdquo; attributes as well. 
<p>
 The bug seems to be: that JUMP is not treated as a relative
 jump by execute() but is being compiled as a relative jump
 by instructionFromText(). So, either make, JUMPs relative or ...
<p>
 Made the &ldquo;labelTable&rdquo; (or jumpTable) a property of the program.
 This is a good idea. Also made the command 'jj' print out the 
 label table. Still using &ldquo;jumptable&rdquo; phrase but this is not 
 a good name for this.
<p>
 I should organise this file: first structure definitions.
 rhen prototype declarations, and then functions. I haven&apos;t done
 this because it was convenient to write the function immediately
 after the structure def (so I could look at the properties). 
 But if I rearrange, then it will be easier to put everything in
 a header file, if that is a good idea.
<p>
 Lots of minor modifications. made searchHelp also search the 
 help command name, for example. Added a compileTime (milliseconds)
 property to the Program structure, and a compileDate (time_t).
 81 instructions (which is how many instructions in <code>asm.pp</code> at the 
 moment) are taking 4 milliseconds to compile. which seems pretty
 slow really.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 file sizes:
 </figcaption>
<pre class='codeblock'>

     pep.c 138430 bytes
     pep   80880 bytes (compiled c code)
   </pre>
</figure>
<p>
 Trying to eliminate warnings from the gcc compiler, which are actually
 very handy. Also seem to have uncovered a bug where the &ldquo;getJump 
&rdquo; function was actually after where it was used (and this <code>pep.c</code> does
 not use any header files, which is very primitive). So the 
 label jumptable code should not have been working at all...
 changing lots of %d to %ld for long integers. Also, on BSD unix
 the ansi colour escape code for &ldquo;grey&rdquo; appears to be black.
<p>
<!-- ------------------------------- -->
<h3> 13 july 2019</h3>

<p>
 Looking at this on an OSX macbook. The code compiles (with a number of 
 warnings) and seems to run. The colours in this bash environment are 
 different.
 <p>
<!-- ------------------------------- -->
<h3> 12 dec 2018</h3>

<p>
 After stepping through the <a href='https://bumble.sf.net/books/pars/asm.pp'>asm </a> program I discovered that
 unconditional jump targets are not being correctly encoded. This probably
 explains why the script was not running properly. Also I may put labels into
 the deassembled listings so that the listings are more readable.
<p>
<!-- ------------------------------- -->
<h3> 19 sept 2018</h3>

<p>
 Revisiting. 
 Need to create command line switches: eg -a &lt;name&gt; for loading
 an assembler script. and -f &lt;name&gt; to load a script file.
 Need to step through the <code>asm.pp</code> script and 
 work out why stack reduction is not working... (see above for
 the answer). An infinite
 loop is occurring. Also, need to write the treemap app for iphone
 android, not related to this. Also, need to write a script that
 converts this file and book files to an asciidoctor format for 
 publishing in html and pdf. Then send all this to someone more 
 knowledgeable.
<p>
<!-- ------------------------------- -->
<h3> 5 sept 2018</h3>

<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 file sizes
 </figcaption>
<pre class='codeblock'>

     pep.c 133423 bytes
     pep   78448 bytes
   </pre>
</figure>
<p>
 Would be handy to have a &ldquo;run until 10 more chars read&rdquo; function.
 This would help to debug problematic scripts. (note: these things 
 have all been implemented with the <em>pep -I" switch which means</em> <em>interactive</em> or really <em>debug</em>
<p>
 Segmentation fault probably caused by trying to &ldquo;put&rdquo; to 
 non-existant tape cell (past the end). Need to check tape size
 before putting, and grow the tape if necessary.
<p>
 Could try to make a palindrome parser. Getting a segmentation fault
 when running the <code>asm.pp</code> program right through. Wrote an INTERPRET 
 mode for testing- where commands are executed on the machine
 but not compiled into the current program. Wrote runUntilWorkspaceIs()
 and adding a testing command to invoke this. This should make is easier
 to test particular parts of a script. found and fixed a problem with
 how labels are resolved, this was cause by buildJumpTable() not ignoring
 multiline comments.
<p>
<!-- ------------------------------- -->
<h3> 4 sept 2018</h3>

<p>
 Made multiline comments <em><code class='nom-token'>(#*</code></em> ... <em>#) work in assembler scripts.  Made the</em> machine.delimiter character visible and used by push and pop in
 execute(). There is no way to set the delimiter char or the escape char
 in scripts
<p>
<!-- ------------------------------- -->
<h3> 3 sept 2018</h3>

<p>
 Added multiline comments to <code>asm.pp</code> (eg #* ... <em>#) as well</em> as single line comments with #.
 Idea: make <code>pep.c</code> produce internal docs in asciidoctor format
 so we can publish to html5/docbook/pdf etc.
 working on the <code>asm.pp</code> script. Made &ldquo;asm&rdquo; command reset the 
 machine and program and input stream. Added quoted text and
 comments to the <code>asm.pp</code> script parsing, but no stack parsing yet.
<p>
 Need to add multiline comments to the loadAssembledProgram() function.
 while and whilenot cannot use a single char: 
 eg: whilenot &ldquo;\n&rdquo; doesn&apos;t work. So, write 'whilenot [\n]' instead
 Also should write checkInstruction() called by 
 instructionFromText() to make sure that the instruction has 
 the correct parameter types. Eg: add should have parameter type
 text delimited by quotes. Not a list [...] or a range [a-z]
<p>
 If the jumptable is a global variable then we can test 
 jump calculations interactively. Although it&rsquo;s not really 
 necessary. Would be good to time how long the machine 
 takes to load assembler files, and also how long it takes
 to parse and transform files. 
<p>
<!-- ------------------------------- -->
<h3> 2 sept 2018</h3>

<p>
 wrote getJump() and made instructionFromText() lookup the label
 jump table and calculate the relative jump. It appears to be 
 working. Which removes perhaps the last obstacle to actually writing 
 the script parser. Need to make program listings &ldquo;page&rdquo; so I can
 see long listings.
<p>
<!-- ------------------------------- -->
<h3> 1 sept 2018</h3>

<p>
 writing printJumpTable() and trying to progress. Looking at
 Need to add &ldquo;struct label table[]&rdquo; jumptable parameter 
 to instructionFromText(), and compile().
 asciidoctor.
<p>
<!-- ------------------------------- -->
<h3> 31 aug 2018</h3>

<p>
 Continued to work on buildJumpTable. Will write printJumpTable.
 Renamed the script assembler to &ldquo;asm.pp
&rdquo; Made a bash function to insert a timestamp. Created an
 &ldquo;asm&rdquo; command in the test loop to load the <code>asm.pp</code> file into the program.
 Started a buildTable function for a label jump table. These
 label offsets could be applied by the &ldquo;compile&rdquo; function.
<p>
<!-- ------------------------------- -->
<h3> 30 august 2018</h3>

<p>
 &ldquo;pep.c&rdquo; source file is 117352 bytes.
 Compiled code is 72800 bytes. I could reduce this dramatically
 by separating the test loop from the machine code.
<p>
 Revisiting this after taking a long detour via a forth bytecode
 machine which currently boots on x86 in real mode (see
 <a href='http://bumble.sourceforge.net/books/osdev/os.asm'>bumble.sourceforge.net/books/osdev/os.asm</a> ) and then trying
 unsuccessfully to port it to the atmega328p architecture (ie arduino) at
 <a href='http://bumble.sf.net/books/arduino/os.avr.asm'>bumble.sf.net/books/arduino/os.avr.asm</a>
<p>
 The immediate task seems to be to write code to create a label
 table for assembly listings, and then use that code to replace
 labels with relative jump offsets. After that, we can start to write
 the actual code (in asm.pp) which will parse and compile scripts.
<p>
 So the process is: the machine loads the script parser code (in
 &ldquo;asm&rdquo; format) from a text file. The machine uses that program to
 parse a given script and convert to text &ldquo;asm&rdquo; format. The machine 
 then loads the new text asm script and uses it to parse and
 transform ("compile") an input text stream.
<p>
<!-- ------------------------------- -->
<h3> 20 dec 2017</h3>

 Allowed assembly listings with no line numbers as default. It 
 would be good idea to allow labels in assembly listings, eg 'here:' to
 make it easier to hand code assembly. So, need a label table. Look at
 the info arrays for the syntax... Made conditional jumps relative so
 that they would be easier to &ldquo;hand-code&rdquo; as integers (although labels
 are really needed). Also, need to add a loadAsm() function which is
 shorthand to load the script assembler. 
<p>
<!-- ------------------------------- -->
<h3> 17 december 2017</h3>

<p>
 For some reason, the code was left in a non compilable
 state in 2016. I think the compile() and instructionFromText()
 functions could be rewritten but seem to be working at 
 the moment.
<p>
<!-- ------------------------------- -->
<h3> 13 dec 2017</h3>

<p>
 The code is not compiling because the parameter to the &ldquo;compile()
&rdquo; function is wrong. When we display instructions, it would be good to
 always indicate the data type of the parameter (eg: text, int, range etc)
 Modify &ldquo;test&rdquo; to use different parameter types, eg list, range, class.
<p>
<!-- ------------------------------- -->
<h3> 29 september 2016</h3>

<p>
 used instructionFromText() within the compile() function and changed
 compile to accept raw instruction text (not command + arguments) wrote
 scanParameter which is a usefull little function to grab an argument up
 to a delimiter. It works out the delimiter by looking at the first char
 of the argument and unescapes all special chars. Now need to change
 loadAssembled to use compile(). 
<p>
<!-- ------------------------------- -->
<h3> 28 sept 2016</h3>

<p>
 Added a help-search <a href='/'><code>/</code></a> and a command help search //. Added escapeText() and
 escapeSpecial(), and printEscapedInstruction(). add writeInstruction() which
 escapes and writes an instruction to file. Added instructionFromText() and a
 test command which tests that function.
<p>
 Worked on loadAssembledProgram() to properly load formats such as &ldquo;while&rdquo; [a-z]" and &ldquo;while [abc\] \\ \r \t]&rdquo; etc. All this work is moving towards
 having the same parse routine loading assembled scripts from text files as
 well as interactively in the test loop.
<p>
<!-- ------------------------------- -->
<h3> 26 sept 2016</h3>

<p>
 Discovered that swap is not implemented.
<p>
<!-- ------------------------------- -->
<h3> 22 sept 2016</h3>

<p>
 Added loadlast, savelast, runzero etc. a few convenience functions
 in the interpreter. One hurdle: I need to be able to write
 testis &ldquo;\n&rdquo; etc where \n indicates a newline so that we can
 test for non printing characters. So this needs to go into the 
 machine as it&rsquo;s ascii code.
 Also, when showing program listings, these special characters
 \n \t \r should be shown in a different colour to make it 
 obvious that they are special chars...
 Also: loadprogram is broken at the moment.... need to deal
 with datatypes.
<p>
<!-- ------------------------------- -->
<h3> 21 sept 2016</h3>

<p>
 When in interpreter mode, reading the last character should not 
 exit, it should return to the command prompt for testing purposes.
<p>
<!-- ------------------------------- -->
<h3> 15 august 2016</h3>

<p>
 Wrote an &ldquo;int read&rdquo; function which reads one character from
 stdin and simplifies the code greatly. Still need to 
 fix &ldquo;escaping&rdquo;.
 need to make ss give better output, configurable
 Escaping in 'until' command seems to be working.
<p>
<!-- ------------------------------- -->
<h3> 13 august 2016</h3>

<p>
 Added a couple more interpreter commands to allow the 
 manipulation of the program and change the ip pointer. Now
 it is possible to jump the ip pointer to a particular 
 instruction. Also, looked at the loadAssembledProgram and
 saveAssembledProgram functions to try to rewrite them correctly.
 The loadAssembledProgram needs to be completely cleaned up
 and the logic revised. 
 My current idea is to write a program which transforms a <em>pep</em>
 script into a text assembly format, and then use the 
 'loadAssembledProgram' to load that script into the machine.
 Wrote 'runUntilTrue' function which executes
 program instructions until the machine flag is set to true (by
 one of the test instructions, such as testis testbegins, testends...
 This should be useful for debugging complex machine programs.
<p>
<!-- ------------------------------- -->
<h3> 7 jan 2016</h3>

<p>
 wrote a cursory freeMachine function with supporting functions
<p>
<!-- ------------------------------- -->
<h3> 4 jan 2016</h3>

<p>
 Tidying up the help system. Had the idea of a program browser,
 ie browse 'prog' subfolder and load selected program into
 the machine. Need to write the actual script compilation
 code.
<p>
<!-- ------------------------------- -->
<h3> 3 jan 2016</h3>

<p>
 Writing a compile function which compiles one instruction
 given command and args. changed the cells array in Tape
 to dynamic. Since we can use array subscripts with pointers
 the code hardly changes. Added the testclass test
 Made program.listing and tape.cells pointers with dynamic
 memory allocation.
<p>
<!-- ------------------------------- -->
<h3> 1 jan 2016</h3>

<p>
 Working on compiling function pointers for the character class tests with
 the while and testis instructions. Creating reflection arrays for class and
 testing.
<p>
<!-- ------------------------------- -->
<h3> late dec 2015</h3>

<p>
 Continued work. Trying to resolve all 
<abbr class='tek-acronym' 
      title='c memory allocation torture'>malloc</abbr> and 
<abbr class='tek-acronym' 
      title='more c memory torture'>realloc</abbr> problems. Using
 a program with instruction listing within the machine. Each command executed
 interactively gets added to this. 
<p>
<!-- ------------------------------- -->
<h3> 26 dec 2015</h3>

<p>
 Saving and loading programs as assembler listings.
 validate program function. &ldquo;until&rdquo; & &ldquo;pop&rdquo; more or less working.
 &ldquo;testends&rdquo; working ...
<p>
<!-- ------------------------------- -->
<h3> 19 dec 2015 </h3>

<p>
 Lots of small changes. The code has been polished up to an almost
 useable stage. The machine can be used interactively. Several
 instructions still need to be implemented. Push and pop need to be
 written properly. Need to realloc() strings when required. The info
 structure will include &ldquo;number of parameter fields&rdquo; so that the code
 knows how many parameters a given instruction needs. This is useful
 for error checking when compiling.
<p>
<!-- ------------------------------- -->
<h3> 16 dec 2015</h3>

<p>
 Revisiting this after a break. Got rid of function pointers, and
 individual instruction functions. Just have one executing function
 &ldquo;execute()&rdquo; with a big switch statement. Same with the test
 (interpreter) loop. A big switch statement to process user commands.
 Start with the 'read' command. Small test file. The disadvantage of not
 having individual instruction functions.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 individual command functions
 </figcaption>
<pre class='codeblock'>

    (eg void pop(struct Machine * mm) 
        void push(struct Machine * mm) etc) 
   </pre>
</figure>
<p>
 is that we cannot
 implement the script compiler as a series of function calls. 
 However the &ldquo;read&rdquo; instruction does have a dedicated function.
<p>
<!-- ------------------------------- -->
<h3> 23 feb 2015</h3>

<p>
 The development strategy has been to incrementally add small bits to the
 machine and concurrently add test commands to the interpreter.
<p>
<!-- ------------------------------- -->
<h3> 22 feb 2015</h3>

<p>
 Had the idea to create a separate test loop file (a command interpreter)
 with a separate help info array. show create showTapeHtml to print the
 tape in html. These functions will allow the code to document itself,
 more or less.
<p>
 Changes to make:
 The conditional jumps should be relative, not absolute. This will make
 it easier to hand write the compiler in &ldquo;assembly language&rdquo; . Line
 numbers are not necessary in the assembly listings. The unconditional
 jump eg jump 0 can still be an absolute line number.
 <p>
 Put a field width in the help output.
 Change help output colours. Make &ldquo;pep&rdquo; help command &ldquo;ls
&rdquo; <pre class='codeline'>
 make p.x -&gt; px or just "."
</pre>

<p>
<!-- ------------------------------- -->
<h3> 2009 </h3>

<p>
 Was working on a c version of this called &ldquo;chomski
<p>
&rdquo; <!-- ------------------------------- -->
<h3> 2006 - 2014</h3>

<p>
 Attempted to write various versions of this machine, in java,
 
<abbr class='tek-acronym' 
      title='Larry Wall's shell script language'>PERL</abbr> , c++ etc, but none was completed successfully
 see <a href='http://bumble.sf.net/pp/cpp'>bumble.sf.net/pp/cpp</a> for an incomplete implementation
 in c++. But better to look at the current version, which is 
 much much better.
<p>
<!-- ------------------------------- -->
<h3> 2005 (approximately)</h3>

<p>
 I started to think about this parsing machine while living in Almetlla de
 Mar. My initial ideas were prompted by trying to write parsing scripts in
 sed and then reading snippets of Compilerbau by N. Wirth, thinking about
 compilers and grammars
<p>

<p>

<div class='footer'><small><em>

<img style='border-radius:50%;width:10em;' class='center'  title='/image/fig.deniliquin.jpg' src='/image/fig.deniliquin.jpg'/>

retro html <a href='/eg/text.tohtml.format.html'>formatted </a> by <a href='/eg/text.tohtml.pss'>nom </a>
comments/suggestions to: <em>mjb at nomlang dot org</em> 
<p>

  </em></small></div></body></html>
