 

   <!DOCTYPE html>
   <html><head>
   <meta http-equiv='Content-type' content='text/html;charset=UTF-8' />
   <link rel='alternate' type='application/rss+xml'
     title='RSS Feed for Pep And Nom Blog' href='/rss.xml' />
   <title>Pep And Nom Blog</title>
   <!-- I will try to read this in with sed -->
   <style type='text/css'>
     


     body { 
       margin-left:5%; margin-right:5%; 
       padding:0; 
       color: #202122;

       /* need a darker grey color:gray; */
     }
     a { 
       text-decoration:none; 
       /* the wren.io link color */
       /* color: #3399cc; */
       color: #386acd;
       /* color:blue; */
     }
     a:hover { 
       /* color:darkblue; */
       color: #3056ad;
       border-bottom: 1px dashed blue; 
     }

     p { 
       margin-left:2em; margin-right:2em; 
       padding:0; 
     }

     /* used or 1st 2nd etc */

     sup.ordinal {
       text-decoration: underline;  
       color: darkgray;
       font-style: italic;
       text-transform: uppercase; 
     }

     h1.page-title { 
       text-align: center;
       color: peru; 
       /* brown colours: 
          siena,maroon,peru,goldenrod,chocolate,
          burlywood */
          
     }
     /* tan: a light brown */
     h1 { color: lightslategray; }
     /* make these headings capital case */
     h2 { 
       text-transform: capitalize; 
       color: lightslategray;
     }
     h3 { 
       text-transform: capitalize; 
       color: lightslategray; 
     }
     
     h3.blog-index-title { color: chocolate; }

     /* the date that is at the top of each blog post */
     h3.blog-post-date { color: darkkhaki; }
     
     div.footer { 
       text-align: center;
       color: goldenrod; 
       width: 100%;
       /* brown colours: 
          siena,maroon,peru,goldenrod,chocolate,
          burlywood */
     }

     /* a list of blog posts */
     dl.blog-index {
       margin-left: 2em;
     }

     /* a list of documents in a folder */
     dl.doc-index {
       margin-left: 2em;
     }
 
     /* a list within a list */
     ul.sublist {
       list-style-type: none;
     }
 
     /* an abbreviation like html, ast, xml */ 
     abbr.tek-acronym {
       border-bottom: 1px dashed purple; 
       text-decoration: none;
       text-transform: uppercase;
       /* font-style: italic; */
       font-size: 0.8em;
       *color: purple;
     }

     /* a one line description of a document  */
     em.doc-description {
       margin-left: 2em;
       color: lightslategray;
     }

     /* this is for pretty printing nom code. But I need lots 
        of span tags in the code. I copied this from the wren.io
        inspect element code snippet. <code> wrapped in <pre>
        in the html there is lots of 
          <span class="punctuation">.</span> etc
          and in the css .punctuation { color: #999; }

        Normal text is black/grey

        the pre has background color #f5f2f0 which is an offwhite
        here are the colours: 
          punctuation: #999 (grey)
          function eg 'print': #DD4A68 (red)
          string: #690 (green)
          keyword: #07A (aqua)
          operator eg '=' : #9a6e3a (brown)
        */

     /* start of pretty print css */

     pre.nom-code { 
       background-color: #f5f2f0;
       border-radius: 10px;
     }

     code.language-nom {
       font-family: Consolas, Monaco, monospace;
       text-align: left;
       white-space: pre;
       word-spacing: normal;
       word-break: normal;
       word-wrap: normal;
       line-height: 1.5;
     }

     span.nom-command { color: #9a6e3a;  /* brown */ }
     /* displaying unknown commands */
     span.nom-unknown { color: orange; }
     span.nom-error { color: red; } 
     span.nom-word { color: #09C; }
     span.nom-keyword { color: #07A; }
     span.nom-string { color: #690; }
     span.nom-class { color: #2A0; }
     span.nom-punct { color: #AAA; }
     span.nom-comment { color: gray; }
     span.nom-multiline-comment { color: gray; }
     
     /* end of pretty print css */

     /* displaying commands */
     code.nom-command {
       font-family: Consolas, Monaco, monospace;
       font-style: italic;
       font-size: 0.9em;
     }

     /* This is used for file names as well */
     code {
       font-family: Consolas, Monaco, monospace;
       font-size: 0.9em;
     }

     /* used for parse tokens in documents (text ending in *) */
     code.nom-token { 
       color: gray;
       font-size: 0.9em;
       font-style: italic;
     }

     /* a single line of code */
     pre.codeline { 
       margin-left:2em; 
       padding:0; 
     }

     figcaption.code-caption { 
       color: white;
       background-color: lightslategray; 
       #background-color: tan; 
       # background-color: sienna; 
       border-radius: 4px;
       padding-left: 1em; padding-bottom: 4px; padding-top: 4px;
       font-weight: normal; 
       width: 90% 
       /* border-bottom: 1px solid lightgrey; */
     }

     /* a centred element or image */
     .center {
        display: block;
        margin-left: auto;
        margin-right: auto;
        width: 50%;
     }

     /* an element which floats to the left */
     .float-left {
       float: left; 
       /*width: 10%; */
       text-align: center;
       font-style: italic;
       font-size: smaller;
       text-indent: 0;
       border-none;
       /* border: thin silver solid; */
       margin: 0.5em;
       padding: 0.5em;
     }

     /* an element which floats to the right */
    .float-right {
      float: right; 
      /*width: 10%; */
      text-align: center;
      font-style: italic;
      font-size: smaller;
      text-indent: 0;
      border: none;
      /* border: thin silver solid; */
      margin: 0.5em;
      margin-right: 3em;
      padding: 0.5em;
    }

    img.image-right {
      width: 100px;
    }
    img.image-left {
      width: 100px;
    }

    .chess-piece {
      /* background-color:#fff; */
      border:1px solid black;    
      border-radius:50%;
      font-size: 1.5em;
      padding: 5px;
    }

    /* this is for the big curly quotes before a <blockquote> quotation 
       html is <blockquote>text<cite>person</cite></blockquote> */
    blockquote.quotation {
      font-family: Georgia, serif;
      font-size: 18px;
      font-style: italic;
      width: 500px;
      margin: 0.25em 0;
      padding: 0.35em 40px;
      line-height: 1.45;
      position: relative;
      color: #383838;
    }

    blockquote.quotation:before {
      display: block;
      padding-left: 10px;
      content: "\201C";
      font-size: 80px;
      position: absolute;
      left: -20px;
      top: -20px;
      color: #7a7a7a;
    }

    blockquote.quotation cite {
      color: #999999;
      font-size: 14px;
      display: block;
      margin-top: 5px;
    }

    blockquote.quotation cite:before {
      content: "\2014 \2009";
    }
   </style></head>
   <body>

    
<p>
<p>


<p>
<!-- ------------ page title -------------------- -->
<h1 class='page-title'> &Popf;&eopf;&popf; ðŸ™´ &Nopf;&oopf;&mopf;</h1>

<a href='http://www.nomlang.org/'>home </a> |
<a href='/doc/'>documentation </a> |
<a href='/eg/'>examples </a> |
<a href='/tr/'>translators </a> |
<a href='/download/'>download </a> |
<a href='/post/index.html'>blog </a> |
<a href='/post/posts.html'>all blog posts </a> 
<img style='border-radius:50%;width:10em;' class='float-right'  title='/image/doodle/doodle.ink.ripples.300.square.jpg' src='/image/doodle/doodle.ink.ripples.300.square.jpg'/>



<p>


<blockquote class="quotation">
   As poor as a king without a poet.
 
<cite>Irish saying </cite>
</blockquote>
<p>

<p>
<p>
<!-- doclist= -->
<!-- doc=./doc/doc.grammar.txt -->
<p>
<!-- ------------------------------- -->
<h2> general notes about grammars and nom</h2>

<p>
 General notes about formal language grammars and nom.
<p>
 In the Medieval period in Europe the four pillars of education were
 Rhetoric, Logic, Theology and Grammar. Today this seems a strange 
 classification of knowledge and study, but Logic and Grammar are 
 the basis of computer science.
<p>
 I should state here that I am not a great formal-language theorist
 or high-level mathematician who can give insights into grammar 
 theory. This page is just a set of heuristic notes about things I 
 have discovered while parsing languages with the &Popf;&eopf;&popf; ðŸ™µ  &Nopf;&oopf;&mopf; system.
<p>
<!-- ------------------------------- -->
<h3> look ahead</h3>

<p>
 You can use the begins-with and ends-with modifiers to achieve token
 lookahead in [nom]. The script <a href='/eg/maths.parse.pss'>/eg/maths.parse.pss</a> and also
 <a href='/eg/maths.tolatex.pss'>/eg/maths.tolatex.pss</a> have good examples of using lookahead.
<p>
 The document <a href='/doc/howto/nom.lookahead.html'>/doc/howto/nom.lookahead.html</a> has detailed information
 about how to write lookahead into a <em>nom</em> script .
<p>
 There is also the <a title='nom syntax reference: peep' href='http://nomlang.org/doc/machine/pep.peep.html'>peep</a> register which provide a single 
 character look-ahead and which is not used directly by the script writer. 
 This register is used by the <code class='nom-command'><a title='nom command reference: while' href='http://nomlang.org/doc/commands/nom.while.html'>while</a></code> and <code class='nom-command'><a title='nom command reference: whilenot' href='http://nomlang.org/doc/commands/nom.whilenot.html'>whilenot</a></code> commands
 to read the input-stream only while the next character matches or 
 does not match the criteria given.
 <p>
<!-- ------------------------------- -->
<h3> associativity</h3>

<p>
 This is how we parse &ldquo;a + b + c&rdquo; ....
 Do we parse this as &ldquo;(a + b) + c&rdquo; (left-associative) or
 as &ldquo;a + (b + c)&rdquo; (right-associative)
<p>
 With <em>nom</em> we need to build this associativity into the grammar.
 See the <a href='https://bumble.sf.net/books/pars/eg/maths.parse.pss'>arithmetic parser </a> example for 
 an example of associativity (with +/- signs which associate right) .
<p>
<!-- ------------------------------- -->
<h3> precedence</h3>

<p>
 This is how we parse for example &ldquo;a + b * c&rdquo; We say that certain operators
 have <em>precedence</em> over others. Do we parse this as &ldquo;(a + b) * c&rdquo; ( '+'
 precedence ) or as &ldquo;a + (b * c)&rdquo; ( * precedence )
<p>
 Again, this has to be factored into the <em>nom</em> grammar. Its not that 
 difficult.
<p>
<!-- ------------------------------- -->
<h3> parser generators</h3>

<p>
 A <a href='https://en.wikipedia.org/wiki/comparison_of_parser_generators'>parser generator </a> is basically
 a way to avoid having to write a <a href='https://en.wikipedia.org/wiki/recursive_descent_parser'>recursive descent parser 
 </a> (and compiler) or some other style of 
 hand coded compiler. Lex, Yacc, Bison, Antlr and many others are 
 examples of parser generators and they seem to be widely used for 
 simple languages. An old example would be the <em>EQN</em> language for 
 formatting mathematical expressions. 
<p>
 <p>
<!-- ------------------------------- -->
<h3> kleene star</h3>

<p>
 The <em>kleene star</em> is a grammar construct which basically means
 &ldquo;zero or more of something&rdquo; . This exists in regular expressions 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 example kleene star in a sed regular expression
 </figcaption>
<pre class='codeline'>
 s/ab*c//
</pre>
</figure>
<p>
 This means: 'a' followed by zero or more 'b's followed by 'c'
 The same construct is used in 
<abbr class='tek-acronym' 
      title='Extended Backus-Naur Form'>EBNF</abbr> grammars (check!).
<p>
 The rule below means that &ldquo;A 'statement' is a 'keyword' followed&rdquo; by zero or more 'parameters' followed by a semi colon. 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 kleene star in ebnf grammar rule
 </figcaption>
<pre class='codeline'>
 statement = keyword parameter* ';' ;
</pre>
</figure>
 <p>
 How can we translate this into 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>&Nopf;&oopf;&mopf;</abbr> ? We cannot create a single 
 <a title='nom syntax reference: block' href='http://nomlang.org/doc/syntax/nom.syntax.block.html'>block</a> which represents the rule above but by using several
 blocks we can create a <em>nom</em> fragment which represents it.
<p>
 The code below represents a complete &ldquo;lexer&rdquo; and &ldquo;recogniser&rdquo; for
 statements as shown below. Notice that white-space is completely 
 ignored except in parameters. 
 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 example of statements recognised below
 </figcaption>
<pre class='codeblock'>

     say 'good'; fizz; bang 'crash' ;
     whirr 'ok' 'okay'; grow'big' 'small' 'tiny' ;
     bird
       'tweet' 'fly '
       'nest' ;
  </pre>
</figure>
 <p>
 The script that follows is a <em>recogniser</em> because it doesn&apos;t actually
 compile/transpile/transform the input text, it just determines if the input
 text consists of valid &ldquo;statements&rdquo;.
 Also notice, that the single 
<abbr class='tek-acronym' 
      title='Extended Backus-Naur Form'>EBNF</abbr> rule
 with a <em>kleene star</em> is broken up into 3 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>&Nopf;&oopf;&mopf;</abbr> <a title='nom syntax reference: block' href='http://nomlang.org/doc/syntax/nom.syntax.block.html'>blocks </a> (
 statements between braces ). 
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 equivalent ebnf rules as used by nom
 </figcaption>
<pre class='codeblock'>

    statement = keyword ';' ;
    statement = keyword parameter ';' ;
    statement = keyword parameterset ';' ;
    parameterset = parameter parameter ;
    parameterset = parameterset parameter ;
  </pre>
</figure>
<p>
 Although their are 5 ebnf rules above, 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>&Nopf;&oopf;&mopf;</abbr> only requires 3 
 blocks because it can use <em>OR logic</em> concatenation in the 
 tests (using the ',' comma character)
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 Ebnf rule with kleene star
 </figcaption>
<pre class='codeblock'>

  # "lexing"
  
  read; 
  # literal token, the character is also the parse-token
  ';' { add "*"; push; }
  [:space:] { while [:space:]; clear; }  
  [:alpha:] { while [:alpha:]; put; clear; add "keyword*"; push; }
  "'" { until "'"; put; clear; add "parameter*"; push; }
  !"" { 
    put; clear; 
    add "?? bad char ["; get; add "]\n";
    print; quit;
  }
 
  # The nom version of the ebnf rule
  #   statement = keyword parameter* ';' ;
  parse&gt;
    # show the stack reductions for debugging
    # add "line "; lines; add " char "; chars; add ": "; print; clear;
    # unstack; print; stack; add "\n"; print; clear;
    pop;
    pop;
    "keyword*;*" 
      { clear; add "statement*"; push; .reparse }
    "parameter*parameter*","paramset*parameter*" 
      { clear; add "paramset*"; push; .reparse }
    pop;
    "keyword*parameter*;*","keyword*paramset*;*" { 
      clear; add "statement!\n"; print;
      clip; clip; add "*";
      push; .reparse 
    }
    push;push;push;
  </pre>
</figure>
<p>
<!-- ------------------------------- -->
<h3> more kleene star analysis</h3>

<p>
 Take a simple regular expression and attempt to translate into <em>nom</em>
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 a none,one,or many asterisk in a regular expression
 </figcaption>
<pre class='codeline'>
 ab*c
</pre>
</figure>
<p>
 This needs to be recognised with a much more verbose <em>nom</em> script.
 The script below will no doubt seem ridiculously verbose, but 
 the strength of &Popf;&eopf;&popf; ðŸ™µ  &Nopf;&oopf;&mopf; is not in parsing regular languages.
<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 the equivalent in nom
 </figcaption>
<pre class='nom-code'><code class='language-nom'>

    <span class='nom-command'>read</span><span class='nom-punct'>;</span>
    <span class='nom-string'>"a"</span> <span class='nom-punct'>{</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"A*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>}</span>
    <span class='nom-string'>"b"</span> <span class='nom-punct'>{</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"B*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>}</span>
    <span class='nom-string'>"c"</span> <span class='nom-punct'>{</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"C*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>}</span>
    <span class='nom-punct'>!</span><span class='nom-string'>""</span> <span class='nom-punct'>{</span>
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"no"</span><span class='nom-punct'>;</span> <span class='nom-command'>print</span><span class='nom-punct'>;</span> <span class='nom-command'>quit</span><span class='nom-punct'>;</span>
    <span class='nom-punct'>}</span>
  <span class='nom-word'>parse</span><span class='nom-punct'>></span>
    <span class='nom-command'>pop</span><span class='nom-punct'>;</span><span class='nom-command'>pop</span><span class='nom-punct'>;</span>
    <span class='nom-string'>"B*B*"</span> <span class='nom-punct'>{</span> 
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span> 
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"B*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span>
    <span class='nom-punct'>}</span>
    <span class='nom-string'>"A*C*"</span> <span class='nom-punct'>{</span> 
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"pattern*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
    <span class='nom-punct'>}</span>
    <span class='nom-command'>pop</span><span class='nom-punct'>;</span>
    <span class='nom-string'>"A*B*C*"</span> <span class='nom-punct'>{</span> 
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>++</span><span class='nom-punct'>;</span> <span class='nom-command'>get</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>--</span><span class='nom-punct'>;</span> <span class='nom-command'>put</span><span class='nom-punct'>;</span>
      <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"pattern*"</span><span class='nom-punct'>;</span> <span class='nom-command'>push</span><span class='nom-punct'>;</span> <span class='nom-punct'>.</span><span class='nom-command'>reparse</span>
    <span class='nom-punct'>}</span>
    
    <span class='nom-punct'>(</span><span class='nom-word'>eof</span><span class='nom-punct'>)</span> <span class='nom-punct'>{</span>
      <span class='nom-punct'>!</span><span class='nom-string'>"pattern*"</span> <span class='nom-punct'>{</span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"no"</span><span class='nom-punct'>;</span> <span class='nom-command'>print</span><span class='nom-punct'>;</span> <span class='nom-command'>quit</span><span class='nom-punct'>;</span>
      <span class='nom-punct'>}</span>
      <span class='nom-string'>"pattern*"</span> <span class='nom-punct'>{</span>
        <span class='nom-command'>clear</span><span class='nom-punct'>;</span> <span class='nom-command'>add</span> <span class='nom-string'>"yes"</span><span class='nom-punct'>;</span> <span class='nom-command'>print</span><span class='nom-punct'>;</span> <span class='nom-command'>quit</span><span class='nom-punct'>;</span>
      <span class='nom-punct'>}</span>
    <span class='nom-punct'>}</span>
    <span class='nom-command'>push</span><span class='nom-punct'>;</span><span class='nom-command'>push</span><span class='nom-punct'>;</span><span class='nom-command'>push</span><span class='nom-punct'>;</span>

  </code></pre>
</figure>
<p>
<!-- ------------------------------- -->
<h3> parse token matching or recognising</h3>

<p>
 <em>Nom</em> can only match or recognise a fixed number of parse-tokens
 at any point in the script. This is because it needs to <code class='nom-command'><a title='nom command reference: pop' href='http://nomlang.org/doc/commands/nom.pop.html'>pop</a></code>
 the parse tokens off the <a title='nom syntax reference: stack' href='http://nomlang.org/doc/machine/pep.stack.html'>stack</a> before it can match
 parse token sequences.
<p>
 This is why ebnf rules in the form 
 <pre class='codeblock'>

   a = b+ c ;
   a = c b* ;
  </pre>

<p>
 need to be broken up into several 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>&Nopf;&oopf;&mopf;</abbr> blocks, because b+ and <em><code class='nom-token'>b*</code></em>
 represent a variable number of parse tokens.
<p>
<!-- ------------------------------- -->
<h3> recursive descent parsing</h3>

<p>
 LL grammars (same?)
<p>
 Although grammar theorists talk about all sorts of different types of
 parsing, in practice, the type of parsers that are written by jobbing
 programmers seem to be <em>recursive descent</em> . There is a very surprising
 statement on Robert Nystrom's blog that all compilers for modern languages in
 common use are recursive descent. Mr. Nystrom is involved in creating
 (designing?) the 
<abbr class='tek-acronym' 
      title='Google's Application Language'>DART</abbr> language and has written a great <a href='http://www.craftinginterpreters.com'>book
 </a> about parsing and compiling, so I am pretty
 convinced he knows what he is talking about. Recursive descent is also the
 type of parser/compiler that seems to be taught in University Comp-Sci
 courses. Nicholas Wirth of Pascal fame was a strong proponent of this type of
 parser/compiler.
<p>
 I don't wish to criticise recursive descent parsers, because they obviously
 work, but it does seem odd to me that this is still the main way to 
 recognise and translate formal-languages. 
<p>
 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>&Nopf;&oopf;&mopf;</abbr> does not do recursive descent parsing: in fact I wrote <em>nom</em> because
 I wanted a way to understand the grammars of language that was more 
 &ldquo;natural&rdquo; for my way of thinking. The 
<abbr class='tek-acronym' 
      title='Parsing Engine for Patterns'>&Popf;&eopf;&popf;</abbr> & 
<abbr class='tek-acronym' 
      title='Nom Parsing Language'>&Nopf;&oopf;&mopf;</abbr> system does 
 <a href='https://www.google.com/search?q=shift+reduce+parsing'>www.google.com/search?q=shift+reduce+parsing</a> but it does it purely as a (unix-style)
 text-stream filter. 
 <p>
 The &Popf;&eopf;&popf; ðŸ™µ  &Nopf;&oopf;&mopf; lexing/parsing/compiling process is as follows: 
 In the <em>lexical analysis</em> phase of the <em>nom</em> script, &Popf;&eopf;&popf; ðŸ™µ  &Nopf;&oopf;&mopf;
 <a title='nom command reference: read' href='http://nomlang.org/doc/commands/nom.read.html'>reads </a> the input stream (more or less) one Unicode character at a
 time, and creates parse-tokens and their &ldquo;attributes&rdquo; in a <a title='pep machine reference: workspace' href='http://nomlang.org/doc/machine/pep.workspace.html'>text buffer
 </a> . The parse-tokens are <a title='nom command reference: push' href='http://nomlang.org/doc/commands/nom.push.html'>pushed </a> onto a <a title='nom syntax reference: stack' href='http://nomlang.org/doc/machine/pep.stack.html'>stack</a>
 and the &ldquo;attributes&rdquo; (the partially compiled/translated text) are <code class='nom-command'><a title='nom command reference: put' href='http://nomlang.org/doc/commands/nom.put.html'>put</a></code>
 into the <a title='nom syntax reference: tape' href='http://nomlang.org/doc/machine/pep.tape.html'>tape</a> . Then, during the parsing or &ldquo;shift-reduce&rdquo; phase 
 of the script, the parse-tokens are <a title='nom command reference: pop' href='http://nomlang.org/doc/commands/nom.pop.html'>popped </a> off the stack
 back into the <code class='nom-command'><a title='nom command reference: workspace' href='http://nomlang.org/doc/commands/nom.workspace.html'>workspace</a></code> buffer. If a particular parse-token 
 sequence is <em>matched</em> or recognised, then the <em>workspace</em> is 
 <a title='nom command reference: clear' href='http://nomlang.org/doc/commands/nom.clear.html'>cleared </a> and the token attributes are <a title='nom command reference: get' href='http://nomlang.org/doc/commands/nom.get.html'>got </a> from the 
 <a title='nom syntax reference: tape' href='http://nomlang.org/doc/machine/pep.tape.html'>tape</a> and compiled and then <em>put</em> again onto the <em>tape</em> .
 Then the <em>workspace</em> (string) buffer is <a title='nom command reference: clear' href='http://nomlang.org/doc/commands/nom.clear.html'>cleared </a> and the 
 new parse-token is created in the workspace with the <code class='nom-command'><a title='nom command reference: add' href='http://nomlang.org/doc/commands/nom.add.html'>add</a></code> command.
 Finally, the new parse-token or tokens is <a title='nom command reference: push' href='http://nomlang.org/doc/commands/nom.push.html'>pushed </a> onto 
 the <em>stack</em> . 
<p>
 This entire process is <em>text-oriented</em> meaning that everything is 
 a &ldquo;string&rdquo; including the parse-tokens and the parse tokens and their
 attributes are manipulated in the same virtual <a title='nom syntax reference: machine' href='http://nomlang.org/doc/machine/pep.machine.html'>machine</a> with the 
 same commands.
<p>
<!-- ------------------------------- -->
<h3> recursion in grammars</h3>

<p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 Left recursive grammars
 </figcaption>
<pre class='codeblock'>

   E := E + E
   E := T
 </pre>
</figure>
<p>
<!-- ------------------------------- -->
<h3> grammar and script construction</h3>

<p>
 My knowledge of formal language grammar theory is quite limited. I am more 
 interested in practical techniques. But there is a reasonably close
 correlation between bnf-type grammar rules and &Popf;&eopf;&popf; ðŸ™µ  &Nopf;&oopf;&mopf; script construction.
 <p>
 The right-hand-side of a (E)BNF grammar rule is represented by the 
 quoted text before a brace block, and the left-hand-side 
 correlates to the new token pushed onto the stack.
 <p>
 <figure class='code-with-caption'>
<figcaption class='code-caption'>
 the rule "&lt;nounphrase&gt; ::= &lt;article&gt; &lt;noun&gt; ;" in a parse script
 </figcaption>
<pre class='codeline'>
 "article*noun*" { clear; add "nounphrase*"; push; }
</pre>
</figure>
<p>
<!-- ------------------------------- -->
<h3> terminology</h3>

<p>
 Terminology, 
 productions (same as rules?)
 terminals, non-terminals, tokens. Tokens are the same as 
 terminals? BNF backus-naur form
<p>
<!-- ------------------------------- -->
<h3> automatons</h3>

<p>
 There is a relationship between virtual machines, automatons and 
 grammars and formal languages.
<p>
 <a href='https://en.wikipedia.org/wiki/Deterministic_finite_automaton'>en.wikipedia.org/wiki/Deterministic_finite_automaton</a>
<div class='footer'><small><em>
<p>

<img style='border-radius:50%;width:10em;' class='center'  title='/image/fig.deniliquin.jpg' src='/image/fig.deniliquin.jpg'/>

retro html <a href='/eg/text.tohtml.format.html'>formatted </a> by <a href='/eg/text.tohtml.pss'>nom </a>
comments/suggestions to: <em>mjb at nomlang dot org</em> 
<p>
  </em></small></div></body></html>
