/* Javacript code generated by 'compile.javascript.pss' */
var pp = require('./Machine'); 
var mm = new pp.Machine(); 
script: 
while (mm.peep != null) {
  lex: { 
    /*
     exp.tolisp.pss
     
     Parsing positive integer/variable arithmetic expressions and attempting
     to reformat in a "lisp" (prefix/bracket syntax). This is a classic 
     elementary parsing problem. We need to construct the grammar so
     that it contains a "lookahead" token, in order to deal with the operator
     precedence dilemma.
     
     This was developed from the script books/gh/eg/exp.recogniser.pss
    
     This script could be extended by adding a power "^" operator and 
     some comparison operators (eg ==, <=, !=, >=, <, >). If we add
     pascal-style operators, then this grammar could form the basis of 
     a pl/0 implementation (although the actual grammar used would be 
     very different from the one written by Niklaus Wirth, because he 
     seemed more interested in LL parsers).
    
    GRAMMAR IMPLEMENTED
    
     This script represents a LR (scan-from-left, parse-from-right)
     bottom-up shift-reduce parse/translator.
    
     The script implements the following grammar (described in Wirths EBNF syntax,
     without the grouping (), optional [] or continuations {} symbols)
    
     "exp" below means expression. EOF means end of file.
    
     * script grammar
     ---------
       opmul = '*' | '/' .
       opadd = '+' | '-' .
       variable = 'a' | 'b' | ... | 'z' .
       number = '0' | '1' | '2' | ... | '9' .
       exp = number | variable .
       exp = exp opmul exp .
       exp = ( exp ) .
       exp = exp opadd exp EOF .
       exp opadd = exp opadd exp opadd .
       exp ')' = exp opadd exp ')' .
     ,,,,
    
     Examining this grammar, its seems to violate the ebnf rule that 
     rules can only have 1 identifier on the left-hand side. But in 
     any case, this seems a useful technique for implementing operator
     precedence with the parse machine.
    
    TESTING 
    
      * demonstrate operator precedence. 
      >> pp -f eg/exp.tolisp.pss -i "a+b*c*(d+e)"
      output:  (+ a (* (* b c) (+ d e))) 
    
      * test reformating of an arithmetic expression
      >> pp -f eg/exp.tolisp.pss -i "6 + (6+7*8)*var"
    
      * make a stand-alone executable of this expression parser/translator
      --------
        pp -f compilable.c.pss exp.tolist.pss > exp.tolist.c
        gcc -o exp.tolisp.exec -Lbooks/gh/object -lmachine -Ibooks/gh/object
      ,,,
    
      * run the stand-alone executable with input from "stdin"
      >> echo "a+b*c*(d+e)" | ./exp.tolisp.exec
      output:  (+ a (* (* b c) (+ d e)))
    
    LIMITATIONS
    
      This doesnt currently handle negative variables or numbers
      or non-integers. 
      
      If we include other operators with even higher precedence than
      "*" or "/" (for example, a power operator "^") then the grammar
      will become more complex.
    
    
    EXAMPLES 
    
     eg: (9+count*4) + var  * 2 
     eg: (var + 88) + 4 * 2 
    
    HISTORY
     
     22 august 2019
    
       Updating comments.
    
     14 august 2019
    
       This appears to be working as a "recogniser" of arithmetic
       expressions, with operator precedance and formats output 
       as a lisp expression. Also, the code produced by 
       compilable.c.pss appears to be compile and run correctly 
       (when "pp" doesnt throw a malloc segmentation fault while 
       creating the c code!).
    
    */
    mm.read();
    //mm.state();
    if ((mm.workspace == "+") || (mm.workspace == "-")) {
      mm.put();
      mm.workspace = '';
      mm.add("opadd*");
      mm.push();
    }
    if ((mm.workspace == "*") || (mm.workspace == "/")) {
      mm.put();
      mm.workspace = '';
      mm.add("opmul*");
      mm.push();
    }
    if ((mm.workspace == "(") || (mm.workspace == ")")) {
      mm.put();
      mm.add("*");
      mm.push();
    }
    if (mm.testClass('[0-9]')) {
      mm.whilePeep('[0-9]');
      mm.put();
      mm.workspace = '';
      mm.add("number*");
      mm.push();
    }
    if (mm.testClass('[a-z]')) {
      mm.whilePeep('[a-z]');
      mm.put();
      mm.workspace = '';
      mm.add("variable*");
      mm.push();
    }
    if (mm.testClass('[:space:]')) {
      mm.workspace = '';
    }
    // a trick to catch bad characters. 
    // better would be a !"text" syntax but this is not implemented
    // yet (aug 2019)
    if ((mm.workspace == "")) {
      break lex;
    }
    mm.add(" << incorrect character (at character ");
    mm.chars();
    mm.add(" of input). \n");
    mm.print();
    break script;
  }
  parse: 
  while (true) { 
    // The parse/compile/translate/transform phase involves 
    // recognising series of tokens on the stack and "reducing" them
    // according to the required bnf grammar rules.
    mm.pop();
    // resolve numbers to expressions to simplify grammar rules
    // add a preceding space to numbers and variables.
    if ((mm.workspace == "number*") || (mm.workspace == "variable*")) {
      mm.workspace = '';
      mm.add(" ");
      mm.get();
      mm.put();
      mm.workspace = '';
      mm.add("exp*");
      mm.push();
      continue parse;
    }
    //-----------------
    // 3 tokens
    mm.pop();
    mm.pop();
    // we dont need any look ahead here because * and / have 
    // precedence.
    if ((mm.workspace == "exp*opmul*exp*")) {
      mm.workspace = '';
      mm.add(" (");
      mm.tapePointer++;
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.get();
      mm.tapePointer++;
      mm.tapePointer++;
      mm.get();
      mm.add(")");
      if (mm.tapePointer > 0) mm.tapePointer--; 
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*");
      mm.push();
      continue parse;
    }
    if ((mm.workspace == "(*exp*)*")) {
      mm.workspace = '';
      mm.tapePointer++;
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*");
      mm.push();
      continue parse;
    }
    if ((mm.peep == null)) {
      if ((mm.workspace == "exp*opadd*exp*")) {
        mm.workspace = '';
        mm.add(" (");
        mm.tapePointer++;
        mm.get();
        if (mm.tapePointer > 0) mm.tapePointer--; 
        mm.get();
        mm.tapePointer++;
        mm.tapePointer++;
        mm.get();
        mm.add(")");
        if (mm.tapePointer > 0) mm.tapePointer--; 
        if (mm.tapePointer > 0) mm.tapePointer--; 
        mm.put();
        mm.workspace = '';
        mm.add("exp*");
        mm.push();
        continue parse;
      }
    }
    //-----------------
    // 4 tokens
    mm.pop();
    if ((mm.workspace == "exp*opadd*exp*opadd*")) {
      mm.workspace = '';
      mm.add(" (");
      mm.tapePointer++;
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.get();
      mm.tapePointer++;
      mm.tapePointer++;
      mm.get();
      mm.add(")");
      if (mm.tapePointer > 0) mm.tapePointer--; 
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*opadd*");
      mm.push();
      mm.push();
      continue parse;
    }
    if ((mm.workspace == "exp*opadd*exp*)*")) {
      mm.workspace = '';
      mm.add(" (");
      mm.tapePointer++;
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.get();
      mm.tapePointer++;
      mm.tapePointer++;
      mm.get();
      mm.add(")");
      if (mm.tapePointer > 0) mm.tapePointer--; 
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*)*");
      mm.push();
      mm.push();
      continue parse;
    }
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    if ((mm.peep == null)) {
      mm.pop();
      mm.pop();
      if ((mm.workspace == "exp*")) {
        mm.workspace = '';
        mm.add("Yes, its an expression! \n");
        mm.add("in lisp format: \n");
        mm.get();
        mm.add("\n");
        mm.print();
        mm.workspace = '';
        break script;
      }
      mm.push();
      mm.push();
      mm.add("no, not an expression. \n");
      mm.print();
      mm.workspace = '';
      break script;
    }
    break parse;
  }
} 
