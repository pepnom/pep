
#*
# print in blue with enscript
~color{0 0 1}

## maths.to.latex.pss

ABOUT 

 Translating arithmetic and logical numerical and symbolic expressions
 to latex.

 Parsing arithmetic and logical expressions and equations with numbers
 (decimals) and variables and the operators "+,-,/,*,^" and comparison
 operators <= >= == != <> 

 This parser handles assignement with := , logical comparison and 
 concatenation with && || AND and OR as well as numerical comparison
 with < <= etc It also contains function names like sqrt(...). 
 The script uses negative token lookahead, so that this script can 
 more-or-less be cut and paste into a language parser/compiler to 
 handle the parsing of expressions (although some modifications may
 be necessary, depending on the syntax of the language).

 This is a significant development and rewrite of the script eg/exp.tolisp.pss
 where I parse the arithmetic and logical infix expression. I will try to add
 functions like sqrt() for square-root and I will try to make the 'lookahead'
 code better so that it can be used in any language expression parser.

 The expression parser also includes its own error handling and help system
 where each topic has a help text. These help texts can be combined 
 with categories. (see the maths.help* token)

NOTES

 This script is now a template for how to write scripts. It has 
 error token throwing with a built in help system.

 numbers and variable names are resolving nicely to expressions
 even before new tokens because I used a negative lookahead test.

DONE

  Made the lookahead code better. Ie use negative testing for 
  operator precedence. eg if x+y not followed by * or / or ^ then 
  reduce. See file:///doc/howto/nom.lookahead.html for an example
  of this. This also simplified the code

  Added "functions" like sqrt tan cos etc.  
  eg: sqrt(x + y)

  added :var for symbols like \\theta etc 

  The sigma sum from 0 to infinity. 
  Added symbols eg " :theta " ":infinity"

  Added 2 arg functions like sum() eg sum(expr* , expr*);

  make assignments reduce with look ahead (eg in brackets or ended 
  with comma). need to preserve lookahead token.

  A +/- symbol with ':plusminus'

  removed brackets from fraction parts with nom://clip and nom://clop

TODO

  Allow compare and logical expression at eof (convert to equation?)

  Allow 4*a*c to be rendered as '4ac'

  decide how to render logical and/or

  \[ e^x = \sum_{n=0}^{\infty} \frac{x^n}{n!} \]
  \[ \Gamma(x) = \int_0^\infty t^{x-1} e^{-t} \, dt \quad

STATUS 

  14 mar 2025: 
    working quite well, has functions, symbols,
    one bug with the new lookahead reductions of assignments
    and maybe op.compare. This allows x:=3, or x:=4) to reduce

TOKENS 

  literal tokens: 
    ( )  grouping
    . 
    ;    end of expression
    = 
    ,    for functions that need several tokens
    :    :var for symbols like greek letters etc.

  expr* an arithmetic expression
  equation* an expression terminated with ';' 
  equationset* just a list of equations. 
  natnum* a natural number [0-9]
  decnum* a positive decimal number
  op.and* for logic '&&' or 'AND'
  op.or* for logic '||' or 'OR'
  op.compare < <= > >= == != <> comparison operators
  op.power* '^'
  op.mul* either * or / but what should be the precedence here?
  op.add* either +/-
  variable* any variable name
  function* a function name like 'sqrt' or 'squareroot'
            functions are written sqrt(...)
  sign* either +/- but only preceeding an expression
  #lits: ().;=,:
  # expr* natnum* decnum* op.compare* op.power* op.mul* op.add* sign* 
  # variable* function*

NOTES
  
  When implementing lookahead with pep/nom it is better to use 
  a "negative" approach, i.e. say "if this sequence is NOT followed
  by token x (which has higher precedence) then reduce, otherwise
  dont.

  
  Negative variables I think are not implemented but this would
  be trivial. 4x 10size (implicit multiplication of variable)
  is also not implemented. Space is ignored so all expressions and 
  equations can span multiple lines.

TESTING 

  * view latex output
  >> pep -f eg/maths.tolatex.pss -i "-0.21*(0.33+e^(x+y))"

  * render the quadratic formula into pdf
  ------
    pep -f eg/maths.tolatex.pss \
        -i ' x==(-b :plusminus sqrt(b^2-4*a*c))/(2*a);' > test.tex
    pdflatex test.tex; open test.pdf
  ,,,

  * generate pdf and view
  -------
    pep -f eg/maths.tolatex.pss -i "10^x/10^(x+1)*(3.15+e^3)" > test.tex
    pdflatex test.tex; open test.pdf
  ,,,

  * demonstrate operator precedence. 
  >> pep -f eg/maths.tolatex.pss -i "a+b*c*(d+e^2)"

  * test reformating of an arithmetic expression
  >> pep -f eg/maths.tolatex.pss -i "6 + (6+7*8)*var"

EXAMPLES 

 assignments, logic and/or, comparisons, functions, variables.

 * negative and decimal number
 >> (-4+3)*6.1/-0.77777

 * logical expression and comparisons
 >> (4+x^2 == y^3) AND (x != y);

 * multiple equations and comparisons
 >>  x+1 > sqrt(1*2*3); y^2+x^2 ; 

 * variable names and functions
 >> (9*count^4) + var * sqrt(123.456+x/3)

 eg: (var + 88) + -44.33 * 2 
 eg: x := (x^2 && (y^2 != 100));

HISTORY
 
 17 mar 2025
   added equationset* token for multiple equations. 
 14 mar 2025
   added logic operators and parse tokens op.and* op.or* and 
   comparison operators with op.compare* token. also ';' equation*
   (which is expression terminated with ';') also added ',*' for 
   functions like sum(0,x) sigma sum.

 13 mar 2025
   converted from eg/exp.tolisp.pss

*#

  # The script lexing phase

  read;

  # spaces are actually significant because they cannot occur in
  # decimal numbers, eg: '4. 03' is probably an error
  # make character counter relative to each line for more helpful
  # error messages
  [\n] { nochars; } 
  [:space:] { 
    clear;
    !(eof) { .restart }
    (eof) { .reparse }
  }

  # literal token lexing

  # ; is end of an expression/equation this is needed to reduce
  #   comparison operators.
  [;] { put; add "*"; push; .reparse }
  # for functions, eg binomial
  [,] { put; add "*"; push; .reparse }
  
  # todo add % as modulus
  [<>:!=|&] { 
    while [<>:!=|&]; put; 
    # this is use for 'assignment'
    ":=" { clear; add "="; put; clear; add "=*"; push; .reparse }
    "&&" { clear; add " \\& "; put; clear; add "op.and*"; push; .reparse }
    "||" { clear; add " | "; put; clear; add "op.and*"; push; .reparse }

    # for symbols like theta
    ":" { add "*"; push; .reparse }
    #"&&" { clear; add " \\land "; put; clear; add "op.and*"; push; .reparse }
    #"||" { clear; add " \\lor "; put; clear; add "op.and*"; push; .reparse }

    "<","<=",">",">=","==","!=","<>" {
      # synonyms
      "==" { clear; add " = "; }
      "<=" { clear; add " \\leq "; }
      ">=" { clear; add " \\geq "; }
      "<>","!=" { clear; add " \\neq "; }
      put; clear; add "op.compare*"; 
      push; .reparse
    }
    clear; add "operators"; swap; ++; put; --;
    clear; add "maths.help*"; push;
    add "  unknown operator '"; get; add "'\n"; 
    put; clear; add "maths.error*"; push; .reparse
  }

  # plus and minus
  "+","-" { put; clear; add "op.add*"; push;  }
  # multiply and divide
  "*","/" { 
    "*" { clear; add " \\times "; } 
    put; 
    clear; add "op.mul*"; push;
  }

  # to the power of, but what is the lisp power operator ???
  "^" { clear; add "^"; put; clear; add "op.power*"; push;  }
  # brackets for grouping
  "(" { 
    # it useful to have a line and char for extra
    # opening brackets.
    clear; add " near line:"; lines; add " char:"; chars; put; 
    clear; add "(*"; push; 
  }
  ")" { put; add "*"; push; }
  # for decimal number
  "." { put; clear; add "dot*"; push; }
  [0-9] {
    while [0-9]; put; 
    clear; add "natnum*"; push;
  }
  # What characters are variable names ?
  [:alpha:] {
    while [:alpha:]; put; 
    # sum is a sigma sum eg \\sum{0,x}
    #"AND" { clear; add " \\land "; put; clear; add "op.and*"; push; .reparse }
    #"OR" { clear; add " \\lor "; put; clear; add "op.or*"; push; .reparse }
    "AND" { clear; add " \\& "; put; clear; add "op.and*"; push; .reparse }
    "OR" { clear; add " | "; put; clear; add "op.or*"; push; .reparse }
    "sqrt","squareroot","cuberoot","4throot","5throot","nthroot",
    "tan","cos","cosine","sin","sine","sec","cosec","cot",
    "sum","binomial" {
      # need to take care these replacements wont interfer with
      # each other
      replace "cosec" "csc"; 
      replace "cosine" "cos"; replace "sine" "sin";
      replace "squareroot" "sqrt"; replace "cuberoot" "sqrt[3]"; 
      replace "4throot" "sqrt[4]"; replace "5throot" "sqrt[5]"; 
      replace "nthroot" "sqrt[n]"; 
      replace "sum" "sum_"; 
      replace "binomial" "binom"; 
      put; clear; add "\\"; get; put;
      clear; add "function*"; push; .reparse
    }
    clear; add "variable*"; push;
  }

  # a trick to catch bad characters. 
  # better would be a !"text" test
  !"" { 
    put; 
    clear; add "characters"; swap; ++; put; --;
    clear; add "maths.help*"; push;
    add "  strange character '"; get; add "' encountered."; put; 
    clear; add "maths.error*"; push; .reparse
  }

parse>
  # The parse phase 

  # watch the stack at is parses: very helpful for debugging.
  # Comment out when the script works.fk
  add "% line "; lines; add " char "; chars; add ": "; print; clear; 
  unstack; print; stack; add "\n"; print; clear;

  # ----------------
  # the error and help system

  # we can group all error analysis here to make the script more 
  # organised. This section helps to provide good error messages to
  # the user.

  pop;

  #*
   Using a help* token to allow the script to document itself.
   The swap commands below are used to save the help text in the tape
   cell so that several or all help topics can be printed at once.

  *#

  "help*" {
    # does json have comments to wrap this in? 
    clear; swap; 
    
    # how to use this script
    "usage","help","all" {
      swap; add "
    USAGE
      pep -f json.check.pss file.json
      pep -f json.check.pss -i '[1,2,3,]'

      A nom script to check the syntax of JSON text data input 
      ";
      swap;
    }

    # help about the help-system
    "words","usage","help" {
      swap; add "
    HELP KEYWORDS

      All JSON documents/input which begin with '/' are considered to be help 
      requests. See below for the list of valid help keywords.

      pep -f json.check.pss -i /<helpword> 
        see some help for that topic or category

      pep -f json.check.pss -i /words
        see what help topics and categories are available for this script.

      pep -f json.check.pss -i /help
        see all the help.

      pep -f json.check.pss -i /toperl | bash
        translate this script to perl 
        
    ### General Help 
      - /usage: show a usage message for this script 
      - /words: show what help commands are available
      - /faq: show an FAQ about this script.
      - /nom: show information about the nom script language
    ### About the JSON format 
      - /flaws: known limitations with how this script parses JSON
      - /format: show summary information about the JSON text format.
    ### About testing this script
      - /eg.lines: prints a set of one line JSON documents that should 
         be accepted by this recogniser script. These can be used by
         other test words.
      - /eg.bad.lines: a set of one-liners that should be rejected.
      - /test.line: tests one random one-line JSON document.
      - /test.bad.line: tests one random one-line invalid JSON document.
      - /test: test the script with a document

      The 'test' and 'to' words need to be piped to bash to actually 
      execute.

    ### About translating this script

      - /translate: show how to translate this script to another language
      - /to<lang>: translate this script to some other language
          using the nom translation scripts at www.nomlang.org/tr/ 
           ( rust|dart|perl|lua|go|java|javascript|ruby|python|tcl|c) 
           (eg: /toperl /tolua etc). Or latex/pdf/html 

      Also see the /test.line help word for testing translated scripts

      There are also help 'categories' which display several help
      topics at once such as:

      - /usage: script usage and helpwords
      - /format: all information about the JSON format 
      - /help: show all available help topics.

      ";
      swap;
    }

    # the faq 
    "FAQ","faq","help" {
      swap; add "
    FAQ
      (not) frequently asked questions about /eg/json.check.pss

      Q: What does this script do?
      A: It checks the syntax of JSON data 

      Q: What is JSON? 
      A: Its sort of a text-data thingy with curly braces and lots
         of quotes. It probably better that JSON
      
      Q: Why does this script have its own FAQ?
      A: A question about a set of questions? How interesting! 
       
      Q: Should I use this instead of 'jq'
      A: No, not really. I think it runs quite fast, but 'jq' is a lot
         faster, even when I compile this script with 'go' or 'rust'.
         Also, this script is more of a demonstration than a serious 
         JSON recogniser.

      ";
      swap;
    }
       
    # more information about the nom language 
    "nom","about","help" {
      swap; add "
        This script is written in the 'nom' language which is a 
        manifestation of the pep:nom parsing system.

        Nom is a scripting language for parsing/translating context-free and 
        (some) context-sensitive patterns. Please see www.nomlang.org for
        (much) more information.
      ";
      swap;
    }

    # standard help word. produce a valid json document which 
    # can be used to test the script with /test
    "eg" {
      swap; add '
      [
        { "name":"tolstoy", "job":"writer"},
        { "name":"obama", "favourite numbers": [0, 3.1517, 42]},
        { "name":"saramago", "age": 21}
      ]
      '; 
      replace "\n  " "\n";
      swap;
    }

    # This help word should be standard so that a script like 
    # /eg/nom.to.pss can call it and test any script
    "eg.lines" {
      swap; add '
        # a simple object
        { "name":"tolstoy", "job":"writer"}
        # object with array
        { "name":"obama", "favourite numbers": [0, 3.1517, 42]}
        { "name":"saramago", "age": 21}
        [-0.00123E+001, 1, "time", "space", [0,0],[1,[2,3]]]
        {"space":-3.22E+20,[{"a":1,"b":2},"when","why"]}
      '; 
      replace "\n       " "\n";
      swap;
    }

    # Erroneous json data that should be caught be the checker.
    "eg.bad.lines" {
      swap; add "
        # unquoted text
        ['a','b',c]
        # duplicated comma in array
        ['a',,'b']
      ";
      swap;
    }

    # tests one one-line JSON doc with this script
    "test.line" {
      swap; add "
        # TESTING SOME RANDOM (one-line) JSON INPUT
        doc=$(pep -f json.check.pss -i /eg.lines | \\
          sed '/^ *#/d;/^ *$/d;' | shuf -n 1) 
        echo \"test-line: $doc\"
        pep -f json.check.pss -i \"$doc\" 
        echo \"test-line: $doc\"
        # ------------------------
        # RUN THIS WITH:
        # pep -f json.check.pss -i /test.line | bash
        ";
      replace "\n     " "\n";
      swap;
    }

    # tests one one-line invalid JSON doc with this script
    "test.bad.line" {
      swap; add "
        # TESTING SOME RANDOM (one-line) JSON INPUT
        doc=$(pep -f json.check.pss -i /eg.bad.lines | \\
          sed '/^ *#/d;/^ *$/d;' | shuf -n 1) 
        echo \"test-line: $doc\"
        pep -f json.check.pss -i \"$doc\" 
        # ------------------------
        # RUN THIS WITH:
        # pep -f json.check.pss -i /test.line | bash
        ";
      replace "\n     " "\n";
      swap;
    }

    # tests json input doc with this script
    "test" {
      swap; add "
        # TESTING JSON INPUT from /eg
        pep -f json.check.pss -i /eg | sed '/^ *#/d;' > test.json
        echo \"input: $doc\"
        pep -f json.check.pss test.json 
        # ------------------------
        # RUN THIS WITH:
        # pep -f json.check.pss -i /test | bash
        ";
      replace "\n     " "\n";
      swap;
    }

    # just call the /eg/nom.to.pss script which does translation from
    # a simple command like 'translate script.pss to ruby'
    # >> pep -f json.check.pss -i /to<lang> | bash
    B"to" {
      clop; clop; put; clear;

      add '
       translator=${PEPNOM}/eg/nom.to.pss
       if [ -f $translator ]; then
         echo -e "[ok] Found translator script: $translator"
       else
         echo -e "
          [error] did not find translator: \\${PEPNOM}/eg/nom.to.pss
          (maybe) set the $PEPNOM environment var
          (or)    download the translator from www.nomlang.org/eg/ 
          ";
         exit 1;
       fi
       pep -f $translator -i "translate json.check.pss to '; get; add '" | bash
       # RUN THIS WITH:  
       #   pep -f json.check.pss -i /to'; get; add ' | bash
       ';
       replace "\n    " "\n";
       print;
       quit;
    }

    # how to translate this script to another language, 
    "translate","tr","about","help" {
      swap; add "

     HOW TO TRANSLATE THIS SCRIPT

       This script can be translated to other languages using nom 
       translation scripts which are available at www.nomlang.org/tr/

       current (aug 2025) translation languages:
         all languages: all
         code languages: 
           rust|dart|perl|lua|go|java|javascript|ruby|
           python|tcl|c
         formats: html|pdf|latex

       * translate to ruby with /eg/nom.to.pss
       >> pep -f /eg/nom.to.pss -i 'translate json.check.pss to ruby' | bash

       * translate itself to java with the help word '/to' (needs /eg/nom.to.pss)
       >> pep -f json.check.pss -i /tojava | bash

       * format the script as colourised pdf (needs xelatex) 
       >> pep -f json.check.pss -i /topdf | bash

       * translate 'by-hand' to rust, compile and run (needs 'rustc')
       ---
         pep -f tr/nom.torust.pss json.check.pss > json.check.rs
         rustc -o texttohtml.exe texttohtml.rs
         echo ' some *strong* text ' | ./texttohtml.exe 
       ,,,

       * translate a script to perl, and run with 'doc.txt' as input
       ---
         pep -f nom.toperl.pss json.check.pss > test.pl 
         chmod +x test.pl
         cat doc.txt | ./test.pl
       ,,,

      ";
      swap;
    }

    # Format can be regarded as a 'category'. So more than one help 
    # topic will be printed
    B"flaw",B"fault","format","help" {
      swap; add "
     SCRIPT FLAWS as of aug 2025: 
    
      - is a member a valid doc? 
      - are single quotes valid in json?
      - doesnt recognise unicode escape sequences
      - completely ignores white-space outside of quotes (which
        may be ok, I am not sure)

      ";
      swap;
    }

    # json array format 
    "arrays","format","help" {
      swap; add '
      JSON ARRAYS
        Arrays are delimited by square brackets and may contain
        any other element (and nested elements)
        eg: [1,"name",{"a":1.2,"b":0.3},0]
      ';
      swap;
    }
    # json number format 
    "numbers","format","help" {
      swap; add "
      JSON NUMBERS
        Json numbers may be in scientific format +/- decimal 
        etc.
        eg: -0.123
      ";
      swap;
    }
    
    swap;
    "" {
      add "Help topic '/"; get; add "' not known\n";  
      add "Type: pep -f json.check.pss -i /words \n";
      add "  to see valid help keywords";
    }
    add "\n\n"; print; quit; 
  }

  "maths.error*" {
    # get the parse stack here as well
    clear; 
    add "--maths.tolatex.pss-- (convert maths expression to LaTeX)\n";
    add "near line:"; lines; add " char:"; chars; add "\n";
    get; add "\n"; 
    # indent the error message 
    replace "\n" "\n  "; add "\n"; print;
    print;
    # provide help from the maths.help* token if one was 
    # put on the stack. 
    clear; pop; "maths.help*" { push; .reparse } 
    quit;
  }

  # using a parse token to display help
  "maths.help*" {
    # the topic or category to display help for is in the
    # attribute
    clear; swap; 
    # 'brackets' is topic, 'all' is a categories

    "functions","all" {
      swap; add "
      functions are predefined words applied to an expression. 
      like 'tan' 'cos' 'sin' 'sqrt' 'cuberoot' '4throot'
      eg:
         sqrt (3^4+1)    correct
         sqrt 5          incorrect ";
    }

    "variables","all" {
      swap; add "
      variables are any alphabetic name that is not a function
      such as x abc longVar etc
      eg:
         var        correct
         var.var    incorrect ";
    }

    "characters","all" {
      swap; add "
      legal characters for expressions 
        arithmetic: ^+-*/
        comparison: < <= > >= == != <>
        logic: && || AND OR
        grouping: ()
        numbers: [-+0-9.]
        equations: := ;  (assignment and termination)
        names: any alphabetic character (for functions and variables)
        whitespace: is ignored.
      eg:
         3*size+2^0.5;    correct
         time := (sin(x) > sin(y));    correct
         4#+3            incorrect (# is not a recognised operator) ";
    }

    "operators.summary","operators","all" {
      swap; add "
      Recognised operators are:
        comparison: <= < >= > == != <>
        arithmetic: + - * / ^
        logic: && || AND OR
        grouping: ( ) ";
    }

    "assignment.operator","operators","all" {
      swap; add "
      The assignment operator is ':=' and the left-hand-side
      must be a simple variable name. Assignments must end in a 
      semicolon.
      eg:
         x := y^2+z^2;         correct";
    }

    "logic.operators","operators","all" {
      swap; add "
      The logic operators are && || 'AND' 'OR'
      AND and OR (uppercase) are synonyms for && and ||
      eg:
         && 2*x          incorrect";
    }

    "compare.operators","operators","all" {
      swap; add "
      The comparison operators are <= < >= > == != <>
      != means not equal to and '<>' is a synonym for that
      eg:
         
         (x==4) AND (x^2 != y)   correct (expression)
         sqrt(x+y^2) == x+y*3;   correct (equation)
         == 2*x                  incorrect";
    }

    "operators","all" {
      swap; add "
      Operators must be between numbers or expressions. 
      The exception to this are +/- signs which can precede
      expressions
      eg:
         4^3*(3+1)       correct
         -(4^2) + +3.1   correct
         /4+3            incorrect ";
    }

    "multiply.and.divide","operators","all" {
      swap; add "
      Multiplication is indicated by the asterisk '*' and division
      by the forward-slash '/' character. These characters must be 
      placed between 2 'expressions' (any combination of operators,
      variables and functions). The mathematical syntax 
      '4x+3y' is not implemented so far - i.e implicit multiplication 
      (but why not?)
      eg:
         4*3/(1.234 ^ 6)   correct
         -(3+2/)         incorrect (divide with no right expression) ";
    }

    "power.operator","all" {
      swap; add "
      The power operator is ^ and must occur between 2 numbers 
      or expressions
      eg:
         12.345^(1/2)    correct (square root)
         ^4              incorrect ";
    }

    "brackets","all" {
      swap; add "
      brackets () are used to group expressions and must be 
      balanced
      eg: 
        ((5.1+3)*10.0)*6^2      correct 
        (5.1+3)*10.0)*6^2       incorrect (extra close bracket) ";
    }

    "dots","all" {
      swap; add "
        The dot (.) is only used in positive and negative decimal
        numbers. I believe that decimals with no leading 0 are not permitted
        I may change this.
        egs: 5.13 -0.1234 +456.78 0.05";
    }
    "power","all" {
      swap; add "
        The power operator is '^' and has greater precedence
        than all other operators.
        eg: 5/6^2+2 will parse as ((5/(6^2))+2) ";
    }
    add "\n\n"; print; quit; 
  }
  # ----------------
  # 2 token errors
  pop;

  # look for tokens that can't start a sequence
  B")*".!")*" {
    clear; add "brackets"; put;
    clear; add "maths.help*"; push;
    add "  extra close bracket ) in expression?"; put; 
    clear; add "maths.error*"; push; .reparse
  }

  # literal token errors

  B"dot*".!E"natnum*" {
    clear; add "dots"; put;
    clear; add "maths.help*"; push;
    add "  Misplaced dot or incorrect decimal number ? ";
    put; clear; add "maths.error*"; push; .reparse
  }

  E"dot*".!B"natnum*" {
    clear; add "dots"; put;
    clear; add "maths.help*"; push;
    add "  Misplaced dot (eg .123 is not implemented) ? ";
    put; clear; add "maths.error*"; push; .reparse

  }

  # the not equals test is superfluous but here for clarity
  B"(*".!"(*" {
    E"op.mul*",E"op.power*",E")*" {
      clear; add "brackets"; put;
      clear; add "maths.help*"; push;
      add "  misplaced bracket or operator? ";
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  # lits: ().=;:
  # expr* natnum* decnum* op.compare* op.power* op.mul* op.add* sign* 
  # variable* function*

  # op.compare <= >= == != <> 
  # needs more thought
  B"op.compare*".!"op.compare" {
    E"op.mul*",E"op.power",E")*",E".*" {
      clear; add "operators"; put;
      clear; add "maths.help*"; push;
      add "  Misplaced operator ? ";
      put; clear; add "maths.error*"; push; .reparse
    }
  }


  # look for sequences
  B"op.add*".!"op.add" {
    E"op.mul*",E"op.power",E")*" {
      clear; add "operators"; put;
      clear; add "maths.help*"; push;
      add "  Misplaced operator ? ";
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  # allow ** as power?
  B"op.mul*".!"op.mul*" {
    E"op.add",E"op.power",E")*" {
      clear; add "operators"; put;
      clear; add "maths.help*"; push;
      add "  Misplaced operator ? ";
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  B"op.power*".!"op.power*" {
    E"op.add",E"op.power*",E"op.power",E")*" {
      clear; add "power.operator"; put;
      clear; add "maths.help*"; push;
      add "  Misplaced operator or bracket? ";
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  #lits: ().
  # expr* natnum* decnum* op.compare* op.power* op.mul* op.add* sign* 
  # variable* function*

  B"natnum*".!"natnum*" {
    E"expr*",E"natnum*",E"decnum*",E"(*" {
      clear; add "  missing operator?"; put;
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  B"decnum*".!"decnum*" {
    E"expr*",E"natnum*",E"decnum*",E"(*" {
      clear; add "  missing operator?"; put;
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  B"expr*".!"expr*" {
    E"expr*",E"natnum*",E"decnum*",E"(*" {
      clear; add "  missing operator?"; put;
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  #lits: ().
  # expr* natnum* decnum* op.power* op.mul* op.add* sign* 
  # variable function

  B"variable*".!"variable*" {
    E"variable*",E"function*",E"expr*",E"natnum*",E"decnum*",
    E"(*",E".*" {
      clear; add "variables"; put;
      clear; add "maths.help*"; push;
      clear; add "  misplaced variable name?"; put;
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  B"function*".!"function*".!E"(*" {
    clear; add "functions"; put;
    clear; add "maths.help*"; push;
    clear; add "  incorrect function syntax?"; put;
    put; clear; add "maths.error*"; push; .reparse
  }

  (eof) {
    # try to diagnose missing close bracket errors at end of script
    # eg (*expr*
    # we have a line/char number in the open bracket tape cell
    B"(*" {
      clear;
      add "* missing close bracket ) ?\n";
      add "  At "; get; add " there is an opening bracket which does \n";
      add "  not seem to be matched with a closing bracket ";
      put; clear; add "maths.error*"; push; .reparse
    }

    E"dot*" {
      # provide dot help with a help parse token
      clear; add "dot"; put; 
      clear; add "maths.help*"; push;
      clear; add "  Misplaced dot '.' at end of expression. \n"; put;
      clear; add "maths.error*"; push; .reparse
    }
    E"op.add*",E"op.mul*",E"op.power*" {
      clear; add "operators";
      swap; ++; put; --; # preserve operator in tape.cell+1
      clear; add "maths.help*"; push;
      add "  Misplaced operator at '"; get; add "' end of expression.";
      put; clear; add "maths.error*"; push; .reparse
    }
  }

  # ----------------
  # 3 token errors
  pop;

  # todo expr op.compare followed by ; or ) are errors
  # unterminated comparison 

  push;push;push;

  # end of error analysis
  # ---------------

  pop; 
  
  # resolve numbers to expressions to simplify grammar rules
  "decnum*","variable*" {
     clear; get; put; clear;
     add "expr*"; push; .reparse
  }

  # reduce natnum to expression at end of file, no!!!
  (eof) {
    "natnum*" { 
       # check not preceded by dot (could be decimal)
       pop;
       !"dot*natnum*" { 
         replace "natnum*" "expr*"; push; push; .reparse 
       }
       push;
     }
  }

  #-----------------
  # 2 token reductions
  pop;

  # eg: (:pi + 2^:pi)/2
  ":*expr*" {
    clear; ++; get; --;
    # mathemtical symbols and greek letters. where there is no capital
    # the roman letter works. eg B Beta
    "pi","Pi","alpha","beta","gamma","Gamma","delta","Delta",
    "epsilon","eepsilon","zeta","eta","theta","Theta",
    "iota","kappa","lambda","Lambda","mu","upsilon","Upsilon",
    "chi","psi","Psi","omega","Omega","nu","xi","Xi",
    "ro","rro","sigma","Sigma","tau","theta","infinity" {
      replace "ro" "varro";  # a curly ro 
      replace "eepsilon" "varepsilon";  # a curly e epsilon
      replace "infinity" "infty"; put;  
      clear; add " \\"; get; add " "; put;
      clear; add "variable*"; push; .reparse
    }
    # a bit of a hack to include +/- as an addition subtraction
    # operator.
    "plusminus" {
      clear; add " \\pm "; put;
      clear; add "op.add*"; push; .reparse
    }
    # save the incorrect symbol name for the error
    # message.
    ++; put; --;
    clear; add "symbols"; put; 
    clear; add "maths.help*"; push;
    clear; add "  unknown symbol '"; get; add "'"; put;
    clear; add "maths.error*"; push; .reparse
  }

  # reduce natnums to expressions if not followed by a dot
  # this creatly reduces complexity of parsing rules later
  # already ensured not "natnum*natnum*" in error checks above.
  B"natnum*".!"natnum*".!E"dot*" {
    replace "natnum*" "expr*"; push; push; .reparse
  }

  "sign*expr*" {
    clear; add " "; get; ++; get; --; add " "; put; clear;
    add "expr*"; push; .reparse
  }
  
  # a list of equations
  "equation*equation*","equationset*equation*" {
    clear; get ; 
    add "\n"; 
    add "\n \\noindent\\makebox[\\linewidth]{\\rule{\\paperwidth}{0.4pt}}\n";
    ++; get; --; put; clear;
    add "equationset*"; push; .reparse
  }
  
  # There may be an issue with reducing sign*natnum in other
  # cases
  (eof) {
    "sign*natnum*" {
      clear; add " "; get; ++; get; --; add " "; put; clear;
      add "expr*"; push; .reparse
    }
  }
  #-----------------
  # 3 tokens
  pop;

  # an equation is just an expression followed by ';'
  # but we need 'lookbehind' here, otherwise partial expressions 
  # will resolve to equations leaving the prefix orphaned so to speak.

  # only 2 tokens, first equation
  # discard the semicolon 
  "expr*;*" {
    clear;
    add "\\[\n"; get; add "\n"; add "\\]"; put;
    clear; add "equation*"; push; .reparse
  }
  E"expr*;*" {
    B"equation*",B"equationset*" {
      replace "expr*;*" "equation*"; push; push;
      add "\\[\n"; --; get; add "\n"; add "\\]"; put;
      # realign tape pointer
      clear; ++; .reparse
    }
  }

  # These are signs at the beginning of the expression
  # only 2 tokens
  "op.add*natnum*","op.add*expr*" {
    replace "op.add*" "sign*"; push; push; .reparse
  }

  # +/- at beginning, 3 tokens
  B"sign*expr*".!"sign*expr*" {
    replace "sign*expr*" "expr*"; push; push;
    # need to compose attributes and transfer other attributes
    # compose sign/exp attribute in Lisp syntax
    --; --; add " "; get; ++; get; add " "; --; put; clear; ++; ++;
    # transfer invisible token attribute
    get; --; put; clear; ++;  
    clear; .reparse

  }

  # convert +/- oppadd* token to a sign* token where appropriate
  # If only 2 tokens (not 3) then start of document
  E"op.add*expr*".!B"expr*" {
    replace "op.add*expr*" "sign*expr*";
    push; push; push; .reparse
  }
  E"op.add*natnum*".!B"expr*" {
    replace "op.add*natnum*" "sign*natnum*";
    push; push; push; .reparse
  }

  # we dont need any look ahead here because '^' the power operator
  # has precedence over multiply/divide/add/subtract.
  # precedence. But natnum* only becomes and expr* when it sees 
  # the following token. So need another 4 token rule
  "expr*op.power*expr*" {
    clear; 
    # can also remove brackets here. see op.mul divide for example
    add " "; get; ++; get; ++; add "{"; get; add "}"; add " "; 
    --; --; put; clear; 
    add "expr*"; push;
    .reparse
  }

  # parse positive decimal numbers like 02.345
  "natnum*dot*natnum*" {
    clear; get; ++; get; ++; get; --; --; 
    # or parse to decnum* here to make negation better
    put; clear; add "expr*"; push;
    .reparse
  }

  # an interesting trick to parse a 4 token pattern before
  # a 3 token pattern. Be aware about popping nothing (empty stack) 
  "(*expr*)*" {
     pop;
     # eg: sqrt(4+9)
     "function*(*expr*)*" {
       clear; get; add "{"; ++; ++; get; add "}"; --; --; put;
       clear; add "expr*"; push; .reparse
     }
     # only push if something was popped
     !"(*expr*)*" { push; }
     clear; add "("; ++; get; add ")"; --; put; clear;
     add "expr*"; push; .reparse
  }

  (eof) {
    # natnums have already been "reduced" to expr* at end of stream 
    "expr*op.add*expr*" {
       clear; 
       add " "; get; ++; get; ++; get; add " "; 
       --; --; put; clear; 
       add "expr*"; push;
       .reparse
    }
    # make / into fractions because they look good.
    "expr*op.mul*expr*" {
       clear; ++; get; --;
       "/" {
         # remove brackets from fractions
         clear; get; B"(".E")" { clip; clop; put; } 
         clear; ++; ++; get; B"(".E")" { clip; clop; put; } --; --;
         clear; add "\\frac{"; get; add "}"; ++; ++; add "{"; get; add "}"; 
       }
       " \\times " {
         clear; add " "; get; ++; get; ++; get; add " "; 
       }
       --; --; put; clear; 
       add "expr*"; push;
       .reparse
    }
  } 

  #-----------------
  # 4 tokens parse token reductions

  pop;
 
  # a better lookahead, this will work within another language
  # it only looks for operators with more precedence.

  # reduce comparisons and logic concats to expression, 
  # so we only reduce comparisons 
  # when surrounded by brackets or terminated with ; or ,
  # if this works we can remove several rules below
  # eg: (x^2 != y)  
  B"expr*op.compare*expr*",B"expr*op.and*expr*",B"expr*op.or*expr*" {
    !"expr*op.compare*expr*".!"expr*op.and*expr*".!"expr*op.or*expr*" {
      E")*",E",*",E";*" {
        replace "expr*op.and*expr*" "expr*"; 
        replace "expr*op.or*expr*" "expr*"; 
        replace "expr*op.compare*expr*" "expr*"; 
        push;push;
        # assemble attribs for new exp token,
        --; --; add " "; get; ++; get; ++; get; add " "; --; --; put;
        # transfer unknown token attrib 
        clear; ++; ++; ++; get; --; --; put; clear; 
        # realign tape pointer 
        ++; .reparse
      }
    }
  }

  # for latex eg in sigma sums
  # eg:  ; 
  B"expr*=*expr*".!"expr*=*expr*" {
    E")*",E",*",E";*" {
      # check that it is a simple variable name. Slightly tricky because
      # variables are instantly reduced to expressions.
      #clear; 
      swap; 
      ![:alpha:] {
        clear; add "assignment.operator"; put;
        clear; add "maths.help*"; push;
        add "  Left-hand-side of equation not a variable? ";
        put; clear; add "maths.error*"; push; .reparse
      }
      swap; replace "expr*=*expr*" "expr*"; push;push;
      # assemble attribs for new exp token,
      --; --; add " "; get; ++; get; ++; get; add " "; --; --; put;
      # transfer unknown token attrib 
      clear; ++; ++; ++; get; --; --; put; clear; 
      # realign tape pointer 
      ++; .reparse
    }
  }

  # op.mul (*/) and op.power (^) have more precedence that +/- 
  B"expr*op.add*expr*".!"expr*op.add*expr*" {
    !E"op.mul*".!E"op.power*" {
      replace "expr*op.add*expr*" "expr*"; push;push;
      # assemble attribs for new exp token,
      --; --; add " "; get; ++; get; ++; get; add " "; --; --; put;
      # transfer unknown token attrib 
      clear; ++; ++; ++; get; --; --; put; clear; 
      # realign tape pointer 
      ++; .reparse
    }
  }

  # op.power (^) has more precedence that */
  B"expr*op.mul*expr*".!"expr*op.mul*expr*" {
    !E"op.power*" {
      replace "expr*op.mul*expr*" "expr*"; push;push;
      # assemble times or fraction
      clear; --; get; --; 
      "/" {
        # remove brackets from fractions
        clear; get; B"(".E")" { clip; clop; put; } 
        clear; ++; ++; get; B"(".E")" { clip; clop; put; } --; --;
        clear; add "\\frac{"; get; add "}"; ++; ++; add "{"; get; add "}"; 
      }
      " \\times " { clear; add " "; get; ++; get; ++; get; add " "; }
      --; --; put;

      clear; ++; ++; ++; get; --; --; put; clear; 
      # realign tape pointer 
      ++; .reparse
    }
  }

  # natnum/var/decnum only become expressions when the following
  # token is seen, this is why we need a 'lookahead' rule here. 
  B"expr*op.power*expr*".!"expr*op.power*expr*" {
    replace "expr*op.power*expr*" "expr*"; push;push;
    --; --; add " "; get; ++; get; ++; get; add " "; --; --; put;
    clear; ++; ++; ++; get; --; --; put; clear; 
    # realign tape pointer 
    ++; .reparse
  
  }

  #*
  # should not be necessary anymore see above for a lookahead rule
  # eg: x^2 != y^3 ; 
  "expr*op.compare*expr*;*" {
    clear; get; ++; get; ++; get; add " "; --; --; put;
    clear; add "equation*"; push; .reparse
  }

  # should not be necessary anymore see above for a lookahead rule
  # reduce this to an equation only at EOF to allow assignments.
  # eg: x^2 OR y^3 ; 
  "expr*op.and*expr*;*","expr*op.or*expr*;*" {
    clear; get; add " "; ++; get; add " "; ++; get; add " "; --; --; put;
    clear; add "expr*;*"; push; push; .reparse
  }

  *#

  #*
  # should not be necessary anymore see above for a lookahead rule

  # this is the only assignment rule. assignments are not allowed
  # inside of other expressions (unlike c) actually, will change this
  # for latex eg in sigma sums
  # eg:  ; 
  "expr*=*expr*;*" {
    # check that it is a simple variable name. Slightly tricky because
    # variables are instantly reduced to expressions.
    clear; get; 
    ![:alpha:] {
      clear; add "assignment.operator"; put;
      clear; add "maths.help*"; push;
      add "  Left-hand-side of equation not a variable? ";
      put; clear; add "maths.error*"; push; .reparse
    }
    clear; get; add " "; ++; get; add " "; ++; get; --; --; put;
    clear; add "equation*"; push; .reparse
  }
  *#

  #-----------------
  # 5 tokens parse token reductions
  pop;

  #*

  # should not be necessary anymore see above for a lookahead rule

  # example to parse comparisons, so we only reduce comparisons 
  # when surrounded by brackets or terminated with ; 
  # eg: (x^2 != y) 
  "(*expr*op.compare*expr*)*" {
    clear; add "("; ++; get; ++; get; ++; get; add ")"; 
    --; --; --; put;
    clear; add "expr*"; push; .reparse
  }

  # should not be necessary anymore see above for a lookahead rule

  # only reduce logic when terminated in ';' or in brackets
  # (x==4) AND (x^2 != y);
  "(*expr*op.and*expr*)*","(*expr*op.or*expr*)*" {
    clear; add "("; ++; get; add " "; ++; get; add " "; ++; get; add ")"; 
    --; --; --; put;
    clear; add "expr*"; push; .reparse
  }

  *#

  #-----------------
  # 6 tokens parse token reductions
  pop;

  # todo: this should be 3 arguments eg sum(0,:infinity,x+y)
  # eg: sum(x=0,100)
  # need to make assignments reduce here
  "function*(*expr*,*expr*)*" {
    clear; get;
    !"\\sum_".!"\\binom" {
      clear; add "functions"; put;
      clear; add "maths.help*"; push;
      clear; add "  sum and binom take 2 arguments."; put;
      put; clear; add "maths.error*"; push; .reparse
    }
    ++; ++; add "{"; get; add "}"; 
    # sum has a funny syntax
    B"\\sum" { add "^"; } add "{"; ++; ++; get; add "}"; 
    --; --; --; --; put;
    clear; add "expr*"; push; .reparse
  }

  
  push; push; push; push; push; push;

  
  (eof) {
    pop;
    "expr*" {
      clear; 
      add "\\[\n"; get; add "\n"; add "\\]"; put;
      clear; add "equation*"; push; .reparse 
    }
    push;
  }


  (eof) {
    pop; pop;
    "expr*","equation*","equationset*" {
      clear;  
      # create a latex document to display the equation
      add "\\documentclass{article}\n";
      add "\\usepackage{amsmath}\n";
      add "% or \\usepackage{mathtools}\n";
      add "\\usepackage{xcolor}\n";
      add "\\usepackage{multicol}\n";
      add "\\begin{document}\n";
      # turn off page numbers
      add "\\pagestyle{empty}\n";
      add "\\Huge\n";
      add "\\color{blue}\n\n";
      get; add "\n";
      add "\\end{document}\n";
      print; clear; quit;
    }

    push; push;
    add "No, it doesn't look like a single valid arithmetic \n";
    add "'in-fix' expression. The parse stack was: ";
    print; clear; unstack; add "\n"; print;
    quit;
  }
