
#*

ABOUT 
 
 parse and check the syntax of [json] text-data input. No [unicode]
 escape sequences. Recognises scientific numbers. I am not sure 
 how *compliant* this is with the official *json* syntax.

 This script parses "json" syntax using the parse-machine. It is  edging
 towards a fully syntax compliant syntax checker.  I will not concern myself
 with the complexities of Unicode escape character parsing for the time being.
 I include D. Crockford's (the inventor of json) json BNF grammar for
 reference but the code actually uses a completely different grammar more
 suited to the pep/nom parse-machine.

 The interesting thing about Crockford's grammar is that it does
 not use any "lexing" phase, nor does it use any EBNF extensions.

NOTES
 
 When translating to other languages it may be good to, by default
 disable the parse-stack visualisation, because this may cause a 
 syntax error in the target language. This is because the comment syntax
 in that language may be different.

 I could change this to use the error/help token system for 
 error checking which is more systematic. 

STATUS 

 Seems to be working (including scientific numbers). Checks leading zeros in
 numbers etc. The trick of displaying the stack at the parse> label, greatly
 helped debugging. Still needs testing.

 Doesnt include escaped unicode chars within strings such as eg \u4567
 But that should not matter.

TO DO 

  Also, the "jq" program allows numbers like "+004e3" which crockfords
  grammar would disallow. So I could make a "strict" script and a
  non-strict one.

  Make this script, or a similar one pretty print the json input.

SEE ALSO
  
 - pars/eg/json.number.pss
    Just check JSON number syntax. But the current script 
    also does that.
 - pars/translate.py.pss
    This python translator should be able to translate the 
    current script into python.

PROBLEMS

  Numbers are tricky to include in this grammar because they require a one
  token (not character) "look ahead" in order to know where the number ends.
  Eg -3 could become -3.22 which could become -3.22E+20 etc.  So we need to
  use the , ] } tokens to know where the number ends.  This is a limitation of
  the parse machine. However, there are some workarounds for this, for example
  we could try

  ---- 
    # Here number is a terminal token, meaning that it can be resolved
    # but integer* is not (because it could be followed by a decimal part
    # etc, so cannot be resolved.
    pop;pop;
    "integer*,*" {
      clear; add "number*,*"; push; push; .reparse
    }

    pop;
    !",*number*", B",*number*" {
      replace ",*number*" "items*";
      push; push; push; # there are 3 tokens
      .reparse
    }
  ,,,,

TODO

HISTORY

   11 aug 2025
    Adding help and error tokens, self translation with the "/to<lang>",
    self-testing with /test and /test.line and /test.bad.line 
    and many other help words.
   9 June 2021
    Added scientific number format to this script, so I can now
    change its name to json.check.pss. 
    Improved the decimal number parser, prohibiting leading zeros 000

   4 June 2021
    Improving some 2 token error messages

   1 June 2021
    Working on including signed and decimal numbers, but it is 
    much trickier than I imagined. It requires having a look ahead
    token, which can only be achieved by adding the lookahead token
    to the grammar.

    Also start several new scripts, one that is a strict syntax
    checker, another that gives warnings for empty objects etc.

    Also, it would be good to compile scripts to the "go" language
    (googles c successor).

  24 july 2020

    Advanced the script translate.java.pss to a sufficient level
    that it appears to correctly translate this script into java.

    For example we can translate this to java with
    ----
       pep -f translate.java.pss eg/json.parse.pss > Machine.java
       javac Machine.java
       # test the java json parser/checker
       echo '{"time": [0,44,22]}' | java Machine
    ,,,,

  20 july 2020

    Wrote json.number.pss which parses correctly json scientific
    format numbers (eg -0.00123E+001). That script can be 
    included here to provide a relatively complete json 
    parser/checker.

  15 june 2020
    Addressing bug in error checking. Need to ensure that 2 tokens
    are on the stack, not just 1. 

  14 June 2020
    Made good progress on this script. Arrays and objects parse
    recursively. Number parsing is very
    simplistic, and no attempt to parse escape sequences is made.

  Early 2020
    Began this script

TESTING

  Script appears to work with the translators for go,java,python,ruby
  but not tcl (some bug in tcl implementation of the machine). The 
  script does not run as quickly as 'jq' but not too bad.

  The script can be tested with:
  >> pep -f eg/json.parse.pss -i '{"location":55, "sum":[1,2,[3,4]]}

  * use the helper functions in helpers.pars.sh to test translations
  >> pep.jaff ...

BNF GRAMMAR

 * Douglas Crockfords recent json grammar (adapted from McKeeman form)
 ------
   # I have removed whitespace elements from this grammar.

   json: element .
   value: object | array | string | number | "true" | "false" | "null" .
   object: '{' '}' | '{' members '}' .
   members: member | member ',' members .
   member: string ':' element .
   array: '[' ']' | '[' elements ']' .
   elements: element | element ',' elements
   element: value 
   string: '"' characters '"' .
   characters: "" | character characters .
   character: '0020' . '10FFFF' - '"' - '\' | '\' escape .
   escape: '"' | '\' | '/' | 'b' | 'f' | 'n' | 'r' | 't' | 'u' hex hex hex hex
   hex: digit | 'A' . 'F' | 'a' . 'f' .
   number: integer fraction exponent .
   integer: digit | onenine digits | '-' digit | '-' onenine digits
   digits: digit | digit digits
   digit: '0' | onenine .
   onenine: '1' . '9' .
   fraction: "" | '.' digits .
   exponent: "" | 'E' sign digits | 'e' sign digits .
   sign: "" | '+' | '-' .
   ws: "" | '0020' ws | '000A' ws | '000D' ws | '0009' ws .

 ,,,,

*#

  # check for an empty doc or help-word and trigger help if so
  begin {
    while [:space:]; clear;
    (eof) {
      # the category is help and the token too.
      add "usage"; put; clear; 
      add "help*"; push; .reparse
    }
    # a document starting with / or // etc will be considered a help request
    # a document starting with '/' would not be valid json?
    while [/];
    !"" {
      # get 2 help words and save with no space 
      clear; while [:space:]; clear; whilenot [:space:];
      put; clear; while [:space:]; clear; whilenot [:space:];
      swap; get; put; clear;
      add "help*"; push; .reparse
    }
  } # end of beginblock

  read;
  # Unlike Crockfords grammar, I will just completely ignore whitespace,
  # but this may not be acceptable in a rigorous application. 

  # make character number relative to line number 
  [\n] { clear; nochars; (eof) { .reparse } .restart }
  [:space:] { clear; (eof) { .reparse } .restart }

  [0-9] { 
    while [0-9]; 
    put; clear; add "integer*"; push; .reparse 
  } 

  [a-z],[A-Z] { 
    while [a-z]; 
    !"true".!"false".!"null".!"e".!"E" {
      # handle error
      put; clear; 
      add "Unknown value '"; get; 
      add "' at line "; lines; add " (character "; chars;
      add ").\n";
      print; zero; a+; quit;
    }
    put; 
    "e","E" { clear; add "E*"; push; .reparse }
    clear; add "value*"; push; .reparse 
  } 

  '"' {
    # save line number for error message
    clear; lines; put; clear; until '"'; 
    <eof> {
      clear; 
      add 'Unterminated quote (") char, starting at line '; 
      get; add "\n"; zero; a+; print; quit;
    }
    }
    clip; put; clear;
    add "string*"; push; .reparse
  }
  # literal tokens
  ".",",",":","-","+","[","]","{","}" { put; add "*"; push; .reparse }

  # here check if the workspace is empty. If not it is an error.
  !"" {
    put; clear; 
    add "JSON syntax error at line "; lines; 
    add ", char "; chars; 
    add ": unquoted '"; get; add "' character.\n"; 
    print; zero; a+; quit;
  }


parse>
   # watch the parse stack reduce
   add "# "; lines; add ":"; chars; add " "; print; clear;
   unstack; print; stack; add " \n"; print; clear;

 # ----------------
 # the error and help system
 pop;

 #*
  error and help tokens which allow implementing a help system
  that can be triggered by an empty document or by help keywords
 *#
 "error*" {
   # maybe get the parse stack here as well
   clear; 
   add "--json.check.pss-- (check syntax of JSON data)\n";
   add "near line:"; lines; add " char:"; chars; add "\n";
   get; 
   # indent the error message 
   replace "\n" "\n  "; add "\n"; print;
   clear; pop; "help*" { push; .reparse } 
   # the help* token also quits but if there is no help token
   # then just stop here.
   zero; a+; quit;
 }

 #*
  Using a help* token to allow the script to document itself.
  The swap commands below are used to save the help text in the tape
  cell so that several or all help topics can be printed at once.

 *#

 "help*" {
   # does json have comments to wrap this in? 
   clear; swap; 
   
   # how to use this script
   "usage","help","all" {
     swap; add "
   USAGE
     pep -f json.check.pss file.json
     pep -f json.check.pss -i '[1,2,3,]'

     A nom script to check the syntax of JSON text data input 
     ";
     swap;
   }

   # help about the help-system
   "words","usage","help" {
     swap; add "
   HELP KEYWORDS

     All JSON documents/input which begin with '/' are considered to be help 
     requests. See below for the list of valid help keywords.

     pep -f json.check.pss -i /<helpword> 
       see some help for that topic or category

     pep -f json.check.pss -i /words
       see what help topics and categories are available for this script.

     pep -f json.check.pss -i /help
       see all the help.

     pep -f json.check.pss -i /toperl | bash
       translate this script to perl 
       
   ### General Help 
     - /usage: show a usage message for this script 
     - /words: show what help commands are available
     - /faq: show an FAQ about this script.
     - /nom: show information about the nom script language
   ### About the JSON format 
     - /flaws: known limitations with how this script parses JSON
     - /format: show summary information about the JSON text format.
   ### About testing this script
     - /eg.lines: prints a set of one line JSON documents that should 
        be accepted by this recogniser script. These can be used by
        other test words.
     - /eg.bad.lines: a set of one-liners that should be rejected.
     - /test.line: tests one random one-line JSON document.
     - /test.bad.line: tests one random one-line invalid JSON document.
     - /test: test the script with a document

     The 'test' and 'to' words need to be piped to bash to actually 
     execute.

   ### About translating this script

     - /translate: show how to translate this script to another language
     - /to<lang>: translate this script to some other language
         using the nom translation scripts at www.nomlang.org/tr/ 
          ( rust|dart|perl|lua|go|java|javascript|ruby|python|tcl|c) 
          (eg: /toperl /tolua etc). Or latex/pdf/html 

     Also see the /test.line help word for testing translated scripts

     There are also help 'categories' which display several help
     topics at once such as:

     - /usage: script usage and helpwords
     - /format: all information about the JSON format 
     - /help: show all available help topics.

     ";
     swap;
   }

   # the faq 
   "FAQ","faq","help" {
     swap; add "
   FAQ
     (not) frequently asked questions about /eg/json.check.pss

     Q: What does this script do?
     A: It checks the syntax of JSON data 

     Q: What is JSON? 
     A: Its sort of a text-data thingy with curly braces and lots
        of quotes. Its probably better than XML and YAML only because
        I dont like being forced to indent things (YAML) or write lots 
        of tags (XML).
     
     Q: Why does this script have its own FAQ?
     A: A question about a set of questions? How interesting! 
      
     Q: Should I use this instead of 'jq'
     A: No, not really. I think it runs quite fast, but 'jq' is a lot
        faster, even when I compile this script with 'go' or 'rust'.
        Also, this script is more of a demonstration than a serious 
        JSON recogniser.

     Q: What is the help system for?
     A: It is for testing the system and providing help for how the 
        script works.

     Q: How do I use the help system for this script?
     A: Instead of an input (JSON) document, type a help-word starting
        with a forward slash, for example 
        >> pep -f json.check.pss -i /help

     Q: How can I translate this script to another language?
     A: Try typing 'pep -f json.check.pss /toperl' to translate to 
        perl, for example. But if you translate to an 'older' translation
        script, then this help system may not work.

     Q: How does this translation thing work?
     A: Nom scripts can translate nom scripts, so there is a nom translation
        script for several languages. These are located at 
        www.nomlang.org/tr/ and there are 2 categories: the older translation
        scripts and the newer. The newer ones are called something like
        /tr/nom.toperl.pss . The newer ones are much better for all sorts 
        of reasons. Whats more, the translation scripts can also translate
        themselves to the Nth degree which is a bit strange.

     Q: What does 'to the Nth degree' mean?
     A: Its a strange concept where the translator translates the translator
        and so on and so forth.

     Q: None of this works. Why did you bother?
     A: I don't think that is true. Some of it should work and does work
        quite well, but yes, there will be the odd bug here and there.

     Q: Is this system better than lex/yacc/bison/antlr etc?
     A: I think it is more fun and interesting to use. And I think that 
        in the long run it has much more potential as a way to 
        use and understand grammars. But it still has a somewhat 
        'experimental flavour'.

     Q: Can I use this script from within my lua program?
     A: Yes, actually you can, funnily enough. What you do is, 1st translate
        the script to lua. There are several ways to do this, and possibly
        the easiest is just to type *pep -f json.check.pss /tolua*
        which will create a lua translation called 'jsoncheck.lua' in 
        the current folder. Then you can delete the 'main' code in the 
        translation and call the 'parse()' method from the translated code.

     Q: But wouldn't it be better to just use some JSON parsing library
        which is written in lua?
     A: You have a point there... but there may be cases where this 
        pep/nom script does something that the lua library doesn't. 

     Q: Can I translate this to the Forth language?
     A: Not yet (Aug 2025) but one day soon it should be possible, which 
        means that you can use this script on a microcontroller.

     Q: I don't think I need a big FAQ on a microcontroller. What would be
        the point? And anyway, it wouldn't fit in the tiny memory space 
        of an ATMEGA.
     A: Well, just delete all that from the script before you translate it
        to the hypothetical forth target. All the help stuff is in the 
        help* token.

     ";
     swap;
   }
      
   # more information about the nom language 
   "nom","about","help" {
     swap; add "
       This script is written in the 'nom' language which is a 
       manifestation of the pep:nom parsing system.

       Nom is a scripting language for parsing/translating context-free and 
       (some) context-sensitive patterns. Please see www.nomlang.org for
       (much) more information.
     ";
     swap;
   }

   # standard help word. produce a valid json document which 
   # can be used to test the script with /test
   "eg" {
     swap; add '
     [
       { "name":"tolstoy", "job":"writer"},
       { "name":"obama", "favourite numbers": [0, 3.1517, 42]},
       { "name":"saramago", "age": 21}
     ]
     '; 
     replace "\n  " "\n";
     swap;
   }

   # This help word should be standard so that a script like 
   # /eg/nom.to.pss can call it and test any script
   "eg.lines" {
     swap; add '
       # a simple object
       { "name":"tolstoy", "job":"writer"}
       # object with array
       { "name":"obama", "favourite numbers": [0, 1.2e-22, 3.1517, 42]}
       # array with objects
       [{"a":1,"b":2},{"c":-3.1E2,"d":0.03},"xy","zz"]
       # null
       {"position":[0,1,2,null],"xyz":true,"abc":false}
       { "name":"saramago", "age": 21}
       [-0.00123E+001, 1, "time", "space", [0,0],[1,[2,3]]]
       {"space":-3.22E+20,[{"a":1,"b":2},"when","why"]}
       # escape sequences are not allowed...but should be. 
       # { "face": "\uD83D\uDE10" }
     '; 
     replace "\n       " "\n";
     swap;
   }

   # Erroneous json data that should be caught by the checker.
   "eg.bad.lines" {
     swap; add "
       # unquoted text
       ['a','b',c]
       # duplicated comma in array
       ['a',,'b']
     ";
     swap;
   }

   # tests one (random) one-line JSON doc with this script
   "test.line" {
     swap; add "
       # TESTING SOME RANDOM (one-line) JSON INPUT
       doc=$(pep -f json.check.pss -i /eg.lines | \\
         sed '/^ *#/d;/^ *$/d;' | shuf -n 1) 
       echo \"input: $doc\"
       pep -f json.check.pss -i \"$doc\" 
       echo \"input: $doc\"
       # ------------------------
       # RUN THIS WITH:
       # pep -f json.check.pss -i /test.line | bash
       ";
     replace "\n     " "\n";
     swap;
   }

   # tests one one-line invalid JSON doc with this script
   "test.bad.line" {
     swap; add "
       # TESTING SOME RANDOM (one-line) JSON INPUT
       doc=$(pep -f json.check.pss -i /eg.bad.lines | \\
         sed '/^ *#/d;/^ *$/d;' | shuf -n 1) 
       echo \"test-line: $doc\"
       pep -f json.check.pss -i \"$doc\" 
       # ------------------------
       # RUN THIS WITH:
       # pep -f json.check.pss -i /test.line | bash
       ";
     replace "\n     " "\n";
     swap;
   }

   # tests json input doc with this script
   "test" {
     swap; add "
       # TESTING JSON INPUT from /eg
       pep -f json.check.pss -i /eg | sed '/^ *#/d;' > test.json
       echo \"input: $doc\"
       pep -f json.check.pss test.json 
       # ------------------------
       # RUN THIS WITH:
       # pep -f json.check.pss -i /test | bash
       ";
     replace "\n     " "\n";
     swap;
   }

   # just call the /eg/nom.to.pss script which does translation from
   # a simple command like 'translate script.pss to ruby'
   # >> pep -f json.check.pss -i /to<lang> | bash
   B"to" {
     clop; clop; put; clear;

     add '
      translator=${PEPNOM}/eg/nom.to.pss
      if [ -f $translator ]; then
        echo -e "[ok] Found translator script: $translator"
      else
        echo -e "
         [error] did not find translator: \\${PEPNOM}/eg/nom.to.pss
         (maybe) set the $PEPNOM environment var
         (or)    download the translator from www.nomlang.org/eg/ 
         ";
        exit 1;
      fi
      pep -f $translator -i "translate json.check.pss to '; get; add '" | bash
      # RUN THIS WITH:  
      #   pep -f json.check.pss -i /to'; get; add ' | bash
      ';
      replace "\n    " "\n";
      print; quit;
   }

   # how to translate this script to another language, 
   "translate","tr","about","help" {
     swap; add "

    HOW TO TRANSLATE THIS SCRIPT

      This script can be translated to other languages using nom 
      translation scripts which are available at www.nomlang.org/tr/

      current (aug 2025) translation languages:
        all languages: all
        code languages: 
          rust|dart|perl|lua|go|java|javascript|ruby|
          python|tcl|c
        formats: html|pdf|latex

      * translate to ruby with /eg/nom.to.pss
      >> pep -f /eg/nom.to.pss -i 'translate json.check.pss to ruby' | bash

      * translate itself to java with the help word '/to' (needs /eg/nom.to.pss)
      >> pep -f json.check.pss -i /tojava | bash

      * format the script as colourised pdf (needs xelatex) 
      >> pep -f json.check.pss -i /topdf | bash

      * translate 'by-hand' to rust, compile and run (needs 'rustc')
      ---
        pep -f tr/nom.torust.pss json.check.pss > json.check.rs
        rustc -o texttohtml.exe texttohtml.rs
        echo ' some *strong* text ' | ./texttohtml.exe 
      ,,,

      * translate a script to perl, and run with 'doc.txt' as input
      ---
        pep -f nom.toperl.pss json.check.pss > test.pl 
        chmod +x test.pl
        cat doc.txt | ./test.pl
      ,,,

     ";
     swap;
   }

   # Format can be regarded as a 'category'. So more than one help 
   # topic will be printed
   B"flaw",B"fault","format","help" {
     swap; add "
    SCRIPT FLAWS as of aug 2025: 
   
     - is a member a valid doc? 
     - are single quotes valid in json?
     - doesnt recognise unicode escape sequences
     - completely ignores white-space outside of quotes (which
       may be ok, I am not sure)

     ";
     swap;
   }

   # json array format 
   "arrays","format","help" {
     swap; add '
     JSON ARRAYS
       Arrays are delimited by square brackets and may contain
       any other element (and nested elements)
       eg: [1,"name",{"a":1.2,"b":0.3},0]
     ';
     swap;
   }
   # json number format 
   "numbers","format","help" {
     swap; add "
     JSON NUMBERS
       Json numbers may be in scientific format +/- decimal etc.
       eg: -0.123 1.6e-33
     ";
     swap;
   }
   
   swap;
   "" {
     add "Help topic '/"; get; add "' not known\n";  
     add "Type: pep -f json.check.pss -i /words \n";
     add "  to see valid help keywords";
   }
   add "\n\n"; print; quit; 
 }

 push;
 # end of the error and help system.
 # -------------------
    
# The parse/compile phase
# --------------
# 2 tokens
  pop; pop;

  #-----------
  # Two token errors (not necessarily a complete list)
  # comma errors 
  "{*,*",",*}*","[*,*",",*,*",",*]*" { 
    clear; 
    add "JSON syntax error (extra or misplaced ',' comma?)\n";
    put; clear; add "error*"; push; .reparse
  }

  # exponent errors (e/E must be followed by an int or signed int)
  !"E*".B"E*".!E"integer*".!E"-*".!E"+*".!E"number*" { 
    clear; 
    add "JSON syntax error at line ";
    add ": misplaced exponent 'e' or 'E' \n";
    add "In JSON syntax, e/E may only precede an int or signed int.\n";
    add "for example: 33e+01 \n";
    put; clear; add "error*"; push; .reparse
  }

  # exponent errors (e/E must be followed by an int or signed int)
  !"E*".E"E*".!B"integer*".!B"sign.integer*".!B"decimal*" { 
    clear; 
    add "JSON syntax error: misplaced exponent 'e' or 'E' \n";
    add "In JSON syntax, e/E may only be preceded by an int, signed int.\n";
    add "or decimal eg: 33e+01 \n";
    put; clear; add "error*"; push; .reparse
  }

  # sign errors (+/- must be followed by an integer
  B"-*",B"+*" {
    !"-*".!"+*".!E"integer*" { 
      clear; 
      add "Json syntax error:  misplaced sign (+/-)\n";
      add "In JSON syntax, -/+ may only precede a number \n";
      add "for example: -33.01 or +33.02 \n";
      put; clear; add "error*"; push; .reparse
    }
  }

  # dot errors (. must be followed by an integer)
  !".*".B".*".!E"integer*" { 
    clear; 
    add "Json syntax error at line "; lines; 
    add " (char "; chars; add "): misplaced dot '.' sign\n";
    add "In JSON syntax, dots may only be used in decimal numbers \n";
    add "for example: -33.01 \n";
    print; quit; 
  }

  # dot errors (. must be preceded by an integer or signed integer)
  !".*".E".*".!B"integer*".!B"sign.integer*" { 
    clear; 
    add "JSON syntax error at line "; lines; 
    add " (char "; chars; add "): misplaced dot '.' sign\n";
    add "In JSON syntax, dots may only be used in decimal numbers \n";
    add "for example: -33.01, but .44 is not a legal JSON number \n";
    print; quit; 
  }

  # eg errors "items*:*","members*:*",",*:*","[*:*","{*:*" 
  # A colon must be preceded by a string. Using <and> logic
  E":*".!":*".!B"string*" {
    clear; 
    add "Json syntax error near line "; lines; 
    add ", char "; chars; add " (misplaced colon ':') \n"; 
    add "A ':' can only occur after a string key in an object structure \n"; 
    add 'Example: {"cancelled":true} \n'; 
    print; quit; 
  }

  # more colon errors 
  !":*".B":*" {
    E"}*",E",*",E"]*" {
      clear; 
      add "JSON syntax error near line "; lines; 
      add ", char "; chars; add " (misplaced colon ':' or missing value?) \n"; 
      add "A ':' only occur as part of an object member \n"; 
      add 'Example: {"cancelled":true} \n'; 
      print; quit; 
    }
  }

  # catch object member errors 
  # also need to check that not only 1 token in on the stack
  # hence the !"member*" construct
  B"member*",B"members*" {
    !"member*".!"members*".!E",*".!E"}*" {
      clear; 
      add "JSON syntax error after object member near line "; lines; 
      add " (char "; chars; add ")\n";
      print; quit; 
    }
  }

  # catch array errors 
  B"items*".!"items*".!E",*".!E"]*" {
    clear; 
    add "Error after an array item near line "; lines; 
    add " (char "; chars; add ")\n";
    print; quit; 
  }

  B"array*",B"object*" {
    !"array*".!"object*".!E",*".!E"}*".!E"]*" {
      clear; 
      add "JSON syntax error near line "; lines; 
      add " char "; chars; add ")\n";
      print; quit; 
    }
  }

  # invalid string sequence
  B"string*" {
    !"string*".!E",*".!E"]*".!E"}*".!E":*" {
      clear; 
      add "JSON syntax error after a string near line "; lines; 
      add " (char "; chars; add ")\n";
      print; quit; 
    }
  }

  # transmogrify into array item, start array
  "[*number*","[*string*","[*value*","[*array*","[*object*" { 
    clear; add "[*items*"; push; push; .reparse
  }

  # exponents (e-403, E+120, E04), this slightly simplifies number parsing
  "E*sign.integer*","E*integer*" { 
    clear; add "^"; ++; get; --; put; 
    clear; add "exponent*"; push; .reparse
  }

  # JSON scientific format (23e-10, -201E+33)
  "integer*exponent*","sign.integer*exponent*" { 
    clear; get; 
    # enforce multidigit zero rules
    # But is "0e44" legal JSON number syntax? That would seem odd
    # if it is.
    B"+" {
      clear; 
      add "JSON syntax error at line "; lines; 
      add " (char "; chars; add "): \n";
      add "In JSON syntax, the number part may not have a positive sign \n";
      add "eg: +0.12e34 (error!) \n";
      add "eg: 0.12e+34 (OK!) \n";
      print; quit; 
    }
    B"-" { clop; }
    !"0".B"0" {
      clear; 
      add "Json syntax error at line "; lines; 
      add " (char "; chars; add "): \n";
      add "In JSON syntax, multidigit numbers must begin with 1-9 \n";
      add "eg: -0234.01E+9 (error) \n";
      print; quit; 
    }
    clear; get; ++; get; --; put; 
    clear; add "number*"; push; .reparse
  }

  # JSON scientific format (-0.23e10, 10.2E+33)
  "decimal*exponent*" { 
    clear; get; ++; get; --; put; 
    clear; add "number*"; push; .reparse
  }

  # where does a number terminate, this is the problem
  # It terminates at the tokens ,* }* ]* and maybe space but 
  # this script doesnt have a space* token.
  "sign.integer*,*","integer*,*" { 
    clear; add "number*,*"; push; push; .reparse
  }

  # transmog
  "sign.integer*]*", "integer*]*" { 
    clear; add "items*]*"; push; push; .reparse
  }

  "sign.integer*}*", "integer*}*" { 
    clear; add "number*}*"; push; push; .reparse
  }

  # convert decimals to numbers with token lookahead
  "decimal*}*", "decimal*]*","decimal*,*" { 
    replace "decimal*" "number*"; push; push; .reparse
  }
  # signed numbers
  "-*integer*","+*integer*" { 
    clear; get; ++; get; --; put; clear;
    add "sign.integer*"; push; .reparse
  }

  # signed numbers
  "-*integer*","+*integer*" { 
    clear; get; ++; get; --; put; clear;
    add "sign.integer*"; push; .reparse
  }

  # empty arrays are legal json
  "[*]*" { clear; add "array*"; push; .reparse }
  # empty objects are legal json
  "{*}*" { clear; add "object*"; push; .reparse }

# --------------
# 3 tokens
  pop;

  #---------------
  # Some three token errors

  # Object errors
  # A negative logic doesnt work because of the lookahead required for numbers
  "{*string*}*","{*integer*}*","{*sign.integer*}*","{*array*}*",
  "{*object*}*","{*value*}*","{*decimal*}*" {
    clear; 
    add "Json syntax error near line "; lines; 
    add ", char "; chars; add " (misplaced brace '}' or bad object) \n"; 
    add "A '}' can only occur to terminate an object structure \n"; 
    add 'Example: {"hour":21.00, "cancelled":true} \n'; 
    print; quit; 
  }

  # transmogrify number into array item
  "[*number*,*" {
    clear; add "[*items*,*"; push; push; push; .reparse
  }

  # decimal numbers eg -4.334 or +4.3 or 0.1
  "sign.integer*.*integer*" {
    clear; get;
    B"+" {
      #error, no positive signed decimals in JSON
      add "Json syntax error at line "; lines; 
      add " (char "; chars; add "): misplaced positive '+' sign\n";
      add "In JSON syntax, decimal numbers are not positively signed\n";
      add "eg: +33.01 (error) \n";
      print; quit; 
    }
    B"-0".!"-0" {
      add "Json syntax error at line "; lines; 
      add " (char "; chars; add "): \n";
      add "In JSON syntax, multidigit numbers must begin with 1-9 \n";
      add "eg: -0234.01E+9 (error) \n";
      print; quit; 
    }
    clear; add "decimal*"; push; .reparse
  }

  # decimal numbers eg -4.334 or +4.3 or 0.1
  "integer*.*integer*" {
    clear; 
    add "decimal*"; push; .reparse
  }

  # arrays, 
  "[*items*]*","[*number*]*" {
    clear; add "array*"; push; .reparse
  }

  # 
  "items*,*string*", "items*,*value*", "items*,*array*", 
  "items*,*object*", "items*,*number*" { 
    clear; add "items*"; push; .reparse
  }

  # object members
  #"string*:*integer*",
  "string*:*number*",
  "string*:*string*",
  "string*:*value*",
  "string*:*object*",
  "string*:*array*" {
    clear; add "member*"; push; .reparse
  }

  # multiple elements of an object
  "member*,*member*","members*,*member*" {
    clear; add "members*"; push; .reparse
  }

  #  
  "{*members*}*","{*member*}*" {
    clear; add "object*"; push; .reparse
  }

  pop; 
  # --------------
  # 4 tokens

  "items*,*items*,*","items*,*number*,*" {
    clear; add "items*,*"; push; push; .reparse
  }

  # numbers require a lookahead token, unfortunately 
  "string*:*number*,*" {
    clear; add "member*,*"; push; push; .reparse
  }

  # numbers require a lookahead token, unfortunately 
  "string*:*number*}*" {
    clear; add "member*}*"; push; push; .reparse
  }

  # multiple elements of an object with lookahead
  "member*,*member*,*","members*,*member*,*" {
    clear; add "members*,*"; push; push; .reparse
  }

  # multiple elements of an object with lookahead
  "member*,*member*}*","members*,*member*}*" {
    clear; add "members*}*"; push; push; .reparse
  }

  pop; 
  # --------------
  # 5 tokens
  # need this clumsy rule for numbers which get resolved when
  # a ] is seen. This is the lookahead
  "[*items*,*items*]*","[*items*,*number*]*" {
    clear; add "array*"; push; .reparse
  }


  push; push; push; push; push;

  <eof> {
    unstack; 
    "object*","array*","value*","string*","integer*","decimal*","number*" {
      stack; 
      add "(Appears to be) valid JSON syntax. Top level structure was '"; 
      print; clear;
      pop; clip; add "'\n"; print; clear; quit;
    }
    stack; 
    add "(maybe) Invalid JSON \n";
    add "The parse stack was \n"; print; clear;  
    unstack; add "\n"; print;
  }

 
