
// code generated by "translate.js.pss" a pep script
// http://bumble.sf.net/books/pars/tr/

  var fs = require("fs");

  function visible(text) {
    if (text == null) return "EOF=null";
    text = text.replace(/\n/g, "\n");
    text = text.replace(/\t/g, "\t");
    text = text.replace(/\r/g, "\r");
    text = text.replace(/\f/g, "\f");
    return text
  }

  // this returns 0 when end of stream reached!!!
  console.read = len => {
    var read;
    var buff = Buffer.alloc(len);
    read = fs.readSync(process.stdin.fd, buff, 0, len);
    if (read == 0) { return null; } 
    return buff.toString();
  };

  function Machine()  {
   //FILE * inputstream;   //source of characters
   this.peep = "";         // next char in the stream, may have EOF
   this.stack = [];        // stack to hold parse tokens
   this.work = "";  // 
   this.tape = [];       // array of strings for token values 
   this.tape[0] = "";    // init first element of tape array 
   this.marks = [];      // array of marks on the tape (mark/go)
   this.cell = 0; // integer pointer to current tape cell
   this.counter = 0; // used for counting
   this.charsRead = 0;   // how many characters read from input stream
   this.linesRead = 1;   // how many lines already read from input stream 
   this.flag = false;    // used for tests (not here).
   this.delimiter = "*"; // to separate tokens on the stack
   this.escape = "\\"; // escape character, default "\
   this.peep = console.read(1);
   process.stdin.setEncoding("utf8");

   this.setInput = function(newInput) {
     process.stdout.write("to be implemented")
   };

   /* read one utf8 character from the input stream and 
      update the machine. */
   this.readChar = function() {
     if (this.eof) { process.exit(); }
     // increment line and char counters
     this.charsRead++;
     if (this.peep == "\n") { this.lines++; }
     this.work += this.peep;
     // read next char from stream
     this.peep = console.read(1);
     if (this.peep == null) { this.eof = true; }
   }

   // remove escape character: trivial method ?
   // check the python code for this, and the c code in machine.interp.c
   this.unescapeChar = function(char) {
     // if this.work = "" { return }
     this.work = this.work.replace(this.work, "\\"+c, c, -1)
   }

   // add escape character : trivial?
   this.escapeChar = function(char) {
     this.work = this.work.replace(c, "\\"+c, -1)
   }

  /** a helper function to count trailing escapes */
  this.countEscapes = function(suffix) {
    var count = 0;
    var ss = "";
    if (this.work.endsWith(suffix)) {
      ss = this.work.substring(0, this.work.lastIndexOf(suffix));
    }
    while (ss.endsWith(this.escape)) {
      ss = ss.substring(0, ss.lastIndexOf(this.escape));
      count++;
    }
    return count
  }


  // reads the input stream until the work ends with the
  // given character or text, ignoring escaped characters
  this.until = function(suffix) {
    if (this.eof) { return; }
    // read at least one character
    this.readChar();
    while (true) { 
      if (this.eof) { return; }
      // we need to count the this.Escape chars preceding suffix
      // if odd, keep reading, if even, stop
      if (this.work.endsWith(suffix)) {
        if (this.countEscapes(suffix) % 2 == 0) { return; }
      }
      this.readChar();
    }
  }  

  // BUT we can just call this.until(this.tape[this.cell]) ??

  /* increment the tape pointer (command ++) and grow the 
     tape and marks arrays if necessary */
  this.increment = function() { 
    this.cell++;
    if (this.cell >= this.tape.length) {
      // grow the marks/tape arrays by 20 when the 
      // tape size is exceeded.
      for (ii=0; ii++; ii<20) {
        this.tape[this.tape.length+ii] = ""; 
        this.marks[this.marks.length+ii] = "";
      }
      this.size = this.tape.length;
    }
  }

  /* pop the top token on the stack onto the beginning of the 
     workspace buffer */
  this.pop = function() {
    if (this.stack.length == 0) return false;
    this.work = this.stack.pop() + this.work;
    if (this.cell > 0) this.cell--;
    return true;
  }

  this.push = function() {
    if (this.work == "") return false;
    var first = this.work.indexOf(this.delimiter);
    if (first > -1) {
      this.stack.push(this.work.slice(0, first+1));
      this.work = this.work.slice(first+1);
    } else {
      this.stack.push(this.work);
      this.work = "";
    }
    // use increment to handle growing the tape and marks
    // arrays if required
    this.increment();
    return true;
  }

  this.printState = function() { 
    process.stdout.write(
      "Stack " + this.stack + " Work[" + this.work + 
      "] Peep[" + this.peep + "] \n");
    process.stdout.write(
      "Acc:" + this.counter + " Esc:" + this.escape + 
      " Delim:" + this.delimiter + " Chars:" + this.charsRead);
    process.stdout.write(
      " Lines:" + this.linesRead + " Cell:" + this.cell + 
      " EOF:" + this.eof + " \n");
    for (ii = 0; ii < this.tape.length; ii++) {
      process.stdout.write(ii + " [" + this.tape[ii] + "] \n");
      if (ii > 4) { return; }
    }
  } 

  this.goToMark = function(mark) {
    var markFound = false;
    for (ii = 0; ii < this.marks.length; ii++) {
      if (this.marks[ii] == mark) {
        this.cell = ii; markFound = true; break;
      }
    }
    if (this.tape[ii] == null) { this.tape[ii] = ""; }
    if (markFound == false) {
      process.stdout.write("badmark '" + mark + "'!");
      process.exit();
    }
  }

  this.clip = function() {
    if (this.work == "") return;
    this.work = this.work.substring(0, this.work.length-1);
  }

  this.clop = function() {
    if (this.work == "") return;
    this.work = this.work.substring(1);
  }

  this.swap = function() {
    //if (this.tape[this.tapePointer] == null) 
    //  this.tape[this.tapePointer] == "";
    var text = this.work;
    this.work = this.tape[this.tapePointer];
    this.tape[this.tapePointer] = text;
  }

  /* 
  go code:
  func isInClass(typeFn fn, s string) bool {
    if s == "" { return false; }
    for _, rr := range s {
      //if !unicode.IsLetter(rr) {
      if !typeFn(rr) { return false }
    }
    return true
  }
  */

  /* range in format 'a,z' */
  /*
  // go code
  func isInRange(start rune, end rune, s string) bool {
    if s == "" { return false; }
    for _, rr := range s {
      if (rr < start) || (rr > end) { return false }
    }
    return true
  }
  */

  // this is where the actual parsing/compiling code should go
  // so that it can be used by other go classes/objects. Also
  // should have a stream argument.
  this.parse = function(reader, writer) {
  } 

 } /* machine */


  var mm = new Machine();
  var restart = false; 
  // create a dummy newline so that doc structures work even
// on the first line of the file/stream.
mm.work += "nl*"
mm.push();
script: 
  while (mm.peep != null) { 
    
    /* lex block */
    while (true) { 
      mm.readChar();           /* read */
      if (!mm.work.match(/^\p{Zs}+$/u)) {
        // count words per line with the accumulator
        mm.counter++;    /* a+ */
        /* whilenot */
        while ((mm.peep != null) && !mm.peep.match(/^\p{Zs}+$/u)) {
          if (mm.eof) { break; }
          mm.readChar();
        }
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "word*"
        mm.push();
        break
      }
      // keep leading space in newline token?
      if (mm.work.match(/^[\n]+$/)) {
        // set accumulator == 0 so that we can count words 
        // per line (and know which is the first word)
        mm.counter = 0;  /* zero */
        mm.charsRead = 0; /* nochars */
        /* while */
        while (mm.peep == " ".charAt(0)) {
          if (mm.eof) { break; }
          mm.readChar();
        }
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "nl*"
        mm.push();
        break
      }
      if (mm.work.match(/^[\r\t ]+$/)) {
        mm.work = "";          /* clear */
        if (!mm.eof) {
          restart = true; continue // restart
        }
      }
      break; 
    }
    if (restart) { restart = false; continue; }
    /* parse block */ 
    while (true) {
      // for debugging, add % as a latex comment.
      mm.work += "%%> line "
      mm.work += mm.linesRead; /* lines */
      mm.work += " char "
      mm.work += mm.charsRead; /* chars */
      mm.work += ": "
      process.stdout.write(mm.work);   /* print */
      mm.work = "";          /* clear */
      while (mm.pop()) {}   /* unstack */ 
      process.stdout.write(mm.work);   /* print */
      while (mm.push()) {}  /* stack */
      mm.work += "\n"
      process.stdout.write(mm.work);   /* print */
      mm.work = "";          /* clear */
      // -------------
      // 1 token
      mm.pop();
      if (mm.work == "nl*") {
        /* nop eliminated */
      }
      // here we classify words into other tokens
      // we can use accumulator with a+ a- to determine if current
      // word is the first word of the line, or even count number of 
      // words per line. This should simplify grammar items such as
      // nl/---  and nl/star/ etc
      // another advantage, is that we can dispense with tokens such as 
      // ---, >> etc and not have to get rid of them later.
      if (mm.work == "word*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        // no numbers in headings!
        if (mm.work.match(/^[A-Z]+$/)) {
          mm.work = "";          /* clear */
          mm.work += "uuword*"
          mm.push();
          continue
        }
        // at least three --- on a newline marks a code block start
        // use 'count;' here to simplify. The token --- probably doesnt
        // need to exist.
        if (mm.work.startsWith("---") && mm.work == "-") {
          mm.work = "";          /* clear */
          mm.work += "---*"
          mm.push();
          continue
        }
        // >> on a newline marks a code line start
        if (mm.work == ">>") {
          mm.work += "*"
          mm.push();
          continue
        }
        // subheading marker
        if (mm.work.startsWith("....") && mm.work == ".") {
          mm.work = "";          /* clear */
          mm.work += "4dots*"
          mm.push();
          continue
        }
        // dash is used for lists 
        // only make a dash token if it is first word on the line
        if (mm.work == "-") {
          mm.work = "";          /* clear */
          mm.work += mm.counter; /* count */ 
          if (mm.work == "1") {
            mm.work = "";          /* clear */
            mm.work += "dash*"
            mm.push();
            continue
          }
          mm.work = "";          /* clear */
          mm.work += mm.tape[mm.cell]; /* get */
        }
        // ordered list start token 
        // only make token if it is first word on the line
        if (mm.work == "o/-" || mm.work == "O/-" || mm.work == "0/-") {
          mm.work = "";          /* clear */
          mm.work += mm.counter; /* count */ 
          if (mm.work == "1") {
            mm.work = "";          /* clear */
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work += "olist*"
            mm.push();
            continue
          }
          mm.work = "";          /* clear */
          mm.work += mm.tape[mm.cell]; /* get */
        }
        // unordered list start token 
        if (mm.work == "u/-" || mm.work == "U/-") {
          mm.work = "";          /* clear */
          mm.work += mm.counter; /* count */ 
          if (mm.work == "1") {
            mm.work = "";          /* clear */
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work += "ulist*"
            mm.push();
            continue
          }
          mm.work = "";          /* clear */
          mm.work += mm.tape[mm.cell]; /* get */
        }
        // definition/description list start token 
        // need to parse a bit differently because of the desc
        if (mm.work == "d/-" || mm.work == "D/-") {
          mm.work = "";          /* clear */
          mm.work += mm.counter; /* count */ 
          if (mm.work == "1") {
            mm.work = "";          /* clear */
            // read description here, but have to escape special
            // verb cant go in here. Special chars will crash this. 
            mm.work += "\n \\item["
            /* whilenot */
            while ((mm.peep != null) && !mm.peep.match(/^[\n:]+$/)) {
              if (mm.eof) { break; }
              mm.readChar();
            }
            mm.work += "]"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
            mm.work += "dlist*"
            mm.push();
            continue
          }
          mm.work = "";          /* clear */
          mm.work += mm.tape[mm.cell]; /* get */
        }
        // star on newline marks emphasis, list or code description 
        // probably dont need star token.
        if (mm.work == "*") {
          // check that * is 1st 'word' on line using accumulator
          mm.work = "";          /* clear */
          mm.work += mm.counter; /* count */ 
          if (mm.work != "1") {
            mm.work = "";          /* clear */
            mm.work += "*"
          }
          if (mm.work == "1") {
            mm.work = "";          /* clear */
            /* while */
            while ((mm.peep != null) && mm.peep.match(/^[ \t\f]+$/)) {
              if (mm.eof) { break; }
              mm.readChar();
            }
            mm.work = "";          /* clear */
            /* whilenot */
            while ((mm.peep != null) && !mm.peep.match(/^[\n]+$/)) {
              if (mm.eof) { break; }
              mm.readChar();
            }
            if (mm.work.length > 0) { 
              mm.work = mm.work.charAt(0).toUpperCase() +   mm.work.substring(1).toLowerCase(); /* cap */ 
            }
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
            // this is a trick, because we want special LaTeX chars to
            // be escaped. So, will add \\emph{} after next replace code. 
            mm.work += "::EMPH::"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.tape[mm.cell] = mm.work;  /* put */
            //add "emline*"; push; .reparse
          }
        }
        // need to escape % # } \ and others
        // & % $ # _ { } ~ ^ \   
        // \textasciitilde, \textasciicircum, and \textbackslash
        /* replace */
        mm.work = mm.work.replace("\\", "\\textbackslash ");
        
        /* replace */
        mm.work = mm.work.replace("&", "\\&");
        
        /* replace */
        mm.work = mm.work.replace("%", "\\%");
        
        /* replace */
        mm.work = mm.work.replace("$", "\\$");
        
        /* replace */
        mm.work = mm.work.replace("#", "\\#");
        
        /* replace */
        mm.work = mm.work.replace("_", "\\_");
        
        /* replace */
        mm.work = mm.work.replace("{", "\\{");
        
        /* replace */
        mm.work = mm.work.replace("}", "\\}");
        
        /* replace */
        mm.work = mm.work.replace("~", "\\textasciitilde");
        
        /* replace */
        mm.work = mm.work.replace("^", "\\textasciicircum");
        
        /* replace */
        mm.work = mm.work.replace(">", "\\textgreater ");
        
        /* replace */
        mm.work = mm.work.replace("<", "\\textless ");
        
        /* replace */
        mm.work = mm.work.replace("LaTeX", "\\LaTeX{}");
        
        // now make the emphasis line token, after special chars have 
        // been escaped.
        if (mm.work.startsWith("::EMPH::")) {
          /* replace */
          mm.work = mm.work.replace("::EMPH::", " \\emph{");
          
          mm.work += "}"
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
          mm.work += "emline*"
          mm.push();
          continue
        }
        // If a previous test has matched, then the workspace should
        // be clear, and so none of the following will match.
        // graphical key representations
        if (mm.work.startsWith("[") && mm.work.endsWith("]")) {
          /* replace */
          mm.work = mm.work.replace("[esc]", "\\Esc");
          
          /* replace */
          mm.work = mm.work.replace("[enter]", "\\Enter");
          
          /* replace */
          mm.work = mm.work.replace("[return]", "\\Enter");
          
          /* replace */
          mm.work = mm.work.replace("[insert]", "\\Ins");
          
          /* replace */
          mm.work = mm.work.replace("[shift]", "\\Shift");
          
          /* replace */
          mm.work = mm.work.replace("[delete]", "\\Del");
          
          /* replace */
          mm.work = mm.work.replace("[home]", "\\Home");
          
          // keys defined by 'keystroke' package, can make new ones.
          // \Enter \Del  \Ins    \Esc   \Shift  \Ctrl  \Home
          // \End   \PgUp \PgDown \PrtSc \Scroll \Break
        }
        //replace '\\n' "\\textbackslash n";
        //replace '\\f' "\\textbackslash f";
        //replace '\\r' "\\textbackslash r";
        //replace '\\t' "\\textbackslash t";
        mm.tape[mm.cell] = mm.work;  /* put */
        // urls, not so important for LaTex (and pdf) output.
        // Dont really need a token because we can render immediately
        // Could maybe render them as footnotes
        if (mm.work.startsWith("http://") || mm.work.startsWith("https://") || mm.work.startsWith("www.") || mm.work.startsWith("ftp://") || mm.work.startsWith("sftp://")) {
          // clear; add "url*"; push; .reparse
          // render as fixed pitch font
          mm.work = "";          /* clear */
          mm.work += "\\url{"
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "}"
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
        }
        // format acronyms as a small capital font, case insensitive
        mm.work = mm.work.toLowerCase();/* lower */
        if (mm.work == "antlr" || mm.work == "pdf" || mm.work == "json" || mm.work == "ebnf" || mm.work == "bnf" || mm.work == "dns" || mm.work == "html") {
          mm.work = "";          /* clear */
          mm.work += "\\textsc{\\textbf{"
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "}}"
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
        }
        // restore the mixed-case version of the input word
        if (mm.work != "") {
          mm.work = "";          /* clear */
          mm.work += mm.tape[mm.cell]; /* get */
        }
        // filenames, could be elided with quoted filenames
        if (mm.work == "parse>" || mm.work == "print" || mm.work == "pop" || mm.work == "push" || mm.work == "get" || mm.work == "put" || mm.work == ".reparse" || mm.work == ".restart" || mm.work == "add" || mm.work == "sed" || mm.work == "awk" || mm.work == "grep" || mm.work == "pep" || mm.work == "nom" || mm.work == "less" || mm.work == "stdin" || mm.work == "stdout" || mm.work == "bash" || mm.work == "lex" || mm.work == "yacc" || mm.work == "flex" || mm.work == "bison" || mm.work == "lalr" || mm.work == "gnu" || mm.work.endsWith(".h") || mm.work.endsWith(".c") || mm.work.endsWith(".a") || mm.work.endsWith(".txt") || mm.work.endsWith(".doc") || mm.work.endsWith(".py") || mm.work.endsWith(".rb") || mm.work.endsWith(".rs") || mm.work.endsWith(".java") || mm.work.endsWith(".class") || mm.work.endsWith(".tcl") || mm.work.endsWith(".tk") || mm.work.endsWith(".sw") || mm.work.endsWith(".js") || mm.work.endsWith(".go") || mm.work.endsWith(".pp") || mm.work.endsWith(".pss") || mm.work.endsWith(".cpp") || mm.work.endsWith(".pl") || mm.work.endsWith(".html") || mm.work.endsWith(".pdf") || mm.work.endsWith(".tex") || mm.work.endsWith(".sh") || mm.work.endsWith(".css") || mm.work.endsWith(".out") || mm.work.endsWith(".log") || mm.work.endsWith(".png") || mm.work.endsWith(".jpg") || mm.work.endsWith(".jpeg") || mm.work.endsWith(".bmp") || mm.work.endsWith(".mp3") || mm.work.endsWith(".wav") || mm.work.endsWith("aux") || mm.work.endsWith(".tar") || mm.work.endsWith(".gz") || mm.work.endsWith("/")) {
          mm.work = "";          /* clear */
          mm.work += "\\texttt{"
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "}"
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
        }
        // mark up language names
        if (mm.work == "python" || mm.work == "java" || mm.work == "ruby" || mm.work == "perl" || mm.work == "tcl" || mm.work == "rust" || mm.work == "swift" || mm.work == "markdown" || mm.work == "c" || mm.work == "c++") {
          mm.work = "";          /* clear */
          mm.work += "\\textit{\\texttt{"
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "}}"
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
        }
        // paths and directories ? 
        if (mm.work.startsWith("../") && mm.work != "../") {
          mm.work = "";          /* clear */
          mm.work += "\\texttt{"
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "}"
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
        }
        if (mm.work.startsWith("\"") && mm.work.endsWith("\"") && mm.work != "\"\"" && mm.work != "\"") {
          // filenames in quotes
          mm.clip();
          mm.clop();
          mm.tape[mm.cell] = mm.work;  /* put */
          // quoted uppercase words in headings
          if (mm.work.match(/^[A-Z]+$/)) {
            // add LaTeX curly quotes to the heading word
            mm.work = "";          /* clear */
            mm.work += "``"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "''"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
            mm.work += "uuword*"
            mm.push();
            continue
          }
          // markup language names
          if (mm.work == "python" || mm.work == "java" || mm.work == "ruby" || mm.work == "perl" || mm.work == "tcl" || mm.work == "rust" || mm.work == "swift" || mm.work == "markdown" || mm.work == "c" || mm.work == "c++" || mm.work == "forth") {
            mm.work = "";          /* clear */
            mm.work += "``\\textit{\\texttt{"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "}}''"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
          // markup filenames and some unix and pep/nom names as fixed-pitch
          // font. 
          if (mm.work == "pep" || mm.work == "parse>" || mm.work == "print" || mm.work == "pop" || mm.work == "push" || mm.work == "get" || mm.work == "put" || mm.work == ".reparse" || mm.work == ".restart" || mm.work == "add" || mm.work == "sed" || mm.work == "awk" || mm.work == "grep" || mm.work == "pep" || mm.work == "nom" || mm.work == "less" || mm.work == "stdin" || mm.work == "stdout" || mm.work == "bash" || mm.work.endsWith(".h") || mm.work.endsWith(".c") || mm.work.endsWith(".a") || mm.work.endsWith(".txt") || mm.work.endsWith(".doc") || mm.work.endsWith(".py") || mm.work.endsWith(".rb") || mm.work.endsWith(".rs") || mm.work.endsWith(".java") || mm.work.endsWith(".class") || mm.work.endsWith(".tcl") || mm.work.endsWith(".tk") || mm.work.endsWith(".sw") || mm.work.endsWith(".js") || mm.work.endsWith(".go") || mm.work.endsWith(".pp") || mm.work.endsWith(".pss") || mm.work.endsWith(".cpp") || mm.work.endsWith(".pl") || mm.work.endsWith(".html") || mm.work.endsWith(".pdf") || mm.work.endsWith(".tex") || mm.work.endsWith(".sh") || mm.work.endsWith(".css") || mm.work.endsWith(".out") || mm.work.endsWith(".log") || mm.work.endsWith(".png") || mm.work.endsWith(".jpg") || mm.work.endsWith(".jpeg") || mm.work.endsWith(".bmp") || mm.work.endsWith(".mp3") || mm.work.endsWith(".wav") || mm.work.endsWith("aux") || mm.work.endsWith(".tar") || mm.work.endsWith(".gz") || mm.work.endsWith(";")) {
            mm.work = "";          /* clear */
            mm.work += "``\\texttt{"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "}''"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
          // everything else in quotes (but only words without spaces!)
          if (mm.work != "") {
            mm.work = "";          /* clear */
            mm.work += "``\\textit{"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "}''"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
        }
        // filenames 
        // crude pattern checking.
        if (mm.work.startsWith("/") && mm.work != "/") {
          mm.clip();
          if (mm.work.endsWith(".")) {
            mm.work = "";          /* clear */
            mm.work += "\\texttt{"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "}"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
          mm.clip();
          if (mm.work.endsWith(".")) {
            mm.work = "";          /* clear */
            mm.work += "\\texttt{"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "}"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
          mm.clip();
          if (mm.work.endsWith(".")) {
            mm.work = "";          /* clear */
            mm.work += "\\texttt{"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "}"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
        }
        // emphasis is *likethis* (only words, not phrases) 
        if (mm.work.startsWith("*") && mm.work.endsWith("*") && mm.work != "**") {
          mm.clip();
          mm.clop();
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
          mm.work += "\\textbf{\\emph{"
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "}}"
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
        }
        // && starting a line marks the document title 
        // the document 'title' after && or first heading, & has already 
        // been escaped
        if (mm.work == "\\&\\&") {
          mm.work = "";          /* clear */
          mm.work += mm.counter; /* count */ 
          if (mm.work == "1") {
            mm.work = "";          /* clear */
            /* while */
            while ((mm.peep != null) && mm.peep.match(/^[ \t\f]+$/)) {
              if (mm.eof) { break; }
              mm.readChar();
            }
            mm.work = "";          /* clear */
            /* whilenot */
            while ((mm.peep != null) && !mm.peep.match(/^[\n]+$/)) {
              if (mm.eof) { break; }
              mm.readChar();
            }
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
            mm.work += "\\centerline{\\Large \\bf "
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "} \\medskip \n"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
        }
        // A quote, starting the line
        if (mm.work == "quote:") {
          mm.work = "";          /* clear */
          mm.work += mm.counter; /* count */ 
          if (mm.work == "1") {
            // \begin{center}
            //    {\huge \`\`}\textit{$quote}{\huge ''}
            //    \textsc{$quoteauthor}
            //  \end{center}
            mm.work = "";          /* clear */
            /* while */
            while ((mm.peep != null) && mm.peep.match(/^[ \t\f]+$/)) {
              if (mm.eof) { break; }
              mm.readChar();
            }
            mm.work = "";          /* clear */
            /* whilenot */
            while ((mm.peep != null) && !mm.peep.match(/^[\n]+$/)) {
              if (mm.eof) { break; }
              mm.readChar();
            }
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
            mm.work += "\\begin{center}{\\huge ``}\\textit{"
            mm.work += mm.tape[mm.cell]; /* get */
            mm.work += "}{\\huge ''}\\end{center} \n"
            mm.tape[mm.cell] = mm.work;  /* put */
            mm.work = "";          /* clear */
          }
        }
        mm.work = "";          /* clear */
        mm.work += "word*"
      }
      mm.pop();
      // -------------
      // 2 tokens
      // ellide text
      if (mm.work == "text*text*" || mm.work == "word*text*" || mm.work == "word*word*" || mm.work == "text*word*" || mm.work == "word*uuword*" || mm.work == "text*uuword*" || mm.work == "uutext*word*" || mm.work == "uuword*word*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      // tokenlist:
      // --- >> 4dots codeblock codeline emline nl text uutext uuword word
      // codeblock,
      // remove pesky newline tokens, 4dots handled elsewhere
      // not really working
      if (mm.work == "nl*text*" || mm.work == "nl*word*" || mm.work == "bl*text*" || mm.work == "bl*word*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      if (mm.work == "nl*dash*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "dash*"
        mm.push();
        continue
      }
      if (mm.work == "nl*emline*" || mm.work == "bl*emline*") {
        mm.work = "";          /* clear */
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "emline*"
        mm.push();
        continue
      }
      // We are using a dummy nl* token at the start of the doc, so the 
      // codeblock* codeline* etc tokens are not able to be the first token
      // of the document. So we can remove the !"codeblock*". clause.
      // multiline codeblocks with no caption 
      if (mm.work.endsWith("codeblock*") && !mm.work.startsWith("emline*")) {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n\n \\begin{tabular}{l}\n  "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += " \\end{tabular} \n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      // single line code with no caption 
      if (mm.work.endsWith("codeline*") && !mm.work.startsWith("emline*")) {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n\n \\begin{tabular}{l}\n  "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += " \\end{tabular} \n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      // eliminate emline* tokens (not followed by codeblock/line)
      // the logic is slightly different because emline* is significant before
      // other tokens, not after.
      // also, consider emline*text*nl*
      if (mm.work.startsWith("emline*") && !mm.work.endsWith("nl*") && !mm.work.endsWith("codeline*") && !mm.work.endsWith("codeblock*")) {
        /* replace */
        mm.work = mm.work.replace("emline*", "text*");
        
        mm.push();
        mm.push();
        // make emline display on its own line, even when not
        // followed by codeline/codeblock. LaTeX will treat a blank line 
        // as a paragraph break, but \newline or \\ could be used.
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "\n\n"
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n\n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        continue
      }
      // remove insignificant 4dots* tokens, 
      // 4 dots (....) marks a subheading and always comes at the end of 
      // all capitals line. Just replacing the 4dots token with a text
      // token is safer and more logical.
      if (mm.work.endsWith("4dots*") && !mm.work.startsWith("uutext*") && !mm.work.startsWith("uuword*")) {
        /* replace */
        mm.work = mm.work.replace("4dots*", "text*");
        
        mm.push();
        mm.push();
        continue
      }
      // remove insignificant ---* tokens
      if (mm.work.endsWith("---*") && !mm.work.startsWith("nl*") && !mm.work.startsWith("bl*")) {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      // remove insignificant >>* tokens
      // lets assume that codelines cant start a document? Or lets
      // generate a dummy nl* token at the start of the document to 
      // make parsing easier.
      // !">>*".E">>*".!B"nl*" {
      if (mm.work.endsWith(">>*") && !mm.work.startsWith("nl*") && !mm.work.startsWith("bl*")) {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      // ellide upper case text 
      if (mm.work == "uuword*uuword*" || mm.work == "uutext*uuword*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "uutext*"
        mm.push();
        continue
      }
      // a blank line token for terminating lists etc 
      // bl/bl should not happen really
      if (mm.work == "nl*nl*" || mm.work == "bl*nl*" || mm.work == "bl*bl*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "bl*"
        mm.push();
        continue
      }
      // ellide multiple newlines 
      //"nl*nl*" {
      //  clear; get; ++; get; --; put; clear;
      //  add "nl*"; push; .reparse
      //}
      // code line (starts with >>) 
      if (mm.work == "bl*>>*" || mm.work == "nl*>>*") {
        // ignore leading space.
        mm.work = "";          /* clear */
        /* while */
        while ((mm.peep != null) && mm.peep.match(/^[ \t\f]+$/)) {
          if (mm.eof) { break; }
          mm.readChar();
        }
        mm.work = "";          /* clear */
        // escape | so it doesnt terminate the verb environment.
        // but how to do it? or use lstlisting
        /* whilenot */
        while ((mm.peep != null) && !mm.peep.match(/^[\n]+$/)) {
          if (mm.eof) { break; }
          mm.readChar();
        }
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += " \\verb| "
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " |\n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "codeline*"
        mm.push();
        continue
      }
      // code block marker 
      if (mm.work == "bl*---*" || mm.work == "nl*---*") {
        mm.work = "";          /* clear */
        mm.until(",,,");
        mm.clip();
        mm.clip();
        mm.clip();
        // remove excessive indentation.
        /* replace */
        mm.work = mm.work.replace("\n   ", "\n");
        
        mm.tape[mm.cell] = mm.work;  /* put */
        /* while */
        while (mm.peep == ",".charAt(0)) {
          if (mm.eof) { break; }
          mm.readChar();
        }
        mm.work = "";          /* clear */
        mm.work += "\n \\begin{lstlisting}[breaklines]"
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n \\end{lstlisting} \n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "codeblock*"
        mm.push();
        continue
      }
      // a code block with its preceding description
      if (mm.work == "emline*codeblock*") {
        mm.work = "";          /* clear */
        mm.work += "\n\n \\begin{tabular}{l}\n  "
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " \\\\ "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += " \\end{tabular} \n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      // a code line with its preceding description
      // add some tabular LaTeX markup here.
      if (mm.work == "emline*codeline*") {
        mm.work = "";          /* clear */
        mm.work += "\n\n \\begin{tabular}{l}\n  "
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " \\\\ \n"
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += " \\end{tabular} \n"
        //add " \\end{figure}";
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*"
        mm.push();
        continue
      }
      // probably indicates an empty - at the end of a list
      // add a dummy text token
      if (mm.work == "olist*bl*" || mm.work == "ulist*bl*" || mm.work == "dlist*bl*") {
        mm.push();
        mm.work = "";          /* clear */
        mm.work += "empty"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "\n\n"
        mm.increment();     /* ++ */ 
        
        mm.tape[mm.cell] = mm.work;  /* put */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        mm.work += "text*bl*"
        mm.push();
        mm.push();
        continue
      }
      // or use this to terminate the list, and so allow nested lists
      if (mm.work == "olist*dash*" || mm.work == "ulist*dash*" || mm.work == "dlist*dash*") {
        mm.push();
        mm.work = "";          /* clear */
        mm.work += "empty"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "text*dash*"
        mm.push();
        mm.push();
        continue
      }
      mm.pop();
      // -------------
      // 3 tokens
      if (mm.work == "olist*word*dash*" || mm.work == "ulist*word*dash*" || mm.work == "dlist*word*dash*" || mm.work == "olist*word*bl*" || mm.work == "ulist*word*bl*" || mm.work == "dlist*word*bl*") {
        /* replace */
        mm.work = mm.work.replace("word*", "text*");
        
        // or dont reparse
        // push; push; push; .reparse
      }
      // eliminate dashes that are not part of a list
      // eg: ulist*dash* olist*text*dash* dlist*word*dash*
      // the logic is tricky, how do we know there are really 3 tokens 
      // here, and not 2. This is the problem with negative tests.
      // doesnt matter because not altering attributes here.
      if (mm.work.endsWith("dash*")) {
        if (!mm.work.startsWith("ulist*text*") && !mm.work.startsWith("olist*text*") && !mm.work.startsWith("dlist*text*")) {
          /* replace */
          mm.work = mm.work.replace("dash*", "text*");
          
          mm.push();
          mm.push();
          mm.push();
          continue
        }
      }
      if (mm.work == "olist*text*dash*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n \\item "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "olist*"
        mm.push();
        continue
      }
      // could be ellided, but for readability, no
      if (mm.work == "ulist*text*dash*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n \\item "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "ulist*"
        mm.push();
        continue
      }
      // 
      if (mm.work == "dlist*text*dash*") {
        mm.work = "";          /* clear */
        // already have \item start
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += " "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        // also, put a \verbatim in [] because text is not escaped??
        mm.work += "\n \\item["
        /* whilenot */
        while ((mm.peep != null) && !mm.peep.match(/^[\n:]+$/)) {
          if (mm.eof) { break; }
          mm.readChar();
        }
        mm.work += "] "
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.work += "dlist*"
        mm.push();
        continue
      }
      // finish off the ordered list, also could finish it off with 
      // ulist*dash* ??
      if (mm.work == "olist*text*bl*") {
        mm.work = "";          /* clear */
        mm.work += "\n \\begin{enumerate}\n"
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n \\item "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "\n \\end{enumerate}\n\n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        // insert the blankline attribute
        mm.work += "\n\n"
        mm.increment();     /* ++ */ 
        
        mm.tape[mm.cell] = mm.work;  /* put */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        mm.work += "text*bl*"
        mm.push();
        mm.push();
        continue
      }
      // finish off the unordered list
      if (mm.work == "ulist*text*bl*") {
        mm.work = "";          /* clear */
        mm.work += "\n \\begin{itemize}\n"
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n \\item "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "\n \\end{itemize}\n\n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        // insert the blankline attribute
        mm.work += "\n\n"
        mm.increment();     /* ++ */ 
        
        mm.tape[mm.cell] = mm.work;  /* put */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        mm.work += "text*bl*"
        mm.push();
        mm.push();
        continue
      }
      // finish off the description list
      if (mm.work == "dlist*text*bl*") {
        // or check here if it is D/- or d/- for nextline style
        // or use \hfill \\ on each item which also works
        mm.work = "";          /* clear */
        mm.work += "\n \\begin{description}[style=nextline]\n"
        mm.work += mm.tape[mm.cell]; /* get */
        mm.work += "\n "
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "\n \\end{description}\n\n"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        // insert the blankline attribute
        mm.work += "\n\n"
        mm.increment();     /* ++ */ 
        
        mm.tape[mm.cell] = mm.work;  /* put */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        mm.work += "text*bl*"
        mm.push();
        mm.push();
        continue
      }
      // top level headings, all upper case on the line in the source document.
      // dont need a "heading" token because we dont parse the document as a 
      // heirarchy, we just render things as we find them in the stream.
      if (mm.work == "nl*uutext*nl*" || mm.work == "nl*uuword*nl*" || mm.work == "bl*uutext*nl*" || mm.work == "bl*uuword*nl*") {
        mm.work = "";          /* clear */
        // Check that heading is at least 4 chars
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.clip();
        mm.clip();
        mm.clip();
        if (mm.work == "") {
          mm.work += "nl*text*nl*"
          mm.push();
          mm.push();
          mm.push();
          continue
        }
        mm.work = "";          /* clear */
        // make headings capital case
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        // capitalise even 1st word in latex curly quotes
        // add "<<heading\n"; print; replace "<<heading\n" "";
        if (mm.work.startsWith("``")) {
          mm.clop();
          mm.clop();
        }
        if (mm.work.length > 0) { 
          mm.work = mm.work.charAt(0).toUpperCase() +   mm.work.substring(1).toLowerCase(); /* cap */ 
        }
        mm.tape[mm.cell] = mm.work;  /* put */
        /* replace */
        mm.work = mm.work.replace("''", "");
        
        // add open curly quotes if there before.
        if (mm.work != mm.tape[mm.cell]) {
          mm.work = "";          /* clear */
          mm.work += "``"
          mm.work += mm.tape[mm.cell]; /* get */
        }
        mm.tape[mm.cell] = mm.work;  /* put */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        // newline
        mm.work += "\\section{"
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "}"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        // transfer nl value
        mm.increment();     /* ++ */ 
        
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "text*nl*"
        mm.push();
        mm.push();
        continue
      }
      // simple reductions 
      if (mm.work == "nl*text*nl*" || mm.work == "nl*word*nl*" || mm.work == "bl*text*nl*" || mm.work == "bl*word*nl*" || mm.work == "text*text*nl*" || mm.work == "emline*text*nl*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        mm.increment();     /* ++ */ 
        
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        // transfer newline value
        mm.work += "text*nl*"
        mm.push();
        mm.push();
        continue
      }
      mm.pop();
      // -------------
      // 4 tokens
      // sub headings, 
      if (mm.work == "nl*uutext*4dots*nl*" || mm.work == "nl*uuword*4dots*nl*" || mm.work == "bl*uutext*4dots*nl*" || mm.work == "bl*uuword*4dots*nl*") {
        mm.work = "";          /* clear */
        // Check that sub heading text is at least 4 chars ?
        // yes but need to transfer 4dots and nl
        // ++; get; --; clip; clip; clip; 
        // "" { add "nl*text*nl*"; push; push; push; .reparse }
        mm.work = "";          /* clear */
        // make subheadings capital case
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        // capitalise even 1st word in latex curly quotes
        if (mm.work.startsWith("``")) {
          mm.clop();
          mm.clop();
        }
        if (mm.work.length > 0) { 
          mm.work = mm.work.charAt(0).toUpperCase() +   mm.work.substring(1).toLowerCase(); /* cap */ 
        }
        mm.tape[mm.cell] = mm.work;  /* put */
        /* replace */
        mm.work = mm.work.replace("''", "");
        
        // add open curly quotes if there before.
        if (mm.work != mm.tape[mm.cell]) {
          mm.work = "";          /* clear */
          mm.work += "``"
          mm.work += mm.tape[mm.cell]; /* get */
        }
        mm.tape[mm.cell] = mm.work;  /* put */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        // newline
        mm.work += "\\subsection{"
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "}"
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        // transfer nl value
        mm.increment();     /* ++ */ 
        
        mm.increment();     /* ++ */ 
        
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.tape[mm.cell] = mm.work;  /* put */
        mm.work = "";          /* clear */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "text*nl*"
        mm.push();
        mm.push();
        continue
      }
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      if (mm.eof) {
        // or use 'unstack' but does it adjust the tape pointer?
        mm.pop();
        mm.pop();
        mm.pop();
        mm.pop();
        mm.pop();
        mm.pop();
        // "nl*word*","nl*text*" have already been dealt with.
        // we would like "permissive" parsing, because this is just
        // a document format, not code, so will just check for starting
        // text token
        //"text*nl*","text*bl","text*" {
        if (mm.work.startsWith("text*") || mm.work.startsWith("word*")) {
          // show the token parse stack at the top of the document
          mm.increment();     /* ++ */ 
          
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
          mm.work += "%% Document parse-stack is: "
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "\n"
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          mm.work = "";          /* clear */
          // make a valid LaTeX document
          mm.work += ""
          mm.work += "\n  %% <start-document>"
          mm.work += "\n  %% -------------------------------------------"
          mm.work += "\n  %%  latex generated by: mark.latex.pss "
          mm.work += "\n  %%   from source file : "
          mm.work += "\n  %%                  on: "
          mm.work += "\n  %% -------------------------------------------"
          mm.work += "\n"
          mm.work += "\n  \\documentclass[a4paper,12pt]{article}"
          mm.work += "\n  \\usepackage[margin=4pt,noheadfoot]{geometry}"
          mm.work += "\n  \\usepackage{color}                   %% to use colours, use 'xcolor' for more"
          mm.work += "\n  \\usepackage{multicol}                %% for multiple columns"
          mm.work += "\n  \\usepackage{keystroke}               %% for keyboard key images"
          mm.work += "\n  \\usepackage[toc]{multitoc}           %% for multi column table of contents"
          mm.work += "\n  \\usepackage{tocloft}                 %% to customize the table of contents"
          mm.work += "\n  \\setcounter{tocdepth}{2}             %% only display 2 levels in the contents"
          mm.work += "\n  \\setlength{\\cftbeforesecskip}{0cm}   %% make the toc more compact"
          mm.work += "\n  \\usepackage{listings}                %% for nice code listings"
          mm.work += "\n  \\usepackage{caption}                 %% "
          mm.work += "\n  \\lstset{"
          mm.work += "\n    captionpos=t,"
          mm.work += "\n    language=bash,"
          mm.work += "\n    basicstyle=\\ttfamily,           %% fixed pitch font"
          mm.work += "\n    xleftmargin=0pt,                %% margin on the left outside the frames"
          mm.work += "\n    framexleftmargin=0pt,"
          mm.work += "\n    framexrightmargin=0pt,"
          mm.work += "\n    framexbottommargin=5pt,"
          mm.work += "\n    framextopmargin=5pt,"
          mm.work += "\n    breaklines=true,                %% break long code lines"
          mm.work += "\n    breakatwhitespace=false,        %% break long code lines anywhere"
          mm.work += "\n    breakindent=10pt,               %% reduce the indent from 20pt to 10"
          mm.work += "\n    postbreak=\\mbox{{\\color{blue}\\small$\\Rightarrow$\\space}},  %% mark with arrow"
          mm.work += "\n    showstringspaces=false,            %% dont show spaces within strings"
          mm.work += "\n    framerule=2pt,                     %% thickness of the frames"
          mm.work += "\n    frame=top,frame=bottom,"
          mm.work += "\n    rulecolor=\\color{lightgrey}, "
          mm.work += "\n    % frame=l"
          mm.work += "\n    % define special comment delimiters '##(' and ')'"
          mm.work += "\n    % moredelim=[s][\\color{grey}\\itshape\\footnotesize\\ttfamily]{~(}{)},"
          mm.work += "\n  }   %% source code settings"
          mm.work += "\n  \\usepackage{graphicx}                %% to include images"
          mm.work += "\n  \\usepackage{fancybox}                %% boxes with rounded corners"
          mm.work += "\n  \\usepackage{wrapfig}                 %% flow text around tables, images"
          mm.work += "\n  \\usepackage{tabularx}                %% change width of tables"
          mm.work += "\n  \\usepackage[table]{xcolor}           %% alternate row colour tables"
          mm.work += "\n  \\usepackage{booktabs}                %% for heavier rules in tables"
          mm.work += "\n  \\usepackage[small,compact]{titlesec} %% sections more compact, less space"
          mm.work += "\n  \\usepackage{enumitem}                %% more compact and better lists"
          mm.work += "\n  \\setlist{noitemsep}                  %% reduce list item spacing"
          mm.work += "\n  \\usepackage{hyperref}     %% make urls into hyperlinks"
          mm.work += "\n  \\hypersetup{              %% add pdftex if only pdf output is required"
          mm.work += "\n     colorlinks=false,       %% set up the colours for the hyperlinks"
          mm.work += "\n     linkcolor=black,        %% internal document links black"
          mm.work += "\n     urlcolor=black,        %% url links black"
          mm.work += "\n     frenchlinks=true,"
          mm.work += "\n     bookmarks=true, pdfpagemode=UseOutlines}"
          mm.work += "\n"
          mm.work += "\n  \\geometry{ left=1.0in,right=1.0in,top=1.0in,bottom=1.0in }"
          mm.work += "\n  %% define some colours to use"
          mm.work += "\n  \\definecolor{lightgrey}{gray}{0.70}"
          mm.work += "\n  \\definecolor{grey}{gray}{0.30}"
          mm.work += "\n"
          mm.work += "\n  %% titlesec: create framed section headings"
          mm.work += "\n  %% \\titleformat{\\section}[frame]{\\normalfont}"
          mm.work += "\n  %%   {\\filleft \\footnotesize \\enspace Section \\thesection\\enspace\\enspace}"
          mm.work += "\n  %%   {3pt} {\\bfseries\\itshape\\filright}"
          mm.work += "\n"
          mm.work += "\n  \\title{The Pep/nom parsing language and machine}"
          mm.work += "\n  \\author{m.j.bishop}"
          mm.work += "\n  \\date{\\today}"
          mm.work += "\n  \\setlength{\\parindent}{0pt}"
          mm.work += "\n  %% \\setlength{\\parskip}{1ex}"
          mm.work += "\n"
          mm.work += "\n  %% label lists with stars"
          mm.work += "\n  \\renewcommand{\\labelitemi}{$\\star$}"
          mm.work += "\n"
          mm.work += "\n  \\parindent=0pt"
          mm.work += "\n  \\parskip=6pt"
          mm.work += "\n  \\begin{document}"
          mm.work += "\n"
          mm.work += "\n  "
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "\n\\end{document} \n"
          mm.work += "\n\n %% Document parsed as text*!\n"
          // show parse-stack at end of doc as well
          mm.increment();     /* ++ */ 
          
          mm.work += " %% Document parse-stack is: "
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "\n"
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          process.stdout.write(mm.work);   /* print */
          break script;
        }
        while (mm.push()) {}  /* stack */
        mm.work += "Document parsed unusually!\n"
        mm.work += "Stack at line "
        mm.work += mm.linesRead; /* lines */
        mm.work += " char "
        mm.work += mm.charsRead; /* chars */
        mm.work += ": "
        process.stdout.write(mm.work);   /* print */
        mm.work = "";          /* clear */
        while (mm.pop()) {}   /* unstack */ 
        process.stdout.write(mm.work);   /* print */
        while (mm.push()) {}  /* stack */
        mm.work += "\n"
        process.stdout.write(mm.work);   /* print */
        mm.work = "";          /* clear */
        break script;
      }
      break; 
    } /* parse */
    
  }


/* end of translated javascript code */
