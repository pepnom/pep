/* Javacript code generated by 'compile.javascript.pss' */
var pp = require('./Machine'); 
var mm = new pp.Machine(); 
script: 
while (mm.peep != null) {
  lex: { 
    mm.read();
    if ((mm.workspace == "+") || (mm.workspace == "-")) {
      mm.put();
      mm.workspace = '';
      mm.add("opadd*");
      mm.push();
    }
    if ((mm.workspace == "*") || (mm.workspace == "/")) {
      mm.put();
      mm.workspace = '';
      mm.add("opmul*");
      mm.push();
    }
    if ((mm.workspace == "(") || (mm.workspace == ")")) {
      mm.put();
      mm.add("*");
      mm.push();
    }
    if (mm.testClass('[0-9]')) {
      mm.whilePeep('[0-9]');
      mm.put();
      mm.workspace = '';
      mm.add("number*");
      mm.push();
    }
    if (mm.testClass('[a-z]')) {
      mm.whilePeep('[a-z]');
      mm.put();
      mm.workspace = '';
      mm.add("variable*");
      mm.push();
    }
    if (mm.testClass('[:space:]')) {
      mm.workspace = '';
    }
    // a trick to catch bad characters. 
    // better would be a !"text" syntax but this is not implemented
    // yet (aug 2019)
    if ((mm.workspace == "")) {
      break lex;
    }
    mm.add(" << incorrect character (at character ");
    mm.chars();
    mm.add(" of input). \n");
    mm.print();
    break script;
  }
  parse: 
  while (true) { 
    // The parse/compile/translate/transform phase involves 
    // recognising series of tokens on the stack and "reducing" them
    // according to the required bnf grammar rules.
    mm.pop();
    // resolve numbers to expressions to simplify grammar rules
    // add a preceding space to numbers and variables.
    if ((mm.workspace == "number*") || (mm.workspace == "variable*")) {
      mm.workspace = '';
      mm.add(" ");
      mm.get();
      mm.put();
      mm.workspace = '';
      mm.add("exp*");
      mm.push();
      continue parse;
    }
    //-----------------
    // 3 tokens
    mm.pop();
    mm.pop();
    // we dont need any look ahead here because * and / have 
    // precedence.
    if ((mm.workspace == "exp*opmul*exp*")) {
      mm.workspace = '';
      mm.add(" (");
      mm.increment();
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.get();
      mm.increment();
      mm.increment();
      mm.get();
      mm.add(")");
      if (mm.tapePointer > 0) mm.tapePointer--; 
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*");
      mm.push();
      continue parse;
    }
    if ((mm.workspace == "(*exp*)*")) {
      mm.workspace = '';
      mm.increment();
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*");
      mm.push();
      continue parse;
    }
    if ((mm.peep == null)) {
      if ((mm.workspace == "exp*opadd*exp*")) {
        mm.workspace = '';
        mm.add(" (");
        mm.increment();
        mm.get();
        if (mm.tapePointer > 0) mm.tapePointer--; 
        mm.get();
        mm.increment();
        mm.increment();
        mm.get();
        mm.add(")");
        if (mm.tapePointer > 0) mm.tapePointer--; 
        if (mm.tapePointer > 0) mm.tapePointer--; 
        mm.put();
        mm.workspace = '';
        mm.add("exp*");
        mm.push();
        continue parse;
      }
    }
    //-----------------
    // 4 tokens
    mm.pop();
    if ((mm.workspace == "exp*opadd*exp*opadd*")) {
      mm.workspace = '';
      mm.add(" (");
      mm.increment();
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.get();
      mm.increment();
      mm.increment();
      mm.get();
      mm.add(")");
      if (mm.tapePointer > 0) mm.tapePointer--; 
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*opadd*");
      mm.push();
      mm.push();
      continue parse;
    }
    if ((mm.workspace == "exp*opadd*exp*)*")) {
      mm.workspace = '';
      mm.add(" (");
      mm.increment();
      mm.get();
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.get();
      mm.increment();
      mm.increment();
      mm.get();
      mm.add(")");
      if (mm.tapePointer > 0) mm.tapePointer--; 
      if (mm.tapePointer > 0) mm.tapePointer--; 
      mm.put();
      mm.workspace = '';
      mm.add("exp*)*");
      mm.push();
      mm.push();
      continue parse;
    }
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    if ((mm.peep == null)) {
      mm.pop();
      mm.pop();
      if ((mm.workspace == "exp*")) {
        mm.workspace = '';
        mm.add("Yes, its an expression! \n");
        mm.add("in lisp format: \n");
        mm.get();
        mm.add("\n");
        mm.print();
        mm.workspace = '';
        break script;
      }
      mm.push();
      mm.push();
      mm.add("no, not an expression. \n");
      mm.print();
      mm.workspace = '';
      break script;
    }
    break parse;
  }
} 
