
// code generated by "translate.js.pss" a pep script
// http://bumble.sf.net/books/pars/tr/

  var fs = require("fs");

  function visible(text) {
    if (text == null) return "EOF=null";
    text = text.replace(/\n/g, "\n");
    text = text.replace(/\t/g, "\t");
    text = text.replace(/\r/g, "\r");
    text = text.replace(/\f/g, "\f");
    return text
  }

  // this returns 0 when end of stream reached!!!
  console.read = len => {
    var read;
    var buff = Buffer.alloc(len);
    read = fs.readSync(process.stdin.fd, buff, 0, len);
    if (read == 0) { return null; } 
    return buff.toString();
  };

  function Machine()  {
   //FILE * inputstream;   //source of characters
   this.peep = "";         // next char in the stream, may have EOF
   this.stack = [];        // stack to hold parse tokens
   this.work = "";  // 
   this.tape = [];       // array of strings for token values 
   this.tape[0] = "";    // init first element of tape array 
   this.marks = [];      // array of marks on the tape (mark/go)
   this.cell = 0; // integer pointer to current tape cell
   this.counter = 0; // used for counting
   this.charsRead = 0;   // how many characters read from input stream
   this.linesRead = 1;   // how many lines already read from input stream 
   this.flag = false;    // used for tests (not here).
   this.delimiter = "*"; // to separate tokens on the stack
   this.escape = "\\"; // escape character, default "\
   this.peep = console.read(1);
   process.stdin.setEncoding("utf8");

   this.setInput = function(newInput) {
     process.stdout.write("to be implemented")
   };

   /* read one utf8 character from the input stream and 
      update the machine. */
   this.readChar = function() {
     if (this.eof) { process.exit(); }
     // increment line and char counters
     this.charsRead++;
     if (this.peep == "\n") { this.lines++; }
     this.work += this.peep;
     // read next char from stream
     this.peep = console.read(1);
     if (this.peep == null) { this.eof = true; }
   }

   // remove escape character: trivial method ?
   // check the python code for this, and the c code in machine.interp.c
   this.unescapeChar = function(char) {
     // if this.work = "" { return }
     this.work = this.work.replace(this.work, "\\"+c, c, -1)
   }

   // add escape character : trivial?
   this.escapeChar = function(char) {
     this.work = this.work.replace(c, "\\"+c, -1)
   }

  /** a helper function to count trailing escapes */
  this.countEscapes = function(suffix) {
    var count = 0;
    var ss = "";
    if (this.work.endsWith(suffix)) {
      ss = this.work.substring(0, this.work.lastIndexOf(suffix));
    }
    while (ss.endsWith(this.escape)) {
      ss = ss.substring(0, ss.lastIndexOf(this.escape));
      count++;
    }
    return count
  }


  // reads the input stream until the work ends with the
  // given character or text, ignoring escaped characters
  this.until = function(suffix) {
    if (this.eof) { return; }
    // read at least one character
    this.readChar();
    while (true) { 
      if (this.eof) { return; }
      // we need to count the this.Escape chars preceding suffix
      // if odd, keep reading, if even, stop
      if (this.work.endsWith(suffix)) {
        if (this.countEscapes(suffix) % 2 == 0) { return; }
      }
      this.readChar();
    }
  }  

  // BUT we can just call this.until(this.tape[this.cell]) ??

  /* increment the tape pointer (command ++) and grow the 
     tape and marks arrays if necessary */
  this.increment = function() { 
    this.cell++;
    if (this.cell >= this.tape.length) {
      // grow the marks/tape arrays by 20 when the 
      // tape size is exceeded.
      for (ii=0; ii++; ii<20) {
        this.tape[this.tape.length+ii] = ""; 
        this.marks[this.marks.length+ii] = "";
      }
      this.size = this.tape.length;
    }
  }

  /* pop the top token on the stack onto the beginning of the 
     workspace buffer */
  this.pop = function() {
    if (this.stack.length == 0) return false;
    this.work = this.stack.pop() + this.work;
    if (this.cell > 0) this.cell--;
    return true;
  }

  this.push = function() {
    if (this.work == "") return false;
    var first = this.work.indexOf(this.delimiter);
    if (first > -1) {
      this.stack.push(this.work.slice(0, first+1));
      this.work = this.work.slice(first+1);
    } else {
      this.stack.push(this.work);
      this.work = "";
    }
    // use increment to handle growing the tape and marks
    // arrays if required
    this.increment();
    return true;
  }

  this.printState = function() { 
    process.stdout.write(
      "Stack " + this.stack + " Work[" + this.work + 
      "] Peep[" + this.peep + "] \n");
    process.stdout.write(
      "Acc:" + this.counter + " Esc:" + this.escape + 
      " Delim:" + this.delimiter + " Chars:" + this.charsRead);
    process.stdout.write(
      " Lines:" + this.linesRead + " Cell:" + this.cell + 
      " EOF:" + this.eof + " \n");
    for (ii = 0; ii < this.tape.length; ii++) {
      process.stdout.write(ii + " [" + this.tape[ii] + "] \n");
      if (ii > 4) { return; }
    }
  } 

  this.goToMark = function(mark) {
    var markFound = false;
    for (ii = 0; ii < this.marks.length; ii++) {
      if (this.marks[ii] == mark) {
        this.cell = ii; markFound = true; break;
      }
    }
    if (this.tape[ii] == null) { this.tape[ii] = ""; }
    if (markFound == false) {
      process.stdout.write("badmark '" + mark + "'!");
      process.exit();
    }
  }

  this.clip = function() {
    if (this.work == "") return;
    this.work = this.work.substring(0, this.work.length-1);
  }

  this.clop = function() {
    if (this.work == "") return;
    this.work = this.work.substring(1);
  }

  this.swap = function() {
    //if (this.tape[this.tapePointer] == null) 
    //  this.tape[this.tapePointer] == "";
    var text = this.work;
    this.work = this.tape[this.tapePointer];
    this.tape[this.tapePointer] = text;
  }

  /* 
  go code:
  func isInClass(typeFn fn, s string) bool {
    if s == "" { return false; }
    for _, rr := range s {
      //if !unicode.IsLetter(rr) {
      if !typeFn(rr) { return false }
    }
    return true
  }
  */

  /* range in format 'a,z' */
  /*
  // go code
  func isInRange(start rune, end rune, s string) bool {
    if s == "" { return false; }
    for _, rr := range s {
      if (rr < start) || (rr > end) { return false }
    }
    return true
  }
  */

  // this is where the actual parsing/compiling code should go
  // so that it can be used by other go classes/objects. Also
  // should have a stream argument.
  this.parse = function(reader, writer) {
  } 

 } /* machine */


  var mm = new Machine();
  var restart = false; 
  /* while */
while ((mm.peep != null) && mm.peep.match(/^\p{Zs}+$/u)) {
  if (mm.eof) { break; }
  mm.readChar();
}
mm.work = "";          /* clear */
mm.work += "> Searching for palindromes and sub-palindromes \n"
mm.work += "> in the input. Strings of the same character are not \n"
mm.work += "> considered as palindromes (eg: xxxx or yyy). \n"
mm.work += "> This version does not ignore whitespace characters.\n"
mm.work += " Palidrome: text that is the same backwards.  \n"
mm.work += "  παλίν (palin) = back \n"
mm.work += "  δρομος (dromos) = running \n"
process.stdout.write(mm.work);   /* print */
mm.work = "";          /* clear */
script: 
  while (mm.peep != null) { 
    
    /* lex block */
    while (true) { 
      mm.readChar();           /* read */
      // make the character count relative to the line number.
      if (mm.work.match(/^[\n]+$/)) {
        mm.charsRead = 0; /* nochars */
      }
      mm.tape[mm.cell] = mm.work;  /* put */
      mm.work = "";          /* clear */
      mm.work += "char*"
      mm.push();
      //-----------
      // here lexing ends and parsing begins
      break; 
    }
    if (restart) { restart = false; continue; }
    /* parse block */ 
    while (true) {
      // To view parse-stack token reduction uncomment the lines below
      // lines; add ":"; chars; add " "; print; clear; 
      // unstack; add "\n"; print; clip; stack; 
      //------------
      // 2 tokens
      mm.pop();
      mm.pop();
      if (mm.work == "pal*pal*") {
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.increment();     /* ++ */ 
        
        if (mm.work == mm.tape[mm.cell]) {
          mm.work += mm.tape[mm.cell]; /* get */
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
          mm.work += "[palindrome found!] ends at line "
          mm.work += mm.linesRead; /* lines */
          mm.work += ", char "
          mm.work += mm.charsRead; /* chars */
          mm.work += ": "
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "\n"
          process.stdout.write(mm.work);   /* print */
          mm.work = "";          /* clear */
          mm.work += "pal*"
          mm.push();
          continue
        }
        mm.work = "";          /* clear */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "pal*pal*"
      }
      if (mm.work == "char*char*") {
        // create the list* token
        mm.work = "";          /* clear */
        mm.work += mm.tape[mm.cell]; /* get */
        mm.increment();     /* ++ */ 
        
        if (mm.work == mm.tape[mm.cell]) {
          // save a copy of the single char on the tape
          // where it wont get overwritten
          mm.increment();     /* ++ */ 
          
          mm.tape[mm.cell] = mm.work;  /* put */
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          mm.work += mm.tape[mm.cell]; /* get */
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
          mm.work += "list*"
          mm.push();
          continue
        }
        mm.work = "";          /* clear */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += "char*char*"
      }
      if (mm.work == "list*char*") {
        // the next tape cell has a copy of the single char
        // of the list
        mm.work = "";          /* clear */
        mm.increment();     /* ++ */ 
        
        mm.work += mm.tape[mm.cell]; /* get */
        mm.increment();     /* ++ */ 
        
        if (mm.work == mm.tape[mm.cell]) {
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          mm.work += mm.tape[mm.cell]; /* get */
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
          mm.work += "list*"
          mm.push();
          continue
        }
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work = "";          /* clear */
        mm.work += "list*char*"
      }
      //------------
      // 3 tokens
      mm.pop();
      if (mm.work == "list*list*list*" || mm.work == "char*list*char*" || mm.work == "list*char*list*" || mm.work == "list*pal*list*" || mm.work == "pal*list*pal*" || mm.work == "char*char*char*" || mm.work == "char*pal*char*" || mm.work == "pal*pal*pal*" || mm.work == "pal*char*pal*") {
        mm.push();
        mm.push();
        mm.push();
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        mm.work += mm.tape[mm.cell]; /* get */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        if (mm.cell > 0) { mm.cell--; }  /* -- */
        if (mm.work == mm.tape[mm.cell]) {
          mm.work = "";          /* clear */
          mm.work += mm.tape[mm.cell]; /* get */
          mm.increment();     /* ++ */ 
          
          mm.work += mm.tape[mm.cell]; /* get */
          mm.increment();     /* ++ */ 
          
          mm.work += mm.tape[mm.cell]; /* get */
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          if (mm.cell > 0) { mm.cell--; }  /* -- */
          mm.tape[mm.cell] = mm.work;  /* put */
          mm.work = "";          /* clear */
          mm.work += "[palindrome found!] ends at line "
          mm.work += mm.linesRead; /* lines */
          mm.work += ", char "
          mm.work += mm.charsRead; /* chars */
          mm.work += ": "
          mm.work += mm.tape[mm.cell]; /* get */
          mm.work += "\n"
          process.stdout.write(mm.work);   /* print */
          mm.work = "";          /* clear */
          mm.increment();     /* ++ */ 
          
          mm.increment();     /* ++ */ 
          
          mm.increment();     /* ++ */ 
          
          mm.pop();
          mm.pop();
          mm.pop();
          mm.work = "";          /* clear */
          mm.work += "pal*"
          mm.push();
          continue
        }
        mm.work = "";          /* clear */
        mm.increment();     /* ++ */ 
        
        mm.increment();     /* ++ */ 
        
        mm.increment();     /* ++ */ 
        
        mm.pop();
        mm.pop();
        mm.pop();
      }
      mm.push();
      mm.push();
      mm.push();
      if (mm.eof) {
        mm.pop();
        mm.pop();
        if (mm.work == "pal*") {
          mm.work = "";          /* clear */
          mm.work += "[whole string is a complete palindrome!]\n"
          process.stdout.write(mm.work);   /* print */
          break script;
        }
        if (mm.work == "list*") {
          mm.work = "";          /* clear */
          mm.work += "[a list]\n"
          process.stdout.write(mm.work);   /* print */
          break script;
        }
        mm.push();
        mm.push();
        mm.work += "Whole string isn't a palindrome.\n"
        process.stdout.write(mm.work);   /* print */
        mm.work = "";          /* clear */
        // add "The parse-stack tokens are:\n  "; print; clear;
        // unstack; 
        // replace "pal*" "palindrome|";
        // replace "*" "|"; clip; add "\n"; print; clear;
      }
      break; 
    } /* parse */
    
  }


/* end of translated javascript code */
