#!/usr/bin/env python3

# code generated by "translate.py.pss" a pep script
# bumble.sf.net/books/pars/
import sys, re    # for sys.read(), write() and regex
from unicodedata import category # for matching classes
# may use, which could make the char class code easier
# import regex
# regex.findall(r'[[:graph:]]', 'a 0 a b z') 

class Machine: 
  # make a new machine 
  def __init__(self):
    self.size = 300      # how many elements in stack/tape/marks
    self.eof = False     # end of stream reached?
    self.charsRead = 0   # how many chars already read
    self.linesRead = 1   # how many lines already read
    self.escape = "\\"
    self.delimiter = "*" # push/pop delimiter (default "*")
    self.counter = 0     # a counter for anything
    self.work = ""       # the workspace
    self.stack = []      # stack for parse tokens 
    self.cell = 0                # current tape cell
    self.tape = [""]*self.size   # a list of attribute for tokens 
    self.marks = [""]*self.size  # marked tape cells
    # or dont initialse peep until "parse()" calls "setInput()"
    self.peep = sys.stdin.read(1)

  def setInput(self, newInput): 
    print("to be implemented")

  # read one character from the input stream and 
  #    update the machine.
  def read(self): 
    if self.eof: System.exit(0)
    self.charsRead += 1;
    # increment lines
    if self.peep == "\n": self.linesRead += 1
    self.work += self.peep
    self.peep = sys.stdin.read(1) 
    if not self.peep: self.eof = True

  # increment the tape pointer (command ++) and increase the 
  # tape and marks array sizes if necessary
  def increment(self): 
    self.cell += 1
    if self.cell >= self.size: 
      self.tape.append("")
      self.marks.append("")
      self.size += 1

  # test if all chars in the text are in the unicode category
  # no! bug! because while checks mm.peep, but class test
  # checks mm.work. so have to adapt this function for either.
  def isInCategory(self, cat, text): 
    for ch in text:
      if not category(ch).startswith(cat): return False
    return True

  # def  
  # remove escape character: trivial method ?
  def unescapeChar(self, c):
    if len(self.work) > 0:
      self.work = self.work.replace("\\"+c, c)

  # add escape character : trivial
  def escapeChar(self, c):
    if len(self.work) > 0:
      self.work = self.work.replace(c, "\\"+c)

  # a helper function for the multiple escape char bug
  def countEscaped(self, suffix): 
    count = 0
    if self.work.endswith(suffix):
      # removesuffix not available in early python
      s = self.work.removesuffix(suffix)
    while s.endswith(self.escape):
      count += 1
      s = s.removesuffix(self.escape)
    return count

  # reads the input stream until the workspace end with text 
  def until(self, suffix): 
    # read at least one character
    if self.eof: return
    self.read()
    while True: 
      if self.eof: return
      # no. bug! count the trailing escape chars, odd=continue, even=stop
      if self.work.endswith(suffix):
        #and (not self.work.endswith(self.escape + suffix)): 
        if self.countEscaped(suffix) % 2 == 0: return
      self.read()
    
  # pop the first token from the stack into the workspace */
  def pop(self): 
    if len(self.stack) == 0: return False
    self.work = mm.stack.pop() + self.work
    if self.cell > 0: self.cell -= 1
    return True

  # push the first token from the workspace to the stack 
  def push(self): 
    # dont increment the tape pointer on an empty push
    if len(self.work) == 0: return False
    # need to get this from the delimiter.
    iFirst = self.work.find(self.delimiter);
    if iFirst == -1:
      self.stack.append(self.work)
      self.work = "" 
      return True
    self.stack.append(self.work[0:iFirst+1])
    self.work = self.work[iFirst+1:]
    self.increment()
    return True

  # this function is not used (the code is "inlined") 
  def swap(self): 
    s = self.work
    self.work = self.tape[self.cell]
    self.tape[self.cell] = s

  def goToMark(self, mark):
    markFound = False  
    length = len(self.marks)
    for ii in range(length): 
      if (mm.marks[ii] == mark):
        mm.cell = ii; markFound = True
    if (markFound == False):
      print("badmark '" + mark + "'!") 
      exit()

  def writeToFile(self): 
    f = open("sav.pp", "w")
    f.write(self.work) 
    f.close() 

  def printState(self): 
    print("Stack[" + ",".join(self.stack) + 
      "] Work[" + self.work + "] Peep[" + self.peep + "]");
    print("Acc:" + str(self.counter) + " Esc:" + self.escape +
          " Delim:" + self.delimiter + " Chars:" + str(self.charsRead) +
          " Lines:" + str(self.linesRead) + " Cell:" + str(self.cell));

  # this is where the actual parsing/compiling code should go
  # so that it can be used by other python classes/objects. Also
  # should have a stream argument.
  def parse(self, s): 
    # a reset or "setinput()" method would be useful to parse a 
    # different string/file/stream, without creating a new
    # machine object.
    # could use code like this to check if input is string or file
    if isinstance(s, file):
      print("")
      # self.reset(s)
      # self.reader = s
    elif isinstance(s, string):
      f = StringIO.StringIO("test")
      for line in f: print(line)
    else:
      f = sys.stdin
    sys.stdout.write("not implemented")


# end of Machine class definition

# will become:
# mm.parse(sys.stdin)  or 
# mm.parse("abcdef") or
# open f; mm.parse(f)

temp = ""    
mm = Machine() 
while (not mm.eof): 
  
  # lex block 
  while True: 
    mm.read()           # read
    # make char number relative to line, for error messages
    if (re.match(r"^[\n]+$", mm.work)):
      mm.charsRead = 0 # nochars 
    # newlines can separate commands in (gnu) sed so we will
    # just add a dummy ';' here. Also, no trailing ; is required
    if (re.match(r"^[\n]+$", mm.work)):
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += ";*"
      mm.push();
      break
    # ignore extraneous white-space?
    if (re.match(r"^[\s]+$", mm.work)):
      mm.work = ''              # clear
      if (mm.eof):
        break
      continue
    # comments, convert to java comments
    if (mm.work == "#"):
      mm.work = ''              # clear
      mm.work += "/* "
      mm.until("\n");
      if (mm.work.endswith("\n")):
        # if len(mm.work) > 0:  # clip 
        mm.work = mm.work[:-1]  # clip
      mm.work += " */\n"
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # uncomment line below to include comments in output
      # add "comment*"; push; .reparse
    # literal tokens '{' and '}' are used to group commands in
    # sed, ';' is used to separate commands and ',' to separate line
    # ranges. ! is the postfix negation operator for ranges
    if (mm.work == "," or mm.work == "{" or mm.work == "}" or mm.work == ";" or mm.work == "!"):
      mm.tape[mm.cell] = mm.work  # put 
      mm.work += "*"
      mm.push();
      break
    # various actions: print, delete, swap
    if (mm.work == "=" or mm.work == "p" or mm.work == "P" or mm.work == "l" or mm.work == "d" or mm.work == "D" or mm.work == "F" or mm.work == "g" or mm.work == "G" or mm.work == "h" or mm.work == "H" or mm.work == "n" or mm.work == "N" or mm.work == "x" or mm.work == "z"):
      if (mm.work == "="):
        mm.work = ''              # clear
        # print line-number + newline
        mm.work += "System.out.println(mm.linesRead);  /* '=' */"
      if (mm.work == "d"):
        mm.work = ''              # clear
        # 'd' delete pattern-space, restart 
        # the if true trick is necessary to avoid 'unreachable statement'
        # java compile errors (when multiple 'd' commands are given)
        mm.work += "if (true) { mm.patternSpace.setLength(0); continue; } /* 'd' */"
      if (mm.work == "D"):
        mm.work = ''              # clear
        # add "/* 'D' delete pattern-space to 1st \\n, restart */";
        mm.work += "if (mm.patternSpace.indexOf(\"\\n\") > -1) {\n"
        mm.work += "  mm.patternSpace.delete(0, mm.patternSpace.indexOf(\"\\n\"));\n"
        mm.work += "  mm.readNext = false; if (true) continue; \n"
        mm.work += "} else { mm.patternSpace.setLength(0); continue; } /* 'd' */"
      if (mm.work == "F"):
        # F: print input filename + newline
        # maybe unsupported in java
        mm.work = ''              # clear
        mm.work += "System.out.println(\"<unknown-file>\");  /* F */"
      if (mm.work == "g"):
        # g: replace patt-space with hold-space
        mm.work = ''              # clear
        mm.work += "mm.patternSpace.setLength(0); \n"
        mm.work += "mm.patternSpace.append(mm.holdSpace);  /* 'g' */"
      if (mm.work == "G"):
        # G; append hold-space to patt-space + \\n"
        mm.work = ''              # clear
        mm.work += "mm.patternSpace.append(\"\\n\" + mm.holdSpace);  /* 'G' */"
      if (mm.work == "h"):
        # h:  replace hold-space with patt-space
        mm.work = ''              # clear
        mm.work += "mm.holdSpace.setLength(0); \n"
        mm.work += "mm.holdSpace.append(mm.patternSpace);  /* 'h' */"
      if (mm.work == "H"):
        # H:  append patt-space to hold-space + newline
        mm.work = ''              # clear
        mm.work += "mm.holdSpace.append(\"\\n\" + mm.patternSpace);  /* 'H' */"
      if (mm.work == "l"):
        # print pattern-space unambiguously, synonym for p ?
        mm.work = ''              # clear
        mm.work += "System.out.println(mm.patternSpace); /* 'l' */"
      if (mm.work == "n"):
        # n: print patt-space, get next line into patt-space
        mm.work = ''              # clear
        mm.work += "if (mm.autoPrint) { System.out.println(mm.patternSpace); }\n"
        mm.work += "mm.patternSpace.setLength(0);\n"
        mm.work += "mm.readLine();   /* 'n' */"
      if (mm.work == "N"):
        # N: append next line to patt-space + newline
        mm.work = ''              # clear
        mm.work += "mm.patternSpace.append('\\n'); "
        mm.work += "mm.readLine();  /* 'N' */"
      if (mm.work == "p"):
        mm.work = ''              # clear
        mm.work += "System.out.println(mm.patternSpace); /* 'p' */"
      if (mm.work == "P"):
        # P: print pattern-space up to 1st newline"
        mm.work = ''              # clear
        mm.work += "if (mm.patternSpace.indexOf(\"\\n\") > -1) {\n"
        mm.work += "  System.out.println(\n"
        mm.work += "    mm.patternSpace.substring(0, mm.patternSpace.indexOf(\"\\n\")));\n"
        mm.work += "} else { System.out.println(mm.patternSpace); }"
      if (mm.work == "x"):
        # x:  # swap pattern-space with hold-space
        mm.work = ''              # clear
        mm.work += "mm.swap();  /* x */"
      if (mm.work == "z"):
        # z:  delete pattern-space, NO restart
        mm.work = ''              # clear
        mm.work += "mm.patternSpace.setLenth(0); /* z */"
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "action*"
      mm.push();
      break
    # line numbers are also selectors
    if (re.match(r"^[0-9]+$", mm.work)):
      # while  
      while re.match(r"^[0-9]+$", mm.peep):
        if mm.eof:  break
        mm.read()
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "number*"
      mm.push();
      break
    # $ is the last line of the file
    if (mm.work == "$"):
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "number*"
      mm.push();
      break
    # patterns - only execute commands if lines match 
    if (mm.work == "/"):
      # save line/char number for error message 
      mm.work = ''              # clear
      mm.work += "near line/char "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ":"
      mm.work += str(mm.charsRead) # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.until("/");
      if (not mm.work.endswith("/")):
        mm.work = ''              # clear
        mm.work += "Missing '/' to terminate "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "?\n"
        sys.stdout.write(mm.work) # print
        exit()
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      # java .matches method matches whole string not substring
      # so we need to add .* at beginning and end, but not if regex
      # begins with ^ or ends with $. complicated hey
      if (not mm.work.endswith("$")):
        mm.work += ".*$"
      if (not mm.work.startswith("^")):
        mm.tape[mm.cell] = mm.work  # put 
        mm.work = ''              # clear
        mm.work += "^.*"
        mm.work += mm.tape[mm.cell] # get
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # add any delimiter for pattern here, or none
      mm.work += "\""
      mm.work += mm.tape[mm.cell] # get
      mm.work += "\""
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "pattern*"
      mm.push();
      break
    # read transliteration commands
    if (mm.work == "y"):
      # save line/char number for error message 
      mm.work = ''              # clear
      mm.work += "near line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # allow spaces between 'y' and '/' although gnu set doesn't
      mm.until("/");
      if (not mm.work.endswith("/") or not re.match(r"^[ /]+$", mm.work)):
        mm.work = ''              # clear
        mm.work += "Missing '/' after 'y' transliterate command\n"
        mm.work += "Or trailing characters "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      # save line/char number for error message 
      mm.work = ''              # clear
      mm.work += "near line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.until("/");
      if (not mm.work.endswith("/")):
        mm.work = ''              # clear
        mm.work += "Missing 2nd '/' after 'y' transliterate command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      if (mm.work == "/"):
        mm.work = ''              # clear
        mm.work += "Sed syntax error? \n"
        mm.work += "  Empty regex after 'y' transliterate command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      # replace pattern found
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "y/"
      mm.work += mm.tape[mm.cell] # get
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # save line/char number for error message 
      mm.work += "near line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.increment()      # ++ 
      mm.tape[mm.cell] = mm.work  # put 
      if mm.cell > 0: mm.cell -= 1  # --
      mm.work = ''              # clear
      mm.until("/");
      if (not mm.work.endswith("/")):
        mm.work = ''              # clear
        mm.work += "Missing 3rd '/' after 'y' transliterate command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += "/"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "/"
      # y/// does not have modifiers (unlike s///)
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "action*"
      mm.push();
      break
    # various commands that have an option word parameter 
    # e has two variants
    #  "e" { replace "e" "e;  # exec patt-space command and replace"; }
    if (mm.work == "b" or mm.work == "e" or mm.work == "q" or mm.work == "Q" or mm.work == "t" or mm.work == "T"):
      # ignore intervening space if any
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # while  
      while re.match(r"^[ ]+$", mm.peep):
        if mm.eof:  break
        mm.read()
      mm.work = ''              # clear
      # A bit more permissive that gnu-sed which doesn't allow
      # read to end in ';'.
      # whilenot  
      while not re.match(r"^[ ;}]+$", mm.peep):
        if mm.eof:  break
        mm.read()
      # word parameters are optional to these commands
      # just add a space to separate command from parameter
      if (mm.work != ""):
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
        mm.work += " "
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += mm.tape[mm.cell] # get
      # hard to implement because java has no goto ?
      if (mm.work.startswith("b")):
        mm.work += ";  # branch to <label> or start"
      if (mm.work.startswith("e ")):
        mm.work += ";  # exec <cmd> and insert into output"
      if (mm.work == "e"):
        mm.work += ";  # exec patt-space command into patt-space"
      if (mm.work == "q"):
        # q; print + quit
        mm.work = ''              # clear
        mm.work += "System.out.println(mm.patternSpace);\n"
        mm.work += "System.exit(0);"
      if (mm.work.startswith("q ")):
        # q; print + quit with exit code
        # if len(mm.work) > 0:  # clop 
        mm.work = mm.work[1:];  # clop
        # if len(mm.work) > 0:  # clop 
        mm.work = mm.work[1:];  # clop
        mm.tape[mm.cell] = mm.work  # put 
        mm.work = ''              # clear
        mm.work += "System.out.println(mm.patternSpace);\n"
        mm.work += "System.exit("
        mm.work += mm.tape[mm.cell] # get
        mm.work += ");"
      if (mm.work == "Q"):
        # Q; quit, dont print
        mm.work = ''              # clear
        mm.work += "System.exit(0);"
      if (mm.work.startswith("Q ")):
        # Q; quit with exit code, dont print
        # if len(mm.work) > 0:  # clop 
        mm.work = mm.work[1:];  # clop
        # if len(mm.work) > 0:  # clop 
        mm.work = mm.work[1:];  # clop
        mm.tape[mm.cell] = mm.work  # put 
        mm.work = ''              # clear
        mm.work += "System.exit("
        mm.work += mm.tape[mm.cell] # get
        mm.work += ");"
      if (mm.work.startswith("t")):
        mm.work += ";  # branch to <label> if substitution made or start"
      if (mm.work.startswith("T")):
        mm.work += ";  # branch to <label> if NO substituion or start"
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "action*"
      mm.push();
      break
    # read 'read <filename>' and write commands
    if (mm.work == ":" or mm.work == "r" or mm.work == "R" or mm.work == "w" or mm.work == "W"):
      # ignore intervening space if any
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # while  
      while re.match(r"^[ ]+$", mm.peep):
        if mm.eof:  break
        mm.read()
      mm.work = ''              # clear
      # A bit more permissive that gnu-sed which doesn't allow
      # read to end in ';'.
      # whilenot  
      while not re.match(r"^[ ;}]+$", mm.peep):
        if mm.eof:  break
        mm.read()
      if (mm.work == ""):
        mm.work = ''              # clear
        mm.work += "Sed syntax error? (at line:char "
        mm.work += str(mm.linesRead) # lines 
        mm.work += ":"
        mm.work += str(mm.charsRead) # chars 
        mm.work += ")\n"
        mm.work += "  no filename for read 'r' command. \n"
        sys.stdout.write(mm.work) # print
        exit()
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += " "
      mm.work += mm.tape[mm.cell] # get
      if (mm.work.startswith(": ")):
        mm.work += ";  # branch to <label>"
      if (mm.work.startswith("r ")):
        mm.work += ";  # read file into patt-space"
      if (mm.work.startswith("R ")):
        mm.work += ";  # insert file into output before next line"
      if (mm.work.startswith("w ")):
        mm.work += ";  # write patt-space to file"
      # mm.writeToFile(name)
      if (mm.work.startswith("W ")):
        mm.work += ";  # write 1st line of patt-space to file"
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "action*"
      mm.push();
      break
    # read substitution commands
    if (mm.work == "s"):
      # save line/char number for error message 
      mm.work = ''              # clear
      mm.work += "near line/char "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ":"
      mm.work += str(mm.charsRead) # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # allow spaces between 's' and '/' ??? 
      mm.until("/");
      if (not mm.work.endswith("/") or not re.match(r"^[ /]+$", mm.work)):
        mm.work = ''              # clear
        mm.work += "Missing '/' after 's' substitute command\n"
        mm.work += "Or trailing characters "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      # save line/char number for error message 
      mm.work = ''              # clear
      mm.work += "near line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.until("/");
      if (not mm.work.endswith("/")):
        mm.work = ''              # clear
        mm.work += "Sed syntax error? \n"
        mm.work += "  Missing 2nd '/' after 's' substitute command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      if (mm.work == "/"):
        mm.work = ''              # clear
        mm.work += "Sed syntax error? \n"
        mm.work += "  Empty regex after 's' substitute command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      # replace pattern found
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "mm.substitute(\""
      mm.work += mm.tape[mm.cell] # get
      mm.work += "\", \""
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      # save line/char number for error message 
      mm.work += "near line/char "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ":"
      mm.work += str(mm.charsRead) # chars 
      mm.increment()      # ++ 
      mm.tape[mm.cell] = mm.work  # put 
      if mm.cell > 0: mm.cell -= 1  # --
      mm.work = ''              # clear
      mm.until("/");
      if (not mm.work.endswith("/")):
        mm.work = ''              # clear
        mm.work += "Missing 3rd '/' after 's' substitute command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += mm.tape[mm.cell] # get
      mm.work += "\", \""
      # also need to read modifiers, eg g/i/p/[0-9] etc
      # need better logic to process these modifiers.
      # while  
      while re.match(r"^[gip]+$", mm.peep):
        if mm.eof:  break
        mm.read()
      mm.work += "\");   /* s */ "
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "action*"
      mm.push();
      break
    if (mm.work == "a" or mm.work == "c" or mm.work == "i"):
      # label, append, branch, change, insert, quit, write, test, write, read
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "Unimplemented command (near line:char "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ":"
      mm.work += str(mm.charsRead) # chars 
      mm.work += ")\n"
      mm.work += "  The script does not recognise '"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "' yet.\n"
      sys.stdout.write(mm.work) # print
      exit()
    if (mm.work != ""):
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "Sed syntax error? (near line:char "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ":"
      mm.work += str(mm.charsRead) # chars 
      mm.work += ")\n"
      mm.work += "  unrecognised command '"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "'\n"
      sys.stdout.write(mm.work) # print
      exit()
    # where token reduction begins
    break 
  
  # parse block 
  while True:  
    # To visualise token reduction uncomment this below:
    mm.work += "// "
    mm.work += str(mm.linesRead) # lines 
    mm.work += ":"
    mm.work += str(mm.charsRead) # chars 
    mm.work += " "
    sys.stdout.write(mm.work) # print
    mm.work = ''              # clear
    mm.work += "\n"
    while (mm.pop()):  continue    # unstack 
    sys.stdout.write(mm.work) # print
    # if len(mm.work) > 0:  # clip 
    mm.work = mm.work[:-1]  # clip
    while (mm.push()):  continue   # stack 
    # commands do not have to be terminated with ';' at the end of a sed script.
    if (mm.eof):
      mm.pop();
      if (mm.work == "action*"):
        mm.work += ";*"
        mm.push();
        mm.push();
        continue
      mm.push();
    mm.pop();
    mm.pop();
    mm.pop();
    mm.pop();
    mm.pop();
    mm.pop();
    # ----------------
    # 6 token reductions
    # these must be done first, to take precedence over 
    # eg pattern/{/commandset/}
    if (mm.work == "pattern*,*pattern*{*commandset*}*" or mm.work == "pattern*,*number*{*commandset*}*" or mm.work == "number*,*number*{*commandset*}*" or mm.work == "number*,*pattern*{*commandset*}*"):
      # also, need to indent the command set.
      mm.increment()      # ++ 
      mm.increment()      # ++ 
      mm.increment()      # ++ 
      mm.increment()      # ++ 
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      # replace 
      if len(mm.work) != 0:  
        mm.work = mm.work.replace("\n", "\n  ")
      
      # use a brace token as temporary storage, so that we can
      # indent the 1st line of the commandset
      # should add 2 spaces but 1st line is getting an extra one.
      if mm.cell > 0: mm.cell -= 1  # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += " "
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++ 
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      if mm.cell > 0: mm.cell -= 1  # --
      if mm.cell > 0: mm.cell -= 1  # --
      if mm.cell > 0: mm.cell -= 1  # --
      if mm.cell > 0: mm.cell -= 1  # --
      # using an array of boolean states to remember if a 
      # pattern has been 'seen'
      if (mm.work.startswith("pattern*,*pattern*")):
        mm.work = ''              # clear
        mm.work += "if (mm.line.toString().matches("
        mm.work += mm.tape[mm.cell] # get
        mm.work += ") && (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == false))\n  {"
        mm.work += " mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] = true; }\n"
        mm.work += "if (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == true) {\n"
        # get commandset at tape+4
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += "\n}\n"
        # comes after so last line is matched 
        mm.work += "if (mm.line.toString().matches("
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += ") && (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == true))\n  {"
        mm.work += " mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] = false; }\n"
        mm.tape[mm.cell] = mm.work  # put 
        mm.counter += 1  # a+ 
      if (mm.work.startswith("pattern*,*number*")):
        mm.work = ''              # clear
        mm.work += "if (mm.line.toString()..matches("
        mm.work += mm.tape[mm.cell] # get
        mm.work += ") && (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == false))\n"
        mm.work += "  { mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] = true; }\n"
        mm.work += "if (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == true) {\n "
        # get commandset at tape+4
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += "\n}\n"
        # put here to match last line in range 
        mm.work += "if ((mm.linesRead > "
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += ") && (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == true))\n"
        mm.work += "  { mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] = false; }\n"
        mm.tape[mm.cell] = mm.work  # put 
        mm.counter += 1  # a+ 
      if (mm.work.startswith("number*,*pattern*")):
        mm.work = ''              # clear
        # but this logic doesn't include last line
        mm.work += "if ((mm.linesRead == "
        mm.work += mm.tape[mm.cell] # get
        mm.work += ") && (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == false))\n"
        mm.work += "  { mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] = true; }\n"
        mm.work += "if (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == true) {\n "
        # get commandset at tape+4
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += "\n}\n"
        # after to match last line in range
        mm.work += "if (mm.line.toString().matches("
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += ") && (mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] == true))\n"
        mm.work += "  { mm.states["
        mm.work += str(mm.counter) # count 
        mm.work += "] = false; }\n"
        mm.tape[mm.cell] = mm.work  # put 
        mm.counter += 1  # a+ 
      if (mm.work.startswith("number*,*number*")):
        mm.work = ''              # clear
        mm.work += "if ((mm.linesRead >= "
        mm.work += mm.tape[mm.cell] # get
        mm.work += ") && (mm.linesRead <= "
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += ")) {\n"
        # get commandset at tape+4
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += "\n}"
        mm.tape[mm.cell] = mm.work  # put 
        mm.counter += 1  # a+ 
      mm.work = ''              # clear
      mm.work += "command*"
      mm.push();
      continue
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    mm.pop();
    mm.pop();
    mm.pop();
    #---------------
    # 3 tokens: 
    #   we have to do this first before the action*;* rule 
    #   is reduced.
    # change to the equivalent eg: range*{*command*}*
    # This avoids have to rewrite all the java code construction
    if (mm.work == "range*action*;*" or mm.work == "number*action*;*" or mm.work == "pattern*action*;*"):
      # preserve range/number/pattern parse token
      mm.push();
      mm.work = ''              # clear
      # transfer action/command code to the correct tapecell
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++ 
      mm.tape[mm.cell] = mm.work  # put 
      if mm.cell > 0: mm.cell -= 1  # --
      mm.work = ''              # clear
      mm.work += "{*commandset*}*"
      mm.push();
      mm.push();
      mm.push();
      continue
      # now we have on the stack, for example
      # range*{*commandset*}* which is already handled, and the 
      # code attributes should be in the right tape cells.
      # we could do: add "{*command*}*" but it doesnt matter....
    # gnu sed allows empty braces, so we will too.
    # Another trick: push an empty commandset onto the stack
    # after a brace - that gets rid of this rule and also
    # the : command/command/ -> commandset/ rule
    if (mm.work == "range*{*}*" or mm.work == "number*{*}*" or mm.work == "pattern*{*}*"):
      mm.work = ''              # clear
      mm.work += mm.tape[mm.cell] # get
      mm.work += " {}  # warning: empty braces- does nothing!"
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "command*"
      mm.push();
      continue
    mm.push();
    mm.push();
    mm.push();
    mm.pop();
    mm.pop();
    #---------------
    # 2 token errors
    if (mm.work == "pattern*number*" or mm.work == "pattern*pattern*" or mm.work == "number*number*" or mm.work == "number*pattern*" or mm.work == "range*number*" or mm.work == "range*pattern*" or mm.work == "pattern*;*" or mm.work == "number*;*" or mm.work == "range*;*"):
      mm.work = ''              # clear
      mm.work += "Sed syntax error? (near line:char "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ":"
      mm.work += str(mm.charsRead) # chars 
      mm.work += ")\n"
      mm.work += "  line selector/number/range with no action \n"
      mm.work += "  (missing ',' or misplaced ';' ?) \n"
      sys.stdout.write(mm.work) # print
      exit()
    if (mm.work == "action*action*" or mm.work == "action*command*" or mm.work == "action*number*" or mm.work == "action*pattern*" or mm.work == "action*range*" or mm.work == "action*{*"):
      mm.work = ''              # clear
      mm.work += "Sed error (line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", chars "
      mm.work += str(mm.charsRead) # chars 
      mm.work += "):\n"
      mm.work += "  Missing ';' after command?\n"
      sys.stdout.write(mm.work) # print
      exit()
    if (mm.work == ",*}*" or mm.work == ",*{*" or mm.work == ",*;*" or mm.work == ",*,*" or mm.work == ";*,*" or mm.work == ";*{*" or mm.work == "range*,*"):
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      # if len(mm.work) > 0:  # clop 
      mm.work = mm.work[1:];  # clop
      # if len(mm.work) > 0:  # clop 
      mm.work = mm.work[1:];  # clop
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "Sed error (line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", chars "
      mm.work += str(mm.charsRead) # chars 
      mm.work += "):\n"
      mm.work += "  Unexpected character '"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "' \n"
      sys.stdout.write(mm.work) # print
      exit()
    #---------------
    # 2 token reductions
    # ignore empty commands (and multiple \n)
    if (mm.work == "command*;*" or mm.work == "commandset*;*" or mm.work == ";*;*"):
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      mm.push();
      continue
    if (mm.work == "action*;*"):
      mm.work = ''              # clear
      mm.work += "command*"
      mm.push();
      continue
    # maybe need a new token type for clarity here 
    # eg: negated selector
    if (mm.work == "number*!*"):
      mm.work = ''              # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++ 
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0: mm.cell -= 1  # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "number*"
      mm.push();
      continue
    if (mm.work == "pattern*!*"):
      mm.work = ''              # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++ 
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0: mm.cell -= 1  # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "pattern*"
      mm.push();
      continue
    if (mm.work == "command*command*" or mm.work == "commandset*command*"):
      mm.work = ''              # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++ 
      mm.work += "\n"
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0: mm.cell -= 1  # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "commandset*"
      mm.push();
      continue
    mm.pop();
    #---------------
    # 3 token errors
    # eg: '/a/,/bb/p;' or '/[0-3]/,20p;' etc
    #---------------
    # 3 token reductions
    # commands dont need a ';' before a closing brace in gnu sed
    # so transmogrify
    if (mm.work == "command*command*}*" or mm.work == "command*action*}*" or mm.work == "commandset*action*}*" or mm.work == "commandset*command*}*"):
      mm.work = ''              # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++ 
      mm.work += "\n"
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0: mm.cell -= 1  # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "commandset*}*"
      mm.push();
      mm.push();
      continue
    if (mm.work == "range*action*}*" or mm.work == "number*action*}*" or mm.work == "pattern*action*}*"):
      mm.work = ''              # clear
      mm.work += mm.tape[mm.cell] # get
      mm.work += "{\n  "
      mm.increment()      # ++ 
      mm.work += mm.tape[mm.cell] # get
      mm.work += "\n}"
      if mm.cell > 0: mm.cell -= 1  # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "command*}*"
      mm.push();
      mm.push();
      continue
    if (mm.work == "{*action*}*"):
      # make commandset not command for grammar simplicity
      mm.work = ''              # clear
      mm.work += "{*commandset*}*"
      mm.push();
      mm.push();
      mm.push();
      continue
    # a single command in braces can be just treated like a 
    # set of commands in braces, so lets change to make other
    # grammar rules simpler
    if (mm.work == "{*command*}*"):
      # make commandset not command for grammar simplicity
      mm.work = ''              # clear
      mm.work += "{*commandset*}*"
      mm.push();
      mm.push();
      mm.push();
      continue
    mm.pop();
    #---------------
    # 4 token errors
    #---------------
    # 4 token reductions
    if (mm.work == "pattern*{*commandset*}*" or mm.work == "number*{*commandset*}*"):
      # indent brace commands in tapecell+2
      mm.increment()      # ++ 
      mm.increment()      # ++ 
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      # replace 
      if len(mm.work) != 0:  
        mm.work = mm.work.replace("\n", "\n  ")
      
      # indent 1st line using { token as temporary storage
      if mm.cell > 0: mm.cell -= 1  # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "  "
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++ 
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      if mm.cell > 0: mm.cell -= 1  # --
      if mm.cell > 0: mm.cell -= 1  # --
      if (mm.work == "pattern*{*commandset*}*"):
        mm.work = ''              # clear
        mm.work += "if (mm.line.toString().matches("
        mm.work += mm.tape[mm.cell] # get
        mm.work += ")) {\n"
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += "\n}"
        mm.tape[mm.cell] = mm.work  # put 
      if (mm.work == "number*{*commandset*}*"):
        mm.work = ''              # clear
        mm.work += "if (mm.linesRead == "
        mm.work += mm.tape[mm.cell] # get
        mm.work += ") {\n"
        mm.increment()      # ++ 
        mm.increment()      # ++ 
        mm.work += mm.tape[mm.cell] # get
        if mm.cell > 0: mm.cell -= 1  # --
        if mm.cell > 0: mm.cell -= 1  # --
        mm.work += "\n}"
        mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "command*"
      mm.push();
      continue
    mm.pop();
    mm.pop();
    # ----------------
    # 6 token reductions
    # none because we have to do them first.
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    if (mm.eof):
      # check for valid sed script
      mm.work += "/* The token parse-stack was: "
      sys.stdout.write(mm.work) # print
      mm.work = ''              # clear
      while (mm.pop()):  continue    # unstack 
      mm.work += " */\n"
      sys.stdout.write(mm.work) # print
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      if (mm.work != "commandset*" and mm.work != "command*"):
        mm.work = ''              # clear
        mm.work += "# [error] Sed syntax error? \n"
        mm.work += "# ----------------- \n"
        mm.work += "# Also, uncomment lines after parse> label in script\n"
        mm.work += "# to see how the sed script is being parsed. \n"
        sys.stdout.write(mm.work) # print
        exit()
      if (mm.work == "commandset*" or mm.work == "command*"):
        mm.work = ''              # clear
        # indent the generated code
        mm.work += "\n"
        mm.work += mm.tape[mm.cell] # get
        # replace 
        if len(mm.work) != 0:  
          mm.work = mm.work.replace("\n", "\n       ")
        
        mm.tape[mm.cell] = mm.work  # put 
        mm.work = ''              # clear
        # create the java preamble, with a 'sedmachine' having a 
        # holdspace and patternspace
        mm.work += ""
        mm.work += "\n"
        mm.work += "\n /* [ok] Sed syntax appears ok */"
        mm.work += "\n /* ---------------------      */"
        mm.work += "\n /* Java code generated by \"sed.tojava.pss\" */"
        mm.work += "\n import java.io.*;"
        mm.work += "\n import java.util.regex.*;"
        mm.work += "\n import java.util.*;   // contains stack"
        mm.work += "\n"
        mm.work += "\n public class javased {"
        mm.work += "\n   public StringBuffer patternSpace;"
        mm.work += "\n   public StringBuffer holdSpace;"
        mm.work += "\n   public StringBuffer line;         /* current line unmodified */"
        mm.work += "\n   public int linesRead;"
        mm.work += "\n   private boolean[] states;         /* pattern-seen state */"
        mm.work += "\n   private Scanner input; "
        mm.work += "\n   private boolean eof;              /* end of file reached? */"
        mm.work += "\n   private boolean hasSubstituted;   /* a sub on this cycle? */"
        mm.work += "\n   private boolean lastLine;         /* last line of input (for $) */"
        mm.work += "\n   private boolean readNext;         /* read next line or not */"
        mm.work += "\n   private boolean autoPrint;        /* autoprint pattern space? */"
        mm.work += "\n"
        mm.work += "\n   /** make a new machine with a character stream reader */"
        mm.work += "\n   public javased(Scanner scanner) {"
        mm.work += "\n     this.patternSpace = new StringBuffer(\"\"); "
        mm.work += "\n     this.holdSpace = new StringBuffer(\"\"); "
        mm.work += "\n     this.line = new StringBuffer(\"\"); "
        mm.work += "\n     this.linesRead = 0;"
        mm.work += "\n     this.input = scanner;"
        mm.work += "\n     this.eof = false;"
        mm.work += "\n     this.hasSubstituted = false;"
        mm.work += "\n     this.readNext = true;"
        mm.work += "\n     this.autoPrint = true;"
        mm.work += "\n     // assume that a sed script has no more than 1K range tests! */"
        mm.work += "\n     this.states = new boolean[1000];"
        mm.work += "\n     for (int ii = 0; ii < 1000; ii++) { this.states[ii] = false; }"
        mm.work += "\n   }"
        mm.work += "\n"
        mm.work += "\n   /** read one line from the input stream and update the machine. */"
        mm.work += "\n   public void readLine() {"
        mm.work += "\n     int iChar;"
        mm.work += "\n     if (this.eof) { System.exit(0); }"
        mm.work += "\n     // increment lines"
        mm.work += "\n     this.linesRead++;"
        mm.work += "\n     if (this.input.hasNext()) {"
        mm.work += "\n       this.line.setLength(0);"
        mm.work += "\n       this.line.append(this.input.nextLine());"
        mm.work += "\n       this.patternSpace.append(this.line);"
        mm.work += "\n     } else { this.eof = true; }"
        mm.work += "\n   }"
        mm.work += "\n"
        mm.work += "\n   /** command \"x\": swap the pattern-space with the hold-space */"
        mm.work += "\n   public void swap() {"
        mm.work += "\n     String s = new String(this.patternSpace);"
        mm.work += "\n     this.patternSpace.setLength(0);"
        mm.work += "\n     this.patternSpace.append(this.holdSpace.toString());"
        mm.work += "\n     this.holdSpace.setLength(0);"
        mm.work += "\n     this.holdSpace.append(s);"
        mm.work += "\n   }"
        mm.work += "\n"
        mm.work += "\n   /** command \"s///x\": make substitutions on the pattern-space */"
        mm.work += "\n   public void substitute(String first, String second, String flags) {"
        mm.work += "\n     // flags can be gip etc"
        mm.work += "\n     // gnu sed modifiers M,<num>,e,w filename may be tricky here."
        mm.work += "\n"
        mm.work += "\n     String temp = new String(\"\");"
        mm.work += "\n     String old = new String(this.patternSpace);"
        mm.work += "\n"
        mm.work += "\n     // case insensitive: add \"(?i)\" at beginning"
        mm.work += "\n     if ((flags.indexOf(\'i\') > -1) ||"
        mm.work += "\n         (flags.indexOf(\'I\') > -1)) { first = \"(?i)\" + first; }"
        mm.work += "\n"
        mm.work += "\n     // multiline matching, check!!"
        mm.work += "\n     if ((flags.indexOf(\'m\') > -1) ||"
        mm.work += "\n         (flags.indexOf(\'M\') > -1)) { first = \"(?m)\" + first; }"
        mm.work += "\n"
        mm.work += "\n     // <num>- replace only nth match"
        mm.work += "\n     // todo"
        mm.work += "\n"
        mm.work += "\n     // g- global, replace all."
        mm.work += "\n     if (flags.indexOf(\'g\') == -1) {"
        mm.work += "\n       temp = this.patternSpace.toString().replaceFirst(first, second);"
        mm.work += "\n     } else {"
        mm.work += "\n       temp = this.patternSpace.toString().replaceAll(first, second);"
        mm.work += "\n     }"
        mm.work += "\n     this.patternSpace.setLength(0);"
        mm.work += "\n     this.patternSpace.append(temp);"
        mm.work += "\n     if  (!old.equals(this.patternSpace.toString())) {"
        mm.work += "\n       this.hasSubstituted = true;"
        mm.work += "\n       // only print if substitution made, patternspace different ?"
        mm.work += "\n       if (flags.indexOf(\'p\') != -1) {"
        mm.work += "\n         System.out.println(this.patternSpace);"
        mm.work += "\n       }"
        mm.work += "\n       // execute pattern space, gnu ext"
        mm.work += "\n       if (flags.indexOf(\'e\') != -1) {"
        mm.work += "\n       }"
        mm.work += "\n       // write pattern space to file, gnu ext"
        mm.work += "\n       // need to scan filename"
        mm.work += "\n       if (flags.indexOf(\'w\') != -1) {"
        mm.work += "\n       }"
        mm.work += "\n     }"
        mm.work += "\n   }"
        mm.work += "\n"
        mm.work += "\n   /** command \"W\": save 1st line of patternspace to filename */"
        mm.work += "\n   public void writeFirstToFile(String fileName) {"
        mm.work += "\n     try {"
        mm.work += "\n       File file = new File(fileName);"
        mm.work += "\n       Writer out = new BufferedWriter(new OutputStreamWriter("
        mm.work += "\n          new FileOutputStream(file), \"UTF8\"));"
        mm.work += "\n       // get first line of ps"
        mm.work += "\n       out.append(this.patternSpace.toString());"
        mm.work += "\n       out.flush(); out.close();"
        mm.work += "\n     } catch (Exception e) {"
        mm.work += "\n       System.out.println(e.getMessage());"
        mm.work += "\n     }"
        mm.work += "\n   }"
        mm.work += "\n"
        mm.work += "\n   /** command \"w\": save the patternspace to filename */"
        mm.work += "\n   public void writeToFile(String fileName) {"
        mm.work += "\n     try {"
        mm.work += "\n       File file = new File(fileName);"
        mm.work += "\n       Writer out = new BufferedWriter(new OutputStreamWriter("
        mm.work += "\n          new FileOutputStream(file), \"UTF8\"));"
        mm.work += "\n       out.append(this.patternSpace.toString());"
        mm.work += "\n       out.flush(); out.close();"
        mm.work += "\n     } catch (Exception e) {"
        mm.work += "\n       System.out.println(e.getMessage());"
        mm.work += "\n     }"
        mm.work += "\n   }"
        mm.work += "\n"
        mm.work += "\n   public static void main(String[] args) throws Exception { "
        mm.work += "\n     String temp = \"\";    "
        mm.work += "\n     javased mm = new javased(new Scanner(System.in)); "
        mm.work += "\n     while (!mm.eof) {"
        mm.work += "\n       mm.hasSubstituted = false;"
        mm.work += "\n       mm.patternSpace.setLength(0);"
        mm.work += "\n       // some sed commands restart without reading a line..."
        mm.work += "\n       // hence the use of a flag."
        mm.work += "\n       if (mm.readNext) { mm.readLine(); }"
        mm.work += "\n       mm.readNext = true;"
        mm.work += "\n"
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n       if (mm.autoPrint) { System.out.println(mm.patternSpace); }"
        mm.work += "\n     }\n   }\n }\n"
        sys.stdout.write(mm.work) # print
      exit()
    break # parse
  

# end of code generated by tr/translate.py.pss 
