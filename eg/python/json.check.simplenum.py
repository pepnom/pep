#!/usr/bin/env python3

# code generated by "translate.py.pss" a pep script
# bumble.sf.net/books/pars/
import sys, re    # for sys.read(), write() and regex
from unicodedata import category # for matching classes

class Machine: 
  # make a new machine 
  def __init__(self):
    self.size = 100      # how many elements in stack/tape/marks
    self.eof = False     # end of stream reached?
    self.charsRead = 0   # how many chars already read
    self.linesRead = 1   # how many lines already read
    self.escape = "\\"
    self.delimiter = "*" # push/pop delimiter (default "*")
    self.counter = 0     # a counter for anything
    self.work = ""       # the workspace
    self.stack = []      # stack for parse tokens 
    self.cell = 0                # current tape cell
    self.tape = [""]*self.size   # a list of attribute for tokens 
    self.marks = [""]*self.size  # marked tape cells
    # or dont initialse peep until "parse()" calls "setInput()"
    self.peep = sys.stdin.read(1)

  def setInput(self, newInput): 
    print("to be implemented")

  # read one character from the input stream and 
  #    update the machine.
  def read(self): 
    if self.eof: System.exit(0)
    self.charsRead += 1;
    # increment lines
    if self.peep == "\n": self.linesRead += 1
    self.work += self.peep
    self.peep = sys.stdin.read(1) 
    if not self.peep: self.eof = True

  # increment tape pointer by one: trivial method in python 
  def increment(self):
    self.cell += 1
  
  # test if all chars in workspace are in unicode category
  def isInCategory(self, cat): 
    for ch in self.work:
      if not category(ch).startswith(cat): return False
    return True

  # def  
  # remove escape character: trivial method ?
  def unescapeChar(self, c):
    if len(self.work) > 0:
      self.work = self.work.replace("\\"+c, c)

  # add escape character : trivial
  def escapeChar(self, c):
    if len(self.work) > 0:
      self.work = self.work.replace(c, "\\"+c)

  # reads the input stream until the workspace end with text 
  def until(self, suffix): 
    # read at least one character
    if self.eof: return
    self.read()
    while True: 
      if self.eof: return
      if self.work.endswith(suffix) and (not self.work.endswith(self.escape + suffix)): return
      self.read()
    
  # pop the first token from the stack into the workspace */
  def pop(self): 
    if len(self.stack) == 0: return False
    self.work = mm.stack.pop() + self.work
    if self.cell > 0: self.cell -= 1
    return True

  # push the first token from the workspace to the stack 
  def push(self): 
    #String sItem;
    # dont increment the tape pointer on an empty push
    if len(self.work) == 0: return False
    # need to get this from the delimiter.
    iFirst = self.work.find(self.delimiter);
    if iFirst == -1:
      self.stack.append(self.work)
      self.work = "" 
      return True
    self.stack.append(self.work[0:iFirst+1])
    self.work = self.work[iFirst+1:]
    if self.cell < self.size: 
      self.cell += 1
    else:
      print("tape max size exceeded while pushing!"); 
      print("tape max size = " + str(self.size)); 
      print("tape cell = " + str(self.cell)); 
      exit()
    return True

  # maybe not required (can be inlined in python)
  def swap(self): 
    s = self.work
    self.work = self.tape[self.cell]
    self.tape[self.cell] = s

  def writeToFile(self): 
    f = open("sav.pp", "w")
    f.write(self.work) 
    f.close() 

  def printState(self): 
    print("Stack[" + ",".join(self.stack) + 
      "] Work[" + self.work + "] Peep[" + self.peep + "]");
    print("Acc:" + str(self.counter) + " Esc:" + self.escape +
          " Delim:" + self.delimiter + " Chars:" + str(self.charsRead) +
          " Lines:" + str(self.linesRead) + " Cell:" + str(self.cell));

  # this is where the actual parsing/compiling code should go
  # so that it can be used by other python classes/objects. Also
  # should have a stream argument.
  def parse(self, s): 
    # a reset or "setinput()" method would be useful to parse a 
    # different string/file/stream, without creating a new
    # machine object.
    # could use code like this to check if input is string or file
    if isinstance(s, file):
      print("")
      # self.reset(s)
      # self.reader = s
    elif isinstance(s, string):
      f = StringIO.StringIO("test")
      for line in f: print(line)
    else:
      f = sys.stdin
    sys.stdout.write("not implemented")


# end of Machine class definition

# will become:
# mm.parse(sys.stdin)  or 
# mm.parse("abcdef") or
# open f; mm.parse(f)

temp = ""    
mm = Machine() 
while (not mm.eof): 
  
  # lex block 
  while True: 
    mm.read()           # read
    # Unlike Crockfords grammar, I will just completely ignore whitespace,
    # but this may not be acceptable in a rigorous application. Also, I
    # am just using the ctype.h definition of whitespace, whatever that 
    # may be.
    if (re.match(r"^[\s]+$", mm.work)):
      mm.work = ''              # clear
      break
    if (re.match(r"^[0-9]+$", mm.work)):
      # while  
      while re.match(r"^[0-9]+$", mm.peep):
        if mm.eof:
          break
        mm.read()
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "integer*"
      mm.push();
      break
    if (re.match(r"^[a-z]+$", mm.work)):
      # while  
      while re.match(r"^[a-z]+$", mm.peep):
        if mm.eof:
          break
        mm.read()
      if (mm.work != "true" and mm.work != "false" and mm.work != "null"):
        # handle error
        mm.tape[mm.cell] = mm.work  # put 
        mm.work = ''              # clear
        mm.work += "Unknown value '"
        mm.work += mm.tape[mm.cell] # get
        mm.work += "' at line "
        mm.work += str(mm.linesRead) # lines 
        mm.work += " (character "
        mm.work += str(mm.charsRead) # chars 
        mm.work += ").\n"
        sys.stdout.write(mm.work) # print
        exit()
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "value*"
      mm.push();
      break
    if (mm.work == "\""):
      # save line number for error message
      mm.work = ''              # clear
      mm.work += str(mm.linesRead) # lines 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.until("\"");
      if (mm.eof):
        mm.work = ''              # clear
        mm.work += "Unterminated \" char, at line "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        sys.stdout.write(mm.work) # print
        exit()
      # if len(mm.work) > 0:  # clip 
      mm.work = mm.work[:-1]  # clip
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "string*"
      mm.push();
      break
    # literal tokens
    if (mm.work == "." or mm.work == "," or mm.work == ":" or mm.work == "-" or mm.work == "+" or mm.work == "[" or mm.work == "]" or mm.work == "{" or mm.work == "}"):
      mm.tape[mm.cell] = mm.work  # put 
      mm.work += "*"
      mm.push();
      break
    # here check if the workspace is empty. If not it is an error.
    if (mm.work != ""):
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''              # clear
      mm.work += "Json syntax error at line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += ": unquoted '"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "' character.\n"
      sys.stdout.write(mm.work) # print
      exit()
    break 
  
  # parse block 
  while True:  
    # just for debugging
    while (mm.pop()):  continue    # unstack 
    mm.work += "\n"
    sys.stdout.write(mm.work) # print
    # if len(mm.work) > 0:  # clip 
    mm.work = mm.work[:-1]  # clip
    while (mm.push()):  continue   # stack 
    # The parse/compile phase
    # --------------
    # 2 tokens
    mm.pop();
    mm.pop();
    #-----------
    # Two token errors (not necessarily a complete list)
    # comma errors 
    if (mm.work == "{*,*" or mm.work == ",*}*" or mm.work == "[*,*" or mm.work == ",*,*" or mm.work == ",*]*"):
      mm.work = ''              # clear
      mm.work += "JSON syntax error at line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += " (extra or misplaced ',' comma)\n"
      sys.stdout.write(mm.work) # print
      exit()
    # sign errors (+/- must be followed by an integer
    if (mm.work != "-*" and mm.work.startswith("-*") and not mm.work.endswith("integer*")):
      mm.work = ''              # clear
      mm.work += "Json syntax error at line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += " (char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += "): misplaced negative '-' sign\n"
      sys.stdout.write(mm.work) # print
      exit()
      mm.work += "In JSON syntax, - may only precede a number \n"
      mm.work += "for example: -33.01 \n"
    # sign errors (+/- must be followed by an integer)
    if (mm.work != "+*" and mm.work.startswith("+*") and not mm.work.endswith("integer*")):
      mm.work = ''              # clear
      mm.work += "Json syntax error at line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += " (char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += "): misplaced positive '+' sign\n"
      mm.work += "In JSON syntax, + may only precede a number \n"
      mm.work += "for example: +33.01 \n"
      sys.stdout.write(mm.work) # print
      exit()
    # dot errors (. must be followed by an integer)
    if (mm.work != ".*" and mm.work.startswith(".*") and not mm.work.endswith("integer*")):
      mm.work = ''              # clear
      mm.work += "Json syntax error at line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += " (char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += "): misplaced dot '.' sign\n"
      mm.work += "In JSON syntax, dots may only be used in decimal numbers \n"
      mm.work += "for example: -33.01 \n"
      sys.stdout.write(mm.work) # print
      exit()
    # dot errors (. must be followed by an integer)
    if (mm.work != ".*" and mm.work.endswith(".*") and not mm.work.startswith("integer*")):
      mm.work = ''              # clear
      mm.work += "JSON syntax error at line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += " (char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += "): misplaced dot '.' sign\n"
      mm.work += "In JSON syntax, dots may only be used in decimal numbers \n"
      mm.work += "for example: -33.01, but .44 is not a legal JSON number \n"
      sys.stdout.write(mm.work) # print
      exit()
    # eg errors "items*:*","members*:*",",*:*","[*:*","{*:*" 
    # A colon must be preceded by a string. Using <and> logic
    if (mm.work.endswith(":*") and mm.work != ":*" and not mm.work.startswith("string*")):
      mm.work = ''              # clear
      mm.work += "Json syntax error near line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += " (misplaced colon ':') \n"
      mm.work += "A ':' can only occur after a string key in an object structure \n"
      mm.work += "Example: {\"cancelled\":true} \n"
      sys.stdout.write(mm.work) # print
      exit()
    # more colon errors 
    if (mm.work != ":*" and mm.work.startswith(":*")):
      if (mm.work.endswith("}*") or mm.work.endswith(",*") or mm.work.endswith("]*")):
        mm.work = ''              # clear
        mm.work += "JSON syntax error near line "
        mm.work += str(mm.linesRead) # lines 
        mm.work += ", char "
        mm.work += str(mm.charsRead) # chars 
        mm.work += " (misplaced colon ':' or missing value?) \n"
        mm.work += "A ':' only occur as part of an object member \n"
        mm.work += "Example: {\"cancelled\":true} \n"
        sys.stdout.write(mm.work) # print
        exit()
    # catch object member errors 
    # also need to check that not only 1 token in on the stack
    # hence the !"member*" construct
    if (mm.work.startswith("member*") or mm.work.startswith("members*")):
      if (mm.work != "member*" and mm.work != "members*" and not mm.work.endswith(",*") and not mm.work.endswith("}*")):
        mm.work = ''              # clear
        mm.work += "JSON syntax error after object member near line "
        mm.work += str(mm.linesRead) # lines 
        mm.work += " (char "
        mm.work += str(mm.charsRead) # chars 
        mm.work += ")\n"
        sys.stdout.write(mm.work) # print
        exit()
    # catch array errors 
    if (mm.work.startswith("items*") and mm.work != "items*" and not mm.work.endswith(",*") and not mm.work.endswith("]*")):
      mm.work = ''              # clear
      mm.work += "Error after an array item near line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += " (char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += ")\n"
      sys.stdout.write(mm.work) # print
      exit()
    if (mm.work.startswith("array*") or mm.work.startswith("object*")):
      if (mm.work != "array*" and mm.work != "object*" and not mm.work.endswith(",*") and not mm.work.endswith("}*") and not mm.work.endswith("]*")):
        mm.work = ''              # clear
        mm.work += "Json error near line "
        mm.work += str(mm.linesRead) # lines 
        mm.work += " char "
        mm.work += str(mm.charsRead) # chars 
        mm.work += ")\n"
        sys.stdout.write(mm.work) # print
        exit()
    # invalid string sequence
    if (mm.work.startswith("string*")):
      if (mm.work != "string*" and not mm.work.endswith(",*") and not mm.work.endswith("]*") and not mm.work.endswith("}*") and not mm.work.endswith(":*")):
        mm.work = ''              # clear
        mm.work += "JSON syntax error after a string near line "
        mm.work += str(mm.linesRead) # lines 
        mm.work += " (char "
        mm.work += str(mm.charsRead) # chars 
        mm.work += ")\n"
        sys.stdout.write(mm.work) # print
        exit()
    # transmogrify into array item, start array
    if (mm.work == "[*decimal*" or mm.work == "[*number*" or mm.work == "[*string*" or mm.work == "[*value*" or mm.work == "[*array*" or mm.work == "[*object*"):
      mm.work = ''              # clear
      mm.work += "[*items*"
      mm.push();
      mm.push();
      continue
    # where does a number terminate, this is the problem
    # It terminates at the tokens ,* }* ]* and maybe space but 
    # this script doesnt have a space* token.
    if (mm.work == "sign.integer*,*" or mm.work == "integer*,*"):
      mm.work = ''              # clear
      mm.work += "number*,*"
      mm.push();
      mm.push();
      continue
    # transmog. tricky 
    if (mm.work == "sign.integer*]*" or mm.work == "integer*]*"):
      mm.work = ''              # clear
      mm.work += "items*]*"
      mm.push();
      mm.push();
      continue
    if (mm.work == "sign.integer*}*" or mm.work == "integer*}*"):
      mm.work = ''              # clear
      mm.work += "number*}*"
      mm.push();
      mm.push();
      continue
    # signed numbers
    if (mm.work == "-*integer*" or mm.work == "+*integer*"):
      mm.work = ''              # clear
      mm.work += "sign.integer*"
      mm.push();
      continue
    # empty arrays are legal json
    if (mm.work == "[*]*"):
      mm.work = ''              # clear
      mm.work += "array*"
      mm.push();
      continue
    # empty objects are legal json
    if (mm.work == "{*}*"):
      mm.work = ''              # clear
      mm.work += "object*"
      mm.push();
      continue
    # --------------
    # 3 tokens
    mm.pop();
    #---------------
    # Some three token errors
    # Object errors
    # A negative logic doesnt work because of the lookahead required for numbers
    if (mm.work == "{*string*}*" or mm.work == "{*integer*}*" or mm.work == "{*sign.integer*}*" or mm.work == "{*array*}*" or mm.work == "{*object*}*" or mm.work == "{*value*}*" or mm.work == "{*decimal*}*"):
      mm.work = ''              # clear
      mm.work += "Json syntax error near line "
      mm.work += str(mm.linesRead) # lines 
      mm.work += ", char "
      mm.work += str(mm.charsRead) # chars 
      mm.work += " (misplaced brace '}' or bad object) \n"
      mm.work += "A '}' can only occur to terminate an object structure \n"
      mm.work += "Example: {\"hour\":21.00, \"cancelled\":true} \n"
      sys.stdout.write(mm.work) # print
      exit()
    # transmogrify number into array item
    if (mm.work == "[*number*,*"):
      mm.work = ''              # clear
      mm.work += "[*items*,*"
      mm.push();
      mm.push();
      mm.push();
      continue
    # decimal numbers eg -4.334 or +4.3 or 0.1
    if (mm.work == "sign.integer*.*integer*" or mm.work == "integer*.*integer*"):
      mm.work = ''              # clear
      mm.work += "decimal*"
      mm.push();
      continue
    # arrays, 
    if (mm.work == "[*items*]*"):
      mm.work = ''              # clear
      mm.work += "array*"
      mm.push();
      continue
    # 
    if (mm.work == "items*,*decimal*" or mm.work == "items*,*string*" or mm.work == "items*,*value*" or mm.work == "items*,*array*" or mm.work == "items*,*object*"):
      mm.work = ''              # clear
      mm.work += "items*"
      mm.push();
      continue
    # object members
    #"string*:*integer*",
    if (mm.work == "string*:*decimal*" or mm.work == "string*:*string*" or mm.work == "string*:*value*" or mm.work == "string*:*object*" or mm.work == "string*:*array*"):
      mm.work = ''              # clear
      mm.work += "member*"
      mm.push();
      continue
    # multiple elements of an object
    if (mm.work == "member*,*member*" or mm.work == "members*,*member*"):
      mm.work = ''              # clear
      mm.work += "members*"
      mm.push();
      continue
    #  
    if (mm.work == "{*members*}*" or mm.work == "{*member*}*"):
      mm.work = ''              # clear
      mm.work += "object*"
      mm.push();
      continue
    mm.pop();
    # --------------
    # 4 tokens
    if (mm.work == "items*,*items*,*" or mm.work == "items*,*number*,*"):
      mm.work = ''              # clear
      mm.work += "items*,*"
      mm.push();
      mm.push();
      continue
    # numbers require a lookahead token, unfortunately 
    if (mm.work == "string*:*number*,*"):
      mm.work = ''              # clear
      mm.work += "member*,*"
      mm.push();
      mm.push();
      continue
    # numbers require a lookahead token, unfortunately 
    if (mm.work == "string*:*number*}*"):
      mm.work = ''              # clear
      mm.work += "member*}*"
      mm.push();
      mm.push();
      continue
    # multiple elements of an object with lookahead
    if (mm.work == "member*,*member*,*" or mm.work == "members*,*member*,*"):
      mm.work = ''              # clear
      mm.work += "members*,*"
      mm.push();
      mm.push();
      continue
    # multiple elements of an object with lookahead
    if (mm.work == "member*,*member*}*" or mm.work == "members*,*member*}*"):
      mm.work = ''              # clear
      mm.work += "members*}*"
      mm.push();
      mm.push();
      continue
    mm.pop();
    # --------------
    # 5 tokens
    # need this clumsy rule for numbers which get resolved when
    # a ] is seen. This is the lookahead
    if (mm.work == "[*items*,*items*]*"):
      mm.work = ''              # clear
      mm.work += "array*"
      mm.push();
      continue
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    if (mm.eof):
      while (mm.pop()):  continue    # unstack 
      if (mm.work == "object*" or mm.work == "array*" or mm.work == "value*" or mm.work == "string*" or mm.work == "integer*"):
        while (mm.push()):  continue   # stack 
        mm.work += "(Appears to be) valid JSON syntax. Top level structure was '"
        sys.stdout.write(mm.work) # print
        mm.work = ''              # clear
        mm.pop();
        # if len(mm.work) > 0:  # clip 
        mm.work = mm.work[:-1]  # clip
        mm.work += "'\n"
        sys.stdout.write(mm.work) # print
        mm.work = ''              # clear
        exit()
      while (mm.push()):  continue   # stack 
      mm.work += "Invalid JSON \n"
      mm.work += "Caveat: this script currently only recognises signed decimal \n"
      mm.work += "in the form -22.123 but not scientific numbers in the form \n"
      mm.work += "-6.11E+10 .\n"
      mm.work += "The parse stack was \n"
      sys.stdout.write(mm.work) # print
      mm.work = ''              # clear
      while (mm.pop()):  continue    # unstack 
      mm.work += "\n"
      sys.stdout.write(mm.work) # print
    break # parse
  

# end of generated code
