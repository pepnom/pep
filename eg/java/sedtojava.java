

 /* Java code generated by "translate.java.pss" */
 import java.io.*;
 import java.util.regex.*;
 import java.util.*;   // contains stack

 public class sedtojava {
   // using int instead of char so that all unicode code points are
   // available instead of just utf16. (emojis cant fit into utf16)
   private int accumulator;         // counter for anything
   private int peep;                // next char in input stream
   private int charsRead;           // No. of chars read so far
   private int linesRead;           // No. of lines read so far
   public StringBuffer workspace;    // text accumulator
   private Stack<String> stack;      // parse token stack
   private int LENGTH;               // tape initial length

   // use ArrayLists instead with .add() .get(n) and .set(n, E)
   // ArrayList<StringBuffer> al=new ArrayList<StringBuffer>();
   private List<StringBuffer> tape;      // array of token attributes 
   private List<StringBuffer> marks;     // tape marks
   private int tapePointer;          // pointer to current cell
   private Reader input;             // text input stream
   private boolean eof;              // end of stream reached?
   private boolean flag;             // not used here
   private StringBuffer escape;    // char used to "escape" others "\"
   private StringBuffer delimiter; // push/pop delimiter (default is "*")
   private boolean markFound;      // if the mark was found in tape
   
   /** make a new machine with a character stream reader */
   public sedtojava(Reader reader) {
     this.markFound = false; 
     this.LENGTH = 100;
     this.input = reader;
     this.eof = false;
     this.flag = false;
     this.charsRead = 0; 
     this.linesRead = 1; 
     this.escape = new StringBuffer("\\");
     this.delimiter = new StringBuffer("*");
     this.accumulator = 0;
     this.workspace = new StringBuffer("");
     this.stack = new Stack<String>();
     this.tapePointer = 0;
     this.tape = new ArrayList<StringBuffer>();
     this.marks = new ArrayList<StringBuffer>();
     for (int ii = 0; ii < this.LENGTH; ii++) {
       this.tape.add(new StringBuffer(""));
       this.marks.add(new StringBuffer(""));
     }

     try
     { this.peep = this.input.read(); } 
     catch (java.io.IOException ex) {
       System.out.println("read error");
       System.exit(-1);
     }
   }

   /** read one character from the input stream and 
       update the machine. */
   public void read() {
     int iChar;
     try {
       if (this.eof) { System.exit(0); }
       this.charsRead++;
       // increment lines
       if ((char)this.peep == '\n') { this.linesRead++; }
       this.workspace.append(Character.toChars(this.peep));
       this.peep = this.input.read(); 
       if (this.peep == -1) { this.eof = true; }
     }
     catch (IOException ex) {
       System.out.println("Error reading input stream" + ex);
       System.exit(-1);
     }
   }

   /** increment tape pointer by one */
   public void increment() {
     this.tapePointer++;
     if (this.tapePointer >= this.LENGTH) {
       this.tape.add(new StringBuffer(""));
       this.marks.add(new StringBuffer(""));
       this.LENGTH++;
     }
   }
   
   /** remove escape character  */
   public void unescapeChar(char c) {
     if (workspace.length() > 0) {
       String s = this.workspace.toString().replace("\\"+c, c+"");
       this.workspace.setLength(0); workspace.append(s);
     }
   }

   /** add escape character  */
   public void escapeChar(char c) {
     if (workspace.length() > 0) {
       String s = this.workspace.toString().replace(c+"", "\\"+c);
       workspace.setLength(0); workspace.append(s);
     }
   }

   /** whether trailing escapes \\ are even or odd */
   // untested code. check! eg try: add "x \\"; print; etc
   public boolean isEscaped(String ss, String sSuffix) {
     int count = 0; 
     if (ss.length() < 2) return false;
     if (ss.length() <= sSuffix.length()) return false;
     if (ss.indexOf(this.escape.toString().charAt(0)) == -1) 
       { return false; }

     int pos = ss.length()-sSuffix.length();
     while ((pos > -1) && (ss.charAt(pos) == this.escape.toString().charAt(0))) {
       count++; pos--;
     }
     if (count % 2 == 0) return false;
     return true;
   }

   /* a helper to see how many trailing \\ escape chars */
   private int countEscaped(String sSuffix) {
     String s = "";
     int count = 0;
     int index = this.workspace.toString().lastIndexOf(sSuffix);
     // remove suffix if it exists
     if (index > 0) {
       s = this.workspace.toString().substring(0, index);
     }
     while (s.endsWith(this.escape.toString())) {
       count++;
       s = s.substring(0, s.lastIndexOf(this.escape.toString()));
     }
     return count;
   }

   /** reads the input stream until the workspace end with text */
   // can test this with
   public void until(String sSuffix) {
     // read at least one character
     if (this.eof) return; 
     this.read();
     while (true) {
       if (this.eof) return;
       if (this.workspace.toString().endsWith(sSuffix)) {
         if (this.countEscaped(sSuffix) % 2 == 0) { return; }
       }
       this.read();
     }
   }

   /** pop the first token from the stack into the workspace */
   public Boolean pop() {
     if (this.stack.isEmpty()) return false;
     this.workspace.insert(0, this.stack.pop());     
     if (this.tapePointer > 0) this.tapePointer--;
     return true;
   }

   /** push the first token from the workspace to the stack */
   public Boolean push() {
     String sItem;
     // dont increment the tape pointer on an empty push
     if (this.workspace.length() == 0) return false;
     // need to get this from this.delim not "*"
     int iFirstStar = 
       this.workspace.indexOf(this.delimiter.toString());
     if (iFirstStar != -1) {
       sItem = this.workspace.toString().substring(0, iFirstStar + 1);
       this.workspace.delete(0, iFirstStar + 1);
     }
     else {
       sItem = this.workspace.toString();
       this.workspace.setLength(0);
     }
     this.stack.push(sItem);     
     this.increment(); 
     return true;
   }

   /** swap current tape cell with the workspace */
   public void swap() {
     String s = new String(this.workspace);
     this.workspace.setLength(0);
     this.workspace.append(this.tape.get(this.tapePointer).toString());
     this.tape.get(this.tapePointer).setLength(0);
     this.tape.get(this.tapePointer).append(s);
   }

   /** save the workspace to file "sav.pp" */
   public void writeToFile() {
     try {
       File file = new File("sav.pp");
       Writer out = new BufferedWriter(new OutputStreamWriter(
          new FileOutputStream(file), "UTF8"));
       out.append(this.workspace.toString());
       out.flush(); out.close();
     } catch (Exception e) { 
       System.out.println(e.getMessage());
     }
   }

   public void goToMark(String mark) {
     this.markFound = false; 
     for (var ii = 0; ii < this.marks.size(); ii++) {
       if (this.marks.get(ii).toString().equals(mark)) { 
         this.tapePointer = ii; this.markFound = true; 
       }
     }
     if (this.markFound == false) { 
       System.out.print("badmark '" + mark + "'!"); 
       System.exit(1);
     }
   }

   /** parse/check/compile the input */
   public void parse(InputStreamReader input) {
     //this is where the actual parsing/compiling code should go 
     //but this means that all generated code must use
     //"this." not "mm."
   }

  public static void main(String[] args) throws Exception { 
    String temp = "";    
    sedtojava mm = new sedtojava(new InputStreamReader(System.in)); 

    script: 
    while (!mm.eof) {
      lex: { 
        mm.read(); /* read */
        // make char number relative to line, for error messages
        if (mm.workspace.toString().matches("^[\n]+$")) {
          mm.charsRead = 0; /* nochars */
        }
        // newlines can separate commands in (gnu) sed so we will
        // just add a dummy ';' here. Also, no trailing ; is required
        if (mm.workspace.toString().matches("^[\n]+$")) {
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(";*"); /* add */
          mm.push();
          break lex;
        }
        // ignore extraneous white-space?
        if (mm.workspace.toString().matches("^\\p{Space}+$")) {
          mm.workspace.setLength(0);            /* clear */
          if (mm.eof) {
            break lex;
          }
          continue script;
        }
        // comments, convert to java comments
        if (mm.workspace.toString().equals("#")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("/* "); /* add */
          mm.until("\n");
          if (mm.workspace.toString().endsWith("\n")) {
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
          }
          mm.workspace.append(" */\n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // uncomment line below to include comments in output
          // add "comment*"; push; .reparse
        }
        // literal tokens '{' and '}' are used to group commands in
        // sed, ';' is used to separate commands and ',' to separate line
        // ranges. ! is the postfix negation operator for ranges
        if (mm.workspace.toString().equals("~") || mm.workspace.toString().equals(",") || mm.workspace.toString().equals("{") || mm.workspace.toString().equals("}") || mm.workspace.toString().equals(";") || mm.workspace.toString().equals("!")) {
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.append("*"); /* add */
          mm.push();
          break lex;
        }
        // various actions: print, delete, swap
        if (mm.workspace.toString().equals("=") || mm.workspace.toString().equals("p") || mm.workspace.toString().equals("P") || mm.workspace.toString().equals("l") || mm.workspace.toString().equals("d") || mm.workspace.toString().equals("D") || mm.workspace.toString().equals("F") || mm.workspace.toString().equals("g") || mm.workspace.toString().equals("G") || mm.workspace.toString().equals("h") || mm.workspace.toString().equals("H") || mm.workspace.toString().equals("n") || mm.workspace.toString().equals("N") || mm.workspace.toString().equals("x") || mm.workspace.toString().equals("z")) {
          if (mm.workspace.toString().equals("=")) {
            mm.workspace.setLength(0);            /* clear */
            // print line-number + newline
            mm.workspace.append("this.output.write(String.valueOf(this.linesRead)+'\\n');\n"); /* add */
            mm.workspace.append("this.output.flush(); /* '=' */"); /* add */
          }
          if (mm.workspace.toString().equals("d")) {
            mm.workspace.setLength(0);            /* clear */
            // 'd' delete pattern-space, restart 
            // the if true trick is necessary to avoid 'unreachable statement'
            // java compile errors (when multiple 'd' commands are given)
            mm.workspace.append("if (true) { this.patternSpace.setLength(0); continue; } /* 'd' */"); /* add */
          }
          if (mm.workspace.toString().equals("D")) {
            mm.workspace.setLength(0);            /* clear */
            // add "/* 'D' delete pattern-space to 1st \\n, restart */";
            mm.workspace.append("if (this.patternSpace.indexOf(\"\\n\") > -1) {\n"); /* add */
            mm.workspace.append("  this.patternSpace.delete(0, this.patternSpace.indexOf(\"\\n\"));\n"); /* add */
            mm.workspace.append("  this.readNext = false; if (true) continue; \n"); /* add */
            mm.workspace.append("} else { this.patternSpace.setLength(0); continue; } /* 'd' */"); /* add */
          }
          if (mm.workspace.toString().equals("F")) {
            // F: print input filename + newline
            // maybe unsupported in java
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.output.write(\"<unknown-file>\n\");  /* F */"); /* add */
          }
          if (mm.workspace.toString().equals("g")) {
            // g: replace patt-space with hold-space
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.patternSpace.setLength(0); \n"); /* add */
            mm.workspace.append("this.patternSpace.append(this.holdSpace);  /* 'g' */"); /* add */
          }
          if (mm.workspace.toString().equals("G")) {
            // G; append hold-space to patt-space + \\n"
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.patternSpace.append(\"\\n\" + this.holdSpace);  /* 'G' */"); /* add */
          }
          if (mm.workspace.toString().equals("h")) {
            // h:  replace hold-space with patt-space
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.holdSpace.setLength(0); \n"); /* add */
            mm.workspace.append("this.holdSpace.append(this.patternSpace);  /* 'h' */"); /* add */
          }
          if (mm.workspace.toString().equals("H")) {
            // H:  append patt-space to hold-space + newline
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.holdSpace.append(\"\\n\" + this.patternSpace);  /* 'H' */"); /* add */
          }
          if (mm.workspace.toString().equals("l")) {
            // print pattern-space unambiguously, synonym for p ?
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.output.write(this.patternSpace.toString()+'\\n'); /* 'l' */"); /* add */
          }
          if (mm.workspace.toString().equals("n")) {
            // n: print patt-space, get next line into patt-space
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if (this.autoPrint) { \n"); /* add */
            mm.workspace.append("  this.output.write(this.patternSpace.toString()+'\\n');\n}\n"); /* add */
            mm.workspace.append("this.patternSpace.setLength(0);\n"); /* add */
            mm.workspace.append("this.readLine();   /* 'n' */"); /* add */
          }
          if (mm.workspace.toString().equals("N")) {
            // N: append next line to patt-space + newline
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.patternSpace.append('\\n'); "); /* add */
            mm.workspace.append("this.readLine();  /* 'N' */"); /* add */
          }
          if (mm.workspace.toString().equals("p")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.output.write(this.patternSpace.toString()+'\\n'); /* 'p' */"); /* add */
          }
          if (mm.workspace.toString().equals("P")) {
            // P: print pattern-space up to 1st newline"
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if (this.patternSpace.indexOf(\"\\n\") > -1) {\n"); /* add */
            mm.workspace.append("  this.output.write(\n"); /* add */
            mm.workspace.append("    this.patternSpace.substring(0, \n"); /* add */
            mm.workspace.append("    this.patternSpace.indexOf(\"\\n\"))+\'\\n\');\n"); /* add */
            mm.workspace.append("} else { this.output.write(this.patternSpace.toString()+'\\n'); }"); /* add */
          }
          if (mm.workspace.toString().equals("x")) {
            // x:  # swap pattern-space with hold-space
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.swap();  /* x */"); /* add */
          }
          if (mm.workspace.toString().equals("z")) {
            // z:  delete pattern-space, NO restart
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.patternSpace.setLenth(0); /* z */"); /* add */
          }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("action*"); /* add */
          mm.push();
          break lex;
        }
        // M and I are modifiers to selectors (multiline and case insensitive)
        // eg /apple/Ip; or /A/M,/b/I{p;p}
        if (mm.workspace.toString().equals("M") || mm.workspace.toString().equals("I")) {
          if (mm.workspace.toString().equals("I")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("(?i)"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
          }
          if (mm.workspace.toString().equals("M")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("(?m)"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
          }
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("mod*"); /* add */
          mm.push();
          break lex;
        }
        // patterns - only execute commands if lines match 
        // line numbers are also selectors
        if (mm.workspace.toString().matches("^[0-9]+$")) {
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[0-9]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("number*"); /* add */
          mm.push();
          break lex;
        }
        // $ is the last line of the file
        if (mm.workspace.toString().equals("$")) {
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("number*"); /* add */
          mm.push();
          break lex;
        }
        // patterns - only execute commands if lines match 
        if (mm.workspace.toString().equals("/")) {
          // save line/char number for error message 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("near line/char "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(":"); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.until("/");
          if (!mm.workspace.toString().endsWith("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Missing '/' to terminate "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("?\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          // java .matches method matches whole string not substring
          // so we need to add .* at beginning and end, but not if regex
          // begins with ^ or ends with $. complicated hey
          if (!mm.workspace.toString().endsWith("$")) {
            mm.workspace.append(".*$"); /* add */
          }
          if (!mm.workspace.toString().startsWith("^")) {
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("^.*"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // add any delimiter for pattern here, or none
          mm.workspace.append("\""); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\""); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("pattern*"); /* add */
          mm.push();
          break lex;
        }
        // read transliteration commands
        if (mm.workspace.toString().equals("y")) {
          // save line/char number for error message 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("near line "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(", char "); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // allow spaces between 'y' and '/' although gnu set doesn't
          mm.until("/");
          if (!mm.workspace.toString().endsWith("/") || !mm.workspace.toString().matches("^[ /]+$")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Missing '/' after 'y' transliterate command\n"); /* add */
            mm.workspace.append("Or trailing characters "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          // save line/char number for error message 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("near line "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(", char "); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.until("/");
          if (!mm.workspace.toString().endsWith("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Missing 2nd '/' after 'y' transliterate command "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          if (mm.workspace.toString().equals("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Sed syntax error? \n"); /* add */
            mm.workspace.append("  Empty regex after 'y' transliterate command "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          // replace pattern found
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("this.transliterate(\""); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\", \""); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // save line/char number for error message 
          mm.workspace.append("near line "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(", char "); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.until("/");
          if (!mm.workspace.toString().endsWith("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Missing 3rd '/' after 'y' transliterate command "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          mm.swap();
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\");   /* y */ "); /* add */
          // y/// does not have modifiers (unlike s///)
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("action*"); /* add */
          mm.push();
          break lex;
        }
        // this is an artificial block, created by the code below
        // which reads multiline append/changes/inserts one char at a time
        if (mm.workspace.toString().startsWith("a\\") || mm.workspace.toString().startsWith("c\\") || mm.workspace.toString().startsWith("i\\")) {
          // print; print; print;
          if (mm.workspace.toString().endsWith("\\\n")) {
            // turn multiline into java single line with \n
            // \ means continue text on next line. 
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            mm.workspace.append("\\n"); /* add */
            continue script;
          }
          // end of stream means we are finished, so add a dummy
          // \n
          if (mm.eof) {
            mm.workspace.append("\n"); /* add */
          }
          if (mm.workspace.toString().endsWith("\n") && !mm.workspace.toString().endsWith("\\\n")) {
            // finished! the !E"\\\n" above is unnecessary (already checked) 
            // but I will leave for clarity
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("\n", "\\n");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            if (mm.workspace.toString().startsWith("a\\")) {
              if (mm.workspace.length() > 0) { /* clop */
                mm.workspace.delete(0, 1); }   /* clop */
              if (mm.workspace.length() > 0) { /* clop */
                mm.workspace.delete(0, 1); }   /* clop */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("this.patternSpace.append('\\n'+\""); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("\");"); /* add */
            }
            if (mm.workspace.toString().startsWith("c\\")) {
              if (mm.workspace.length() > 0) { /* clop */
                mm.workspace.delete(0, 1); }   /* clop */
              if (mm.workspace.length() > 0) { /* clop */
                mm.workspace.delete(0, 1); }   /* clop */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("this.patternSpace.setLength(0);\n"); /* add */
              mm.workspace.append("this.patternSpace.append(\""); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("\");"); /* add */
            }
            if (mm.workspace.toString().startsWith("i\\")) {
              if (mm.workspace.length() > 0) { /* clop */
                mm.workspace.delete(0, 1); }   /* clop */
              if (mm.workspace.length() > 0) { /* clop */
                mm.workspace.delete(0, 1); }   /* clop */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("this.patternSpace.insert(0, \""); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("\"+\'\\n\');"); /* add */
            }
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("action*;*"); /* add */
            mm.push();
            mm.push();
            break lex;
          }
          continue script;
        }
        // the add/change/insert commands: have 2 forms
        //   a text or a\ <multiline text>
        if (mm.workspace.toString().equals("a") || mm.workspace.toString().equals("c") || mm.workspace.toString().equals("i")) {
          // ignore intervening space if any
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[ \t\f]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.workspace.setLength(0);            /* clear */
          if (mm.eof) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Sed syntax error? (near line:char "); /* add */
            mm.workspace.append(mm.linesRead); /* lines */
            mm.workspace.append(":"); /* add */
            mm.workspace.append(mm.charsRead); /* chars */
            mm.workspace.append(")\n"); /* add */
            mm.workspace.append("  No argument for '"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("' command.\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          // also handle the a\ multiline form here
          // The following are ok: 'a\ text' 'a  \ text ' 
          //   'a \ text \
              #      text'
          // So a\ can be terminated by eof, or \n without \\
          // strategy: read one char, check for \\, if so restart
          // and write a block "a\\","i\\" etc, and read one char
          // at a time until ends with \n but not \\\n
          // if the first not whitespace char is "\" then we need to read
          // the inputstream until it ends with \n but not \\\n. This 
          // is the a\ i\ c\ syntax  This is tricky with pep at the moment.
          // allowing logic syntax for 'until' would solve this. eg
          //  until "\n".!"\\\n";
          // or allow 2 args to until;
          mm.read(); /* read */
          if (mm.workspace.toString().startsWith("\\")) {
            mm.swap();
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            //print; print; print;
            // now should be a\\ or c\\ or i\\
            // this will be handled by the block above.
            continue script;
          }
          if (mm.eof && mm.workspace.toString().equals("\n")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("[Sed syntax error?] (near line:char "); /* add */
            mm.workspace.append(mm.linesRead); /* lines */
            mm.workspace.append(":"); /* add */
            mm.workspace.append(mm.charsRead); /* chars */
            mm.workspace.append(")\n"); /* add */
            mm.workspace.append("  No argument for '"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("' command.\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          mm.until("\n");
          if (mm.eof) {
            if (mm.workspace.toString().endsWith("\n")) {
              if (mm.workspace.length() > 0) { /* clip */
                mm.workspace.delete(mm.workspace.length() - 1, 
                mm.workspace.length()); }
            }
            if (mm.workspace.toString().equals("")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("{Sed syntax error?] (near line:char "); /* add */
              mm.workspace.append(mm.linesRead); /* lines */
              mm.workspace.append(":"); /* add */
              mm.workspace.append(mm.charsRead); /* chars */
              mm.workspace.append(")\n"); /* add */
              mm.workspace.append("  No argument for '"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("' command.\n"); /* add */
              System.out.print(mm.workspace); /* print */
              break script;
            }
          }
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\n", "\\n");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          mm.swap();
          if (mm.workspace.toString().equals("a")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.patternSpace.append('\\n'+\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\");"); /* add */
          }
          if (mm.workspace.toString().equals("c")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.patternSpace.setLength(0);\n"); /* add */
            mm.workspace.append("this.patternSpace.append(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\");"); /* add */
          }
          if (mm.workspace.toString().equals("i")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.patternSpace.insert(0, \""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\"+\'\\n\');"); /* add */
          }
          // should work, because 'this' starts with 't' not a/c/i
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("action*;*"); /* add */
          mm.push();
          mm.push();
          break lex;
        }
        // various commands that have an option word parameter 
        // e has two variants
        //  "e" { replace "e" "e;  # exec patt-space command and replace"; }
        if (mm.workspace.toString().equals("b") || mm.workspace.toString().equals("e") || mm.workspace.toString().equals("q") || mm.workspace.toString().equals("Q") || mm.workspace.toString().equals("t") || mm.workspace.toString().equals("T")) {
          // ignore intervening space if any
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[ ]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.workspace.setLength(0);            /* clear */
          // A bit more permissive that gnu-sed which doesn't allow
          // read to end in ';'.
          /* whilenot */ 
          while (!Character.toString((char)mm.peep).matches("^[ ;}]+$")) { if (mm.eof) { break; } mm.read(); }
          // word parameters are optional to these commands
          // just add a space to separate command from parameter
          if (!mm.workspace.toString().equals("")) {
            mm.swap();
            mm.workspace.append(" "); /* add */
            mm.swap();
          }
          mm.swap();
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          // hard to implement because java has no goto ?
          // or try to use labelled loops??
          if (mm.workspace.toString().startsWith("b")) {
            mm.workspace.setLength(0);            /* clear */
            // todo: 'b'  branch to <label> or start";
            mm.workspace.append("this.unsupported(\"b -branch \");\n"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("e ")) {
            mm.workspace.setLength(0);            /* clear */
            // 'e <cmd>' exec <cmd> and insert into outputfk
            mm.workspace.append("System.out.print(this.execute(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\"));  /* \"e <cmd>\" */"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().equals("e")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("temp = this.patternSpace.toString();\n"); /* add */
            mm.workspace.append("this.patternSpace.setLength(0);  /* 'e' */\n"); /* add */
            mm.workspace.append("this.patternSpace.append(this.execute(temp)); "); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().equals("q")) {
            // q; print + quit
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.output.write(this.patternSpace.toString()+'\\n');\n"); /* add */
            mm.workspace.append("System.exit(0);"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("q ")) {
            // q; print + quit with exit code
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("this.output.write(this.patternSpace.toString()+'\\n');\n"); /* add */
            mm.workspace.append("System.exit("); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(");"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().equals("Q")) {
            // Q; quit, dont print
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("System.exit(0);"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("Q ")) {
            // Q; quit with exit code, dont print
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("System.exit("); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(");"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("t")) {
            mm.workspace.setLength(0);            /* clear */
            // 't' command not implemented yet! \n";
            // (branch to <label> if substitution made or start)"; 
            mm.workspace.append("this.unsupported(\"t - branch \");\n"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("T")) {
            mm.workspace.setLength(0);            /* clear */
            // 'T' command not implemented yet! \n";
            // (branch to <label> if NO substitution made or start)"; 
            mm.workspace.append("this.unsupported(\"T - branch \");\n"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          mm.workspace.append("action*"); /* add */
          mm.push();
          break lex;
        }
        // read 'read <filename>' and write commands
        if (mm.workspace.toString().equals(":") || mm.workspace.toString().equals("r") || mm.workspace.toString().equals("R") || mm.workspace.toString().equals("w") || mm.workspace.toString().equals("W")) {
          // ignore intervening space if any
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[ ]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.workspace.setLength(0);            /* clear */
          // A bit more permissive that gnu-sed which doesn't allow
          // read to end in ';'. i.e. filename cant contain ; or } in
          // this version.
          /* whilenot */ 
          while (!Character.toString((char)mm.peep).matches("^[ ;}]+$")) { if (mm.eof) { break; } mm.read(); }
          if (mm.workspace.toString().equals("")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Sed syntax error? (at line:char "); /* add */
            mm.workspace.append(mm.linesRead); /* lines */
            mm.workspace.append(":"); /* add */
            mm.workspace.append(mm.charsRead); /* chars */
            mm.workspace.append(")\n"); /* add */
            mm.workspace.append("  no filename for read 'r' command. \n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          mm.swap();
          mm.workspace.append(" "); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.workspace.toString().startsWith(": ")) {
            mm.workspace.setLength(0);            /* clear */
            // todo?: ':' branch to <label>\n"; 
            // might be hard without 'goto' !";
            mm.workspace.append("this.unsupported(\": - branchlabel \");\n"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("r ")) {
            mm.workspace.setLength(0);            /* clear */
            // r' read file into patt-space
            mm.workspace.append("/* \"r\" */\n"); /* add */
            mm.workspace.append("Path path = Path.of(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\");\n"); /* add */
            mm.workspace.append("File f = new File(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\"); \n"); /* add */
            mm.workspace.append("if (f.isFile()) { \n"); /* add */
            mm.workspace.append("  this.patternSpace.append(Files.readString(path));\n"); /* add */
            mm.workspace.append("}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("R ")) {
            mm.workspace.setLength(0);            /* clear */
            // 'R' insert file into output before next line"; 
            // bug! inserts file immediately into output.
            mm.workspace.append("/* \"R\" */\n"); /* add */
            mm.workspace.append("Path path = Path.of(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\");\n"); /* add */
            mm.workspace.append("File f = new File(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\"); \n"); /* add */
            mm.workspace.append("if (f.isFile()) { \n"); /* add */
            mm.workspace.append("  this.output.write(Files.readString(path)+'\\n');\n"); /* add */
            //add '  System.out.println(Files.readString(path));\n';
            mm.workspace.append("}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("w ")) {
            mm.workspace.setLength(0);            /* clear */
            // 'w' write patt-space to file"; 
            mm.workspace.append("this.writeToFile(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\");"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          // mm.writeToFile(name)
          if (mm.workspace.toString().startsWith("W ")) {
            mm.workspace.setLength(0);            /* clear */
            // 'W' write 1st line of patt-space to file"; 
            mm.workspace.append("this.writeFirstToFile(\""); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\");"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          mm.workspace.append("action*"); /* add */
          mm.push();
          break lex;
        }
        // read substitution commands
        if (mm.workspace.toString().equals("s")) {
          // save line/char number for error message 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("near line/char "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(":"); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // allow spaces between 's' and '/' ??? 
          mm.until("/");
          if (!mm.workspace.toString().endsWith("/") || !mm.workspace.toString().matches("^[ /]+$")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Missing '/' after 's' substitute command\n"); /* add */
            mm.workspace.append("Or trailing characters "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          // save line/char number for error message 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("near line "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(", char "); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.until("/");
          if (!mm.workspace.toString().endsWith("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Sed syntax error? \n"); /* add */
            mm.workspace.append("  Missing 2nd '/' after 's' substitute command "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          if (mm.workspace.toString().equals("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Sed syntax error? \n"); /* add */
            mm.workspace.append("  Empty regex after 's' substitute command "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          // replace pattern found
          // legal escape chars in java are \t \b \n \r \f \' \" \\
          // anything else will crash the compiler and needs to be eliminated
          // but may have to live with this
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\(", "(");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\)", ")");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\'", "'");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("this.substitute(\""); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\", \""); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // save line/char number for error message 
          mm.workspace.append("near line/char "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(":"); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.until("/");
          if (!mm.workspace.toString().endsWith("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("Missing 3rd '/' after 's' substitute command "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          // this is a hack
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\1", "$1");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\2", "$2");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\3", "$3");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\4", "$4");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\5", "$5");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\6", "$6");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\7", "$7");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\8", "$8");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\9", "$9");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          mm.swap();
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\", \""); /* add */
          // also need to read s/// modifiers, eg e/w/m/g/i/p/[0-9] etc
          // in gnu sed 'w filename' reads filename to end of line, so
          // no other commands on that line. 
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[emgip0123456789]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.workspace.append("\", \""); /* add */
          // now read filename given to 'w' switch (if any)
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[w]+$")) { if (mm.eof) { break; } mm.read(); }
          if (mm.workspace.toString().endsWith("w")) {
            // gnu-sed allows ';' in filename, but I wont (for now)
            // will need to use substitute method to trim whitespace from
            // the filename and remove leading 'w'
            /* whilenot */ 
            while (!Character.toString((char)mm.peep).matches("^[;\n]+$")) { if (mm.eof) { break; } mm.read(); }
          }
          mm.workspace.append("\");   /* s */ "); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("action*"); /* add */
          mm.push();
          break lex;
        }
        if (mm.workspace.toString().equals("b") || mm.workspace.toString().equals("T") || mm.workspace.toString().equals("t")) {
          // branch 
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("Unimplemented command (near line:char "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(":"); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.workspace.append(")\n"); /* add */
          mm.workspace.append("  The script does not recognise '"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("' yet.\n"); /* add */
          System.out.print(mm.workspace); /* print */
          break script;
        }
        if (!mm.workspace.toString().equals("")) {
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("Sed syntax error? (near line:char "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(":"); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.workspace.append(")\n"); /* add */
          mm.workspace.append("  unrecognised command '"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("'\n"); /* add */
          System.out.print(mm.workspace); /* print */
          break script;
        }
        // where token reduction begins
      }
      parse: 
      while (true) { 
        // To visualise token reduction uncomment this below:
        mm.workspace.append("// "); /* add */
        mm.workspace.append(mm.linesRead); /* lines */
        mm.workspace.append(":"); /* add */
        mm.workspace.append(mm.charsRead); /* chars */
        mm.workspace.append(" "); /* add */
        System.out.print(mm.workspace); /* print */
        mm.workspace.setLength(0);            /* clear */
        mm.workspace.append("\n"); /* add */
        while (mm.pop());          /* unstack */
        System.out.print(mm.workspace); /* print */
        if (mm.workspace.length() > 0) { /* clip */
          mm.workspace.delete(mm.workspace.length() - 1, 
          mm.workspace.length()); }
        while(mm.push());          /* stack */
        // commands do not have to be terminated with ';' at the end of a sed script.
        if (mm.eof) {
          mm.pop();
          if (mm.workspace.toString().equals("action*")) {
            mm.workspace.append(";*"); /* add */
            mm.push();
            mm.push();
            continue parse;
          }
          mm.push();
        }
        mm.pop();
        mm.pop();
        mm.pop();
        mm.pop();
        mm.pop();
        mm.pop();
        // ----------------
        // 6 token reductions
        // these must be done first, to take precedence over 
        // eg pattern/{/commandset/}
        if (mm.workspace.toString().equals("pattern*,*pattern*{*commandset*}*") || mm.workspace.toString().equals("pattern*,*number*{*commandset*}*") || mm.workspace.toString().equals("number*,*number*{*commandset*}*") || mm.workspace.toString().equals("number*~*number*{*commandset*}*") || mm.workspace.toString().equals("number*,*pattern*{*commandset*}*")) {
          // also, need to indent the command set.
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.swap();
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\n", "\n  ");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          // use a brace token as temporary storage, so that we can
          // indent the 1st line of the commandset
          // should add 2 spaces but 1st line is getting an extra one.
          // somewhere...
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(" "); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.swap();
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          // using an array of boolean states to remember if a 
          // pattern has been 'seen'
          if (mm.workspace.toString().startsWith("pattern*,*pattern*")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if (this.line.toString().matches("); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(") && (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == false))\n  {"); /* add */
            mm.workspace.append(" this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] = true; }\n"); /* add */
            mm.workspace.append("if (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == true) {\n"); /* add */
            // get commandset at tape+4
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append("\n}\n"); /* add */
            // comes after so last line is matched 
            mm.workspace.append("if (this.line.toString().matches("); /* add */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append(") && (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == true))\n  {"); /* add */
            mm.workspace.append(" this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] = false; }\n"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.accumulator++; /* a+ */
          }
          if (mm.workspace.toString().startsWith("pattern*,*number*")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if (this.line.toString()..matches("); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(") && (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == false))\n"); /* add */
            mm.workspace.append("  { this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] = true; }\n"); /* add */
            mm.workspace.append("if (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == true) {\n "); /* add */
            // get commandset at tape+4
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append("\n}\n"); /* add */
            // put here to match last line in range 
            mm.workspace.append("if ((this.linesRead > "); /* add */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append(") && (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == true))\n"); /* add */
            mm.workspace.append("  { this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] = false; }\n"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.accumulator++; /* a+ */
          }
          if (mm.workspace.toString().startsWith("number*,*pattern*")) {
            mm.workspace.setLength(0);            /* clear */
            // but this logic doesn't include last line
            mm.workspace.append("if ((this.linesRead == "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(") && (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == false))\n"); /* add */
            mm.workspace.append("  { this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] = true; }\n"); /* add */
            mm.workspace.append("if (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == true) {\n "); /* add */
            // get commandset at tape+4
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append("\n}\n"); /* add */
            // after to match last line in range
            mm.workspace.append("if (this.line.toString().matches("); /* add */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append(") && (this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] == true))\n"); /* add */
            mm.workspace.append("  { this.states["); /* add */
            mm.workspace.append(mm.accumulator); /* count */
            mm.workspace.append("] = false; }\n"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.accumulator++; /* a+ */
          }
          if (mm.workspace.toString().startsWith("number*,*number*")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if ((this.linesRead >= "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(") && (this.linesRead <= "); /* add */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append(")) {\n"); /* add */
            // get commandset at tape+4
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append("\n}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            //a+;
          }
          if (mm.workspace.toString().startsWith("number*~*number*")) {
            // 0~8 step syntax 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if ((this.linesRead % "); /* add */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append(") == "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(") {\n"); /* add */
            // get commandset at tape+4
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append("\n}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
          }
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("command*"); /* add */
          mm.push();
          continue parse;
        }
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        // ---------------------------
        // priority 4 token reductions
        mm.pop();
        mm.pop();
        mm.pop();
        mm.pop();
        // these must be done first, to take precedence over 
        // eg pattern/command/} I forgot about this pattern.
        // a cool trick! just convert this to {*commandset*}* and 
        // reparse, so we dont have to rewrite all that code
        if (mm.workspace.toString().equals("pattern*,*pattern*command*") || mm.workspace.toString().equals("pattern*,*number*command*") || mm.workspace.toString().equals("number*,*number*command*") || mm.workspace.toString().equals("number*~*number*command*") || mm.workspace.toString().equals("number*,*pattern*command*")) {
          // preserve 1st 3 tokens
          mm.push();
          mm.push();
          mm.push();
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.append("{*commandset*}*"); /* add */
          mm.push();
          mm.push();
          mm.push();
          continue parse;
        }
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        //---------------
        // 2 tokens: 
        mm.pop();
        mm.pop();
        // modifiers only come after /.../
        if (mm.workspace.toString().endsWith("mod*") && !mm.workspace.toString().startsWith("pattern*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("[Sed syntax error?] near line:char "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(","); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.workspace.append("\n"); /* add */
          mm.workspace.append("  Modifiers (I,M) can only come after line pattern selectors  \n"); /* add */
          System.out.print(mm.workspace); /* print */
          break script;
        }
        if (mm.workspace.toString().equals("pattern*mod*")) {
          // remove quote from start of regex
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.workspace.length() > 0) { /* clop */
            mm.workspace.delete(0, 1); }   /* clop */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // add (?i) or (?m) at the beginning of the java pattern
          mm.workspace.append("\""); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("pattern*"); /* add */
          mm.push();
          continue parse;
        }
        //---------------
        // 3 tokens: 
        //   we have to do this first before the action*;* rule 
        //   is reduced.
        mm.pop();
        // change to the equivalent eg: range*{*command*}*
        // This avoids have to rewrite all the java code construction
        if (mm.workspace.toString().equals("range*action*;*") || mm.workspace.toString().equals("number*action*;*") || mm.workspace.toString().equals("pattern*action*;*")) {
          // preserve range/number/pattern parse token
          mm.push();
          mm.workspace.setLength(0);            /* clear */
          // transfer action/command code to the correct tapecell
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("{*commandset*}*"); /* add */
          mm.push();
          mm.push();
          mm.push();
          continue parse;
          // now we have on the stack, for example
          // range*{*commandset*}* which is already handled, and the 
          // code attributes should be in the right tape cells.
          // we could do: add "{*command*}*" but it doesnt matter....
        }
        // gnu sed allows empty braces, so we will too.
        // Another trick: push an empty commandset onto the stack
        // after a brace - that gets rid of this rule and also
        // the : command/command/ -> commandset/ rule
        if (mm.workspace.toString().equals("range*{*}*") || mm.workspace.toString().equals("number*{*}*") || mm.workspace.toString().equals("pattern*{*}*")) {
          // preserve 1st 2 tokens
          mm.push();
          mm.push();
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("  // warning: empty braces {} - does nothing!"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          // add a 'dummy' commandset and reparse.
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("commandset*}*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        mm.push();
        mm.push();
        mm.push();
        mm.pop();
        mm.pop();
        //---------------
        // 2 token errors
        if (mm.workspace.toString().equals("pattern*number*") || mm.workspace.toString().equals("pattern*pattern*") || mm.workspace.toString().equals("number*number*") || mm.workspace.toString().equals("number*pattern*") || mm.workspace.toString().equals("range*number*") || mm.workspace.toString().equals("range*pattern*") || mm.workspace.toString().equals("pattern*;*") || mm.workspace.toString().equals("number*;*") || mm.workspace.toString().equals("range*;*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("Sed syntax error? (near line:char "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(":"); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.workspace.append(")\n"); /* add */
          mm.workspace.append("  line selector/number/range with no action \n"); /* add */
          mm.workspace.append("  (missing ',' or misplaced ';' ?) \n"); /* add */
          System.out.print(mm.workspace); /* print */
          break script;
        }
        if (mm.workspace.toString().equals("action*action*") || mm.workspace.toString().equals("action*command*") || mm.workspace.toString().equals("action*number*") || mm.workspace.toString().equals("action*pattern*") || mm.workspace.toString().equals("action*range*") || mm.workspace.toString().equals("action*{*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("Sed error (line "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(", chars "); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.workspace.append("):\n"); /* add */
          mm.workspace.append("  Missing ';' after command?\n"); /* add */
          System.out.print(mm.workspace); /* print */
          break script;
        }
        if (mm.workspace.toString().equals(",*}*") || mm.workspace.toString().equals(",*{*") || mm.workspace.toString().equals(",*;*") || mm.workspace.toString().equals(",*,*") || mm.workspace.toString().equals(";*,*") || mm.workspace.toString().equals(";*{*") || mm.workspace.toString().equals("range*,*")) {
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clop */
            mm.workspace.delete(0, 1); }   /* clop */
          if (mm.workspace.length() > 0) { /* clop */
            mm.workspace.delete(0, 1); }   /* clop */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("Sed error (line "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(", chars "); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.workspace.append("):\n"); /* add */
          mm.workspace.append("  Unexpected character '"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("' \n"); /* add */
          System.out.print(mm.workspace); /* print */
          break script;
        }
        //---------------
        // 2 token reductions
        // ignore empty commands (and multiple \n)
        if (mm.workspace.toString().equals("command*;*") || mm.workspace.toString().equals("commandset*;*") || mm.workspace.toString().equals(";*;*")) {
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("action*;*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("command*"); /* add */
          mm.push();
          continue parse;
        }
        // maybe need a new token type for clarity here 
        // eg: negated selector
        if (mm.workspace.toString().equals("number*!*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("number*"); /* add */
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("pattern*!*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("pattern*"); /* add */
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("command*command*") || mm.workspace.toString().equals("commandset*command*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append("\n"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("commandset*"); /* add */
          mm.push();
          continue parse;
        }
        mm.pop();
        //---------------
        // 3 token errors
        // eg: '/a/,/bb/p;' or '/[0-3]/,20p;' etc
        //---------------
        // 3 token reductions
        // commands dont need a ';' before a closing brace in gnu sed
        // so transmogrify
        if (mm.workspace.toString().equals("command*command*}*") || mm.workspace.toString().equals("command*action*}*") || mm.workspace.toString().equals("commandset*action*}*") || mm.workspace.toString().equals("commandset*command*}*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append("\n"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("commandset*}*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("range*action*}*") || mm.workspace.toString().equals("number*action*}*") || mm.workspace.toString().equals("pattern*action*}*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("{\n  "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n}"); /* add */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("command*}*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("{*action*}*")) {
          // make commandset not command for grammar simplicity
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("{*commandset*}*"); /* add */
          mm.push();
          mm.push();
          mm.push();
          continue parse;
        }
        // a single command in braces can be just treated like a 
        // set of commands in braces, so lets change to make other
        // grammar rules simpler
        if (mm.workspace.toString().equals("{*command*}*")) {
          // make commandset not command for grammar simplicity
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("{*commandset*}*"); /* add */
          mm.push();
          mm.push();
          mm.push();
          continue parse;
        }
        mm.pop();
        //---------------
        // 4 token errors
        //---------------
        // 4 token reductions
        if (mm.workspace.toString().equals("pattern*{*commandset*}*") || mm.workspace.toString().equals("number*{*commandset*}*")) {
          // indent brace commands in tapecell+2
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.swap();
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\n", "\n  ");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          // indent 1st line using { token as temporary storage
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("  "); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.swap();
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.workspace.toString().equals("pattern*{*commandset*}*")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if (this.line.toString().matches("); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(")) {\n"); /* add */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append("\n}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
          }
          if (mm.workspace.toString().equals("number*{*commandset*}*")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("if (this.linesRead == "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(") {\n"); /* add */
            mm.increment();                 /* ++ */
            mm.increment();                 /* ++ */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.append("\n}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
          }
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("command*"); /* add */
          mm.push();
          continue parse;
        }
        mm.pop();
        mm.pop();
        // ----------------
        // 6 token reductions
        // none because we have to do them first.
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        if (mm.eof) {
          // check for valid sed script
          mm.workspace.append("/* The token parse-stack was: "); /* add */
          System.out.print(mm.workspace); /* print */
          mm.workspace.setLength(0);            /* clear */
          while (mm.pop());          /* unstack */
          mm.workspace.append(" */\n"); /* add */
          System.out.print(mm.workspace); /* print */
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (!mm.workspace.toString().equals("commandset*") && !mm.workspace.toString().equals("command*")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("# [error] Sed syntax error? \n"); /* add */
            mm.workspace.append("# ----------------- \n"); /* add */
            mm.workspace.append("# Also, uncomment lines after parse> label in script\n"); /* add */
            mm.workspace.append("# to see how the sed script is being parsed. \n"); /* add */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          if (mm.workspace.toString().equals("commandset*") || mm.workspace.toString().equals("command*")) {
            mm.workspace.setLength(0);            /* clear */
            // indent the generated code
            mm.workspace.append("\n"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("\n", "\n       ");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            // create the java preamble, with a 'sedmachine' having a 
            // holdspace and patternspace
            mm.workspace.append(""); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n /* [ok] Sed syntax appears ok */"); 
            mm.workspace.append("\n /* ---------------------      */"); 
            mm.workspace.append("\n /* Java code generated by \"sed.tojava.pss\" */"); 
            mm.workspace.append("\n import java.io.*;"); 
            mm.workspace.append("\n import java.nio.file.*;"); 
            mm.workspace.append("\n import java.nio.charset.*;"); 
            mm.workspace.append("\n import java.util.regex.*;"); 
            mm.workspace.append("\n import java.util.*;   // contains stack"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n public class javased {"); 
            mm.workspace.append("\n   public StringBuffer patternSpace;"); 
            mm.workspace.append("\n   public StringBuffer holdSpace;"); 
            mm.workspace.append("\n   public StringBuffer line;         /* current line unmodified */"); 
            mm.workspace.append("\n   public int linesRead;"); 
            mm.workspace.append("\n   private boolean[] states;         /* pattern-seen state */"); 
            mm.workspace.append("\n   private Scanner input;            /* what script will read */"); 
            mm.workspace.append("\n   public Writer output;             /* where script will send output */"); 
            mm.workspace.append("\n   private boolean eof;              /* end of file reached? */"); 
            mm.workspace.append("\n   private boolean hasSubstituted;   /* a sub on this cycle? */"); 
            mm.workspace.append("\n   private boolean lastLine;         /* last line of input (for $) */"); 
            mm.workspace.append("\n   private boolean readNext;         /* read next line or not */"); 
            mm.workspace.append("\n   private boolean autoPrint;        /* autoprint pattern space? */"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** convenience: read stdin, write to stdout */"); 
            mm.workspace.append("\n   public javased() {"); 
            mm.workspace.append("\n     this("); 
            mm.workspace.append("\n       new Scanner(System.in), "); 
            mm.workspace.append("\n       new BufferedWriter(new OutputStreamWriter(System.out)));"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** convenience: read and write to strings */"); 
            mm.workspace.append("\n   public javased(String in, StringWriter out) {"); 
            mm.workspace.append("\n     this(new Scanner(in), out);"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** make a new machine with a character stream reader */"); 
            mm.workspace.append("\n   public javased(Scanner scanner, Writer writer) {"); 
            mm.workspace.append("\n     this.patternSpace = new StringBuffer(\"\"); "); 
            mm.workspace.append("\n     this.holdSpace = new StringBuffer(\"\"); "); 
            mm.workspace.append("\n     this.line = new StringBuffer(\"\"); "); 
            mm.workspace.append("\n     this.linesRead = 0;"); 
            mm.workspace.append("\n     this.input = scanner;"); 
            mm.workspace.append("\n     this.output = writer;"); 
            mm.workspace.append("\n     this.eof = false;"); 
            mm.workspace.append("\n     this.hasSubstituted = false;"); 
            mm.workspace.append("\n     this.readNext = true;"); 
            mm.workspace.append("\n     this.autoPrint = true;"); 
            mm.workspace.append("\n     // assume that a sed script has no more than 1K range tests! */"); 
            mm.workspace.append("\n     this.states = new boolean[1000];"); 
            mm.workspace.append("\n     for (int ii = 0; ii < 1000; ii++) { this.states[ii] = false; }"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** read one line from the input stream and update the machine. */"); 
            mm.workspace.append("\n   public void readLine() {"); 
            mm.workspace.append("\n     int iChar;"); 
            mm.workspace.append("\n     if (this.eof) { System.exit(0); }"); 
            mm.workspace.append("\n     // increment lines"); 
            mm.workspace.append("\n     this.linesRead++;"); 
            mm.workspace.append("\n     if (this.input.hasNext()) {"); 
            mm.workspace.append("\n       this.line.setLength(0);"); 
            mm.workspace.append("\n       this.line.append(this.input.nextLine());"); 
            mm.workspace.append("\n       this.patternSpace.append(this.line);"); 
            mm.workspace.append("\n     } "); 
            mm.workspace.append("\n     if (!this.input.hasNext()) { this.eof = true; }"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** command \"x\": swap the pattern-space with the hold-space */"); 
            mm.workspace.append("\n   public void swap() {"); 
            mm.workspace.append("\n     String s = new String(this.patternSpace);"); 
            mm.workspace.append("\n     this.patternSpace.setLength(0);"); 
            mm.workspace.append("\n     this.patternSpace.append(this.holdSpace.toString());"); 
            mm.workspace.append("\n     this.holdSpace.setLength(0);"); 
            mm.workspace.append("\n     this.holdSpace.append(s);"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** command \"y/abc/xyz/\": transliterate */"); 
            mm.workspace.append("\n   public void transliterate(String target, String replacement) {"); 
            mm.workspace.append("\n     // javacode for translit"); 
            mm.workspace.append("\n     //String target      = \"ab\";"); 
            mm.workspace.append("\n     //String replacement = \"**\";"); 
            mm.workspace.append("\n     //char[] array = \"abcde\".toString().toCharArray();"); 
            mm.workspace.append("\n     int ii = 0;"); 
            mm.workspace.append("\n     char[] array = this.patternSpace.toString().toCharArray();"); 
            mm.workspace.append("\n     for (ii = 0; ii < array.length; ii++) {"); 
            mm.workspace.append("\n       int index = target.indexOf(array[ii]);"); 
            mm.workspace.append("\n       if (index != -1) {"); 
            mm.workspace.append("\n         array[ii] = replacement.charAt(index);"); 
            mm.workspace.append("\n       }"); 
            mm.workspace.append("\n     }"); 
            mm.workspace.append("\n     this.patternSpace.setLength(0);"); 
            mm.workspace.append("\n     this.patternSpace.append(array);"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** command \"s///x\": make substitutions on the pattern-space */"); 
            mm.workspace.append("\n   public void substitute("); 
            mm.workspace.append("\n     String first, String second, String flags, String writeText) {"); 
            mm.workspace.append("\n     // flags can be gip etc"); 
            mm.workspace.append("\n     // gnu sed modifiers M,<num>,e,w filename "); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     Process p;"); 
            mm.workspace.append("\n     BufferedReader stdin;"); 
            mm.workspace.append("\n     BufferedReader stderr;"); 
            mm.workspace.append("\n     String ss = null;"); 
            mm.workspace.append("\n     String temp = new String(\"\");"); 
            mm.workspace.append("\n     String old = new String(this.patternSpace);"); 
            mm.workspace.append("\n     String opsys = System.getProperty(\"os.name\").toLowerCase();"); 
            mm.workspace.append("\n "); 
            mm.workspace.append("\n     // here replace \1 \2 etc (gnu replace group syntax) with"); 
            mm.workspace.append("\n     // $1 $2 etc (java syntax)"); 
            mm.workspace.append("\n     //second = second.replaceAll(\"\\\\\\\\([0-9])\",\"X$1\");"); 
            mm.workspace.append("\n     //System.out.println(\"sec = \" + second);"); 
            mm.workspace.append("\n     // also \(\) gnu group syntax becomes () java group syntax"); 
            mm.workspace.append("\n     // but this is already dealt with, in the parser"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     // case insensitive: add \"(?i)\" at beginning"); 
            mm.workspace.append("\n     if ((flags.indexOf(\'i\') > -1) ||"); 
            mm.workspace.append("\n         (flags.indexOf(\'I\') > -1)) { first = \"(?i)\" + first; }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     // multiline matching, check!!"); 
            mm.workspace.append("\n     if ((flags.indexOf(\'m\') > -1) ||"); 
            mm.workspace.append("\n         (flags.indexOf(\'M\') > -1)) { first = \"(?m)\" + first; }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     // <num>- replace only nth match"); 
            mm.workspace.append("\n     // todo"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     // gnu sed considers a substitute has taken place even if the "); 
            mm.workspace.append("\n     // pattern space is unchanged! i.e. if matches first pattern."); 
            mm.workspace.append("\n     if (this.patternSpace.toString().matches(\".*\" + first + \".*\")) {"); 
            mm.workspace.append("\n       this.hasSubstituted = true;"); 
            mm.workspace.append("\n     }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     // syntax \"s/a/A/3;\" replace nth (3rd) occurence of match "); 
            mm.workspace.append("\n     if (flags.matches(\".*[0-9]+.*\")) {"); 
            mm.workspace.append("\n       String[] parts = flags.replaceAll(\"[^0-9]+\", \" \").trim().split(\" \");"); 
            mm.workspace.append("\n       int nn = Integer.parseInt(parts[0]);"); 
            mm.workspace.append("\n       //System.out.println(\"nn=\" + nn);"); 
            mm.workspace.append("\n       int ii = 0;"); 
            mm.workspace.append("\n       int index = -1;"); 
            mm.workspace.append("\n       Pattern pp = Pattern.compile(first);"); 
            mm.workspace.append("\n       Matcher m = pp.matcher(this.patternSpace.toString());"); 
            mm.workspace.append("\n       temp = this.patternSpace.toString();"); 
            mm.workspace.append("\n       while(m.find()) {"); 
            mm.workspace.append("\n         ii++;"); 
            mm.workspace.append("\n         //System.out.println(\"ii=\" + ii);"); 
            mm.workspace.append("\n         if (ii >= nn) {"); 
            mm.workspace.append("\n           index = m.start();"); 
            mm.workspace.append("\n           temp = this.patternSpace.toString();"); 
            mm.workspace.append("\n           this.patternSpace.setLength(0);"); 
            mm.workspace.append("\n           this.patternSpace.append(temp.substring(0,index));"); 
            mm.workspace.append("\n           this.patternSpace.append("); 
            mm.workspace.append("\n             temp.substring(index).replaceFirst(first, second));"); 
            mm.workspace.append("\n           temp = this.patternSpace.toString();"); 
            mm.workspace.append("\n           // trying to match gnu sed behavior where the \"g\" and \"nth\""); 
            mm.workspace.append("\n           // occurence are combined (i.e. replace all matches from "); 
            mm.workspace.append("\n           // the nth occurence."); 
            mm.workspace.append("\n           if (flags.indexOf(\'g\') == -1) { break; }"); 
            mm.workspace.append("\n         }"); 
            mm.workspace.append("\n       }"); 
            mm.workspace.append("\n     } else if (flags.indexOf(\'g\') != -1) {"); 
            mm.workspace.append("\n       // sed syntax \"s/a/A/g;\" g- global, replace all matches"); 
            mm.workspace.append("\n       temp = this.patternSpace.toString().replaceAll(first, second);"); 
            mm.workspace.append("\n     } else {"); 
            mm.workspace.append("\n       // sed syntax \"s/a/A/;\" replace only 1st match"); 
            mm.workspace.append("\n       temp = this.patternSpace.toString().replaceFirst(first, second);"); 
            mm.workspace.append("\n     }"); 
            mm.workspace.append("\n     this.patternSpace.setLength(0);"); 
            mm.workspace.append("\n     this.patternSpace.append(temp);"); 
            mm.workspace.append("\n     try {"); 
            mm.workspace.append("\n       if  (this.hasSubstituted) {"); 
            mm.workspace.append("\n         // only print if substitution made, (but pattern-space may be"); 
            mm.workspace.append("\n         // unchanged, according to gnu sed)."); 
            mm.workspace.append("\n         if (flags.indexOf(\'p\') != -1) {"); 
            mm.workspace.append("\n           this.output.write(this.patternSpace.toString()+\'\\n\');"); 
            mm.workspace.append("\n         }"); 
            mm.workspace.append("\n         // execute pattern space, gnu ext"); 
            mm.workspace.append("\n         if (flags.indexOf(\'e\') != -1) {"); 
            mm.workspace.append("\n           this.output.write(this.execute(this.patternSpace.toString()));"); 
            mm.workspace.append("\n           //System.out.print(this.execute(this.patternSpace.toString()));"); 
            mm.workspace.append("\n         }"); 
            mm.workspace.append("\n         // write pattern space to file, gnu extension, if sub occurred"); 
            mm.workspace.append("\n         // The writeText parameter contains \'w\' switch plus possible "); 
            mm.workspace.append("\n         // whitespace."); 
            mm.workspace.append("\n         if (writeText.length() > 0) {"); 
            mm.workspace.append("\n           writeText = writeText.substring(1).trim();"); 
            mm.workspace.append("\n           this.writeToFile(writeText);"); 
            mm.workspace.append("\n         }"); 
            mm.workspace.append("\n       }"); 
            mm.workspace.append("\n     } catch (IOException e) {"); 
            mm.workspace.append("\n       System.out.println(e.toString());"); 
            mm.workspace.append("\n     }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** execute command/pattspace for s///e or e <arg> or \"e\" */"); 
            mm.workspace.append("\n   public String execute(String command) {"); 
            mm.workspace.append("\n     Process p;"); 
            mm.workspace.append("\n     BufferedReader stdin;"); 
            mm.workspace.append("\n     BufferedReader stderr;"); 
            mm.workspace.append("\n     String ss;"); 
            mm.workspace.append("\n     StringBuffer output = new StringBuffer(\"\");"); 
            mm.workspace.append("\n     try {"); 
            mm.workspace.append("\n       if (System.getProperty(\"os.name\").toLowerCase().contains(\"win\")) {"); 
            mm.workspace.append("\n         p = Runtime.getRuntime().exec(new String[]{\"cmd.exe\", \"/c\", command});"); 
            mm.workspace.append("\n       } else {"); 
            mm.workspace.append("\n         p = Runtime.getRuntime().exec(new String[]{\"bash\", \"-c\", command});"); 
            mm.workspace.append("\n       }"); 
            mm.workspace.append("\n       stdin = new BufferedReader(new InputStreamReader(p.getInputStream()));"); 
            mm.workspace.append("\n       stderr = new BufferedReader(new InputStreamReader(p.getErrorStream()));"); 
            mm.workspace.append("\n       while ((ss = stdin.readLine()) != null) { output.append(ss + \'\\n\'); }  "); 
            mm.workspace.append("\n       while ((ss = stderr.readLine()) != null) { output.append(ss + \'\\n\'); } "); 
            mm.workspace.append("\n     } catch (IOException e) {"); 
            mm.workspace.append("\n       System.out.println(\"sed exec \'e\' failed: \" + e);"); 
            mm.workspace.append("\n     }"); 
            mm.workspace.append("\n     return output.toString();"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** command \"W\": save 1st line of patternspace to filename */"); 
            mm.workspace.append("\n   public void writeFirstToFile(String fileName) {"); 
            mm.workspace.append("\n     try {"); 
            mm.workspace.append("\n       File file = new File(fileName);"); 
            mm.workspace.append("\n       Writer out = new BufferedWriter(new OutputStreamWriter("); 
            mm.workspace.append("\n          new FileOutputStream(file), \"UTF8\"));"); 
            mm.workspace.append("\n       // get first line of ps"); 
            mm.workspace.append("\n       out.append(this.patternSpace.toString().split(\"\\\\R\",2)[0]);"); 
            mm.workspace.append("\n       // yourString.split(\"\\R\", 2);"); 
            mm.workspace.append("\n       out.flush(); out.close();"); 
            mm.workspace.append("\n     } catch (Exception e) {"); 
            mm.workspace.append("\n       System.out.println(e.getMessage());"); 
            mm.workspace.append("\n     }"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** command \"w\": save the patternspace to filename */"); 
            mm.workspace.append("\n   public void writeToFile(String fileName) {"); 
            mm.workspace.append("\n     try {"); 
            mm.workspace.append("\n       File file = new File(fileName);"); 
            mm.workspace.append("\n       Writer out = new BufferedWriter(new OutputStreamWriter("); 
            mm.workspace.append("\n          new FileOutputStream(file), \"UTF8\"));"); 
            mm.workspace.append("\n       out.append(this.patternSpace.toString());"); 
            mm.workspace.append("\n       out.flush(); out.close();"); 
            mm.workspace.append("\n     } catch (Exception e) {"); 
            mm.workspace.append("\n       System.out.println(e.getMessage());"); 
            mm.workspace.append("\n     }"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** handle an unsupported command (message + abort) */"); 
            mm.workspace.append("\n   public void unsupported(String name) {"); 
            mm.workspace.append("\n     String ss ="); 
            mm.workspace.append("\n      \"The \" + name + \"command has not yet been implemented\\n\" +"); 
            mm.workspace.append("\n      \"in this sed-to-java translator. Branching commands are hard in\\n\" +"); 
            mm.workspace.append("\n      \"in a language that doesn\'t have \'goto\'. Your script will not \\n\" + "); 
            mm.workspace.append("\n      \"execute properly. Exiting now... \\n\";"); 
            mm.workspace.append("\n      System.out.println(ss); System.exit(0);"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /** run the script with reader and writer. This allows the code to"); 
            mm.workspace.append("\n       be used from within another java program, and not just as a "); 
            mm.workspace.append("\n       stream filter. */"); 
            mm.workspace.append("\n   public void run() throws IOException {"); 
            mm.workspace.append("\n     String temp = \"\";    "); 
            mm.workspace.append("\n     while (!this.eof) {"); 
            mm.workspace.append("\n       this.hasSubstituted = false;"); 
            mm.workspace.append("\n       this.patternSpace.setLength(0);"); 
            mm.workspace.append("\n       // some sed commands restart without reading a line..."); 
            mm.workspace.append("\n       // hence the use of a flag."); 
            mm.workspace.append("\n       if (this.readNext) { this.readLine(); }"); 
            mm.workspace.append("\n       this.readNext = true;"); 
            mm.workspace.append("\n"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append(""); 
            mm.workspace.append("\n       if (this.autoPrint) { "); 
            mm.workspace.append("\n         this.output.write(this.patternSpace.toString() + \'\\n\');"); 
            mm.workspace.append("\n         this.output.flush();"); 
            mm.workspace.append("\n       }"); 
            mm.workspace.append("\n     } "); 
            mm.workspace.append("\n   } "); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n   /* run the script as a stream filter. remove this main method"); 
            mm.workspace.append("\n      to embed the script in another java program */"); 
            mm.workspace.append("\n   public static void main(String[] args) throws Exception { "); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     // read and write to stdin/stdout"); 
            mm.workspace.append("\n     javased mm = new javased();"); 
            mm.workspace.append("\n     // new Scanner(System.in), "); 
            mm.workspace.append("\n     // new BufferedWriter(new OutputStreamWriter(System.out)));"); 
            mm.workspace.append("\n     mm.run();"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n     // convert sedstring to java and write to string."); 
            mm.workspace.append("\n     // javased mm = new javased(\"/class/s/ass/ASS/g\", new StringWriter());"); 
            mm.workspace.append("\n     // then use mm.output.toString() to get the result (java source code)"); 
            mm.workspace.append("\n   }"); 
            mm.workspace.append("\n }"); 
            mm.workspace.append("\n"); /* add */
            System.out.print(mm.workspace); /* print */
          }
          break script;
        }
        break parse;
      }
    }
  }
}
