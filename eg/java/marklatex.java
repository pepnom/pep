

 /* Java code generated by "translate.java.pss" */
 import java.io.*;
 import java.util.regex.*;
 import java.util.*;   // contains stack

 public class marklatex {
   // using int instead of char so that all unicode code points are
   // available instead of just utf16. (emojis cant fit into utf16)
   private int accumulator;         // counter for anything
   private int peep;                // next char in input stream
   private int charsRead;           // No. of chars read so far
   private int linesRead;           // No. of lines read so far
   public StringBuffer workspace;    // text accumulator
   private Stack<String> stack;      // parse token stack
   private int LENGTH;               // tape initial length

   // use ArrayLists instead with .add() .get(n) and .set(n, E)
   // ArrayList<StringBuffer> al=new ArrayList<StringBuffer>();
   private List<StringBuffer> tape;      // array of token attributes 
   private List<StringBuffer> marks;     // tape marks
   private int tapePointer;          // pointer to current cell
   private Reader input;             // text input stream
   private boolean eof;              // end of stream reached?
   private boolean flag;             // not used here
   private StringBuffer escape;    // char used to "escape" others "\"
   private StringBuffer delimiter; // push/pop delimiter (default is "*")
   private boolean markFound;      // if the mark was found in tape
   
   /** make a new machine with a character stream reader */
   public marklatex(Reader reader) {
     this.markFound = false; 
     this.LENGTH = 100;
     this.input = reader;
     this.eof = false;
     this.flag = false;
     this.charsRead = 0; 
     this.linesRead = 1; 
     this.escape = new StringBuffer("\\");
     this.delimiter = new StringBuffer("*");
     this.accumulator = 0;
     this.workspace = new StringBuffer("");
     this.stack = new Stack<String>();
     this.tapePointer = 0;
     this.tape = new ArrayList<StringBuffer>();
     this.marks = new ArrayList<StringBuffer>();
     for (int ii = 0; ii < this.LENGTH; ii++) {
       this.tape.add(new StringBuffer(""));
       this.marks.add(new StringBuffer(""));
     }

     try
     { this.peep = this.input.read(); } 
     catch (java.io.IOException ex) {
       System.out.println("read error");
       System.exit(-1);
     }
   }

   /** read one character from the input stream and 
       update the machine. */
   public void read() {
     int iChar;
     try {
       if (this.eof) { System.exit(0); }
       this.charsRead++;
       // increment lines
       if ((char)this.peep == '\n') { this.linesRead++; }
       this.workspace.append(Character.toChars(this.peep));
       this.peep = this.input.read(); 
       if (this.peep == -1) { this.eof = true; }
     }
     catch (IOException ex) {
       System.out.println("Error reading input stream" + ex);
       System.exit(-1);
     }
   }

   /** increment tape pointer by one */
   public void increment() {
     this.tapePointer++;
     if (this.tapePointer >= this.LENGTH) {
       this.tape.add(new StringBuffer(""));
       this.marks.add(new StringBuffer(""));
       this.LENGTH++;
     }
   }
   
   /** remove escape character  */
   public void unescapeChar(char c) {
     if (workspace.length() > 0) {
       String s = this.workspace.toString().replace("\\"+c, c+"");
       this.workspace.setLength(0); workspace.append(s);
     }
   }

   /** add escape character  */
   public void escapeChar(char c) {
     if (workspace.length() > 0) {
       String s = this.workspace.toString().replace(c+"", "\\"+c);
       workspace.setLength(0); workspace.append(s);
     }
   }

   /** whether trailing escapes \\ are even or odd */
   // untested code. check! eg try: add "x \\"; print; etc
   public boolean isEscaped(String ss, String sSuffix) {
     int count = 0; 
     if (ss.length() < 2) return false;
     if (ss.length() <= sSuffix.length()) return false;
     if (ss.indexOf(this.escape.toString().charAt(0)) == -1) 
       { return false; }

     int pos = ss.length()-sSuffix.length();
     while ((pos > -1) && (ss.charAt(pos) == this.escape.toString().charAt(0))) {
       count++; pos--;
     }
     if (count % 2 == 0) return false;
     return true;
   }

   /* a helper to see how many trailing \\ escape chars */
   private int countEscaped(String sSuffix) {
     String s = "";
     int count = 0;
     int index = this.workspace.toString().lastIndexOf(sSuffix);
     // remove suffix if it exists
     if (index > 0) {
       s = this.workspace.toString().substring(0, index);
     }
     while (s.endsWith(this.escape.toString())) {
       count++;
       s = s.substring(0, s.lastIndexOf(this.escape.toString()));
     }
     return count;
   }

   /** reads the input stream until the workspace end with text */
   // can test this with
   public void until(String sSuffix) {
     // read at least one character
     if (this.eof) return; 
     this.read();
     while (true) {
       if (this.eof) return;
       if (this.workspace.toString().endsWith(sSuffix)) {
         if (this.countEscaped(sSuffix) % 2 == 0) { return; }
       }
       this.read();
     }
   }

   /** pop the first token from the stack into the workspace */
   public Boolean pop() {
     if (this.stack.isEmpty()) return false;
     this.workspace.insert(0, this.stack.pop());     
     if (this.tapePointer > 0) this.tapePointer--;
     return true;
   }

   /** push the first token from the workspace to the stack */
   public Boolean push() {
     String sItem;
     // dont increment the tape pointer on an empty push
     if (this.workspace.length() == 0) return false;
     // need to get this from this.delim not "*"
     int iFirstStar = 
       this.workspace.indexOf(this.delimiter.toString());
     if (iFirstStar != -1) {
       sItem = this.workspace.toString().substring(0, iFirstStar + 1);
       this.workspace.delete(0, iFirstStar + 1);
     }
     else {
       sItem = this.workspace.toString();
       this.workspace.setLength(0);
     }
     this.stack.push(sItem);     
     this.increment(); 
     return true;
   }

   /** swap current tape cell with the workspace */
   public void swap() {
     String s = new String(this.workspace);
     this.workspace.setLength(0);
     this.workspace.append(this.tape.get(this.tapePointer).toString());
     this.tape.get(this.tapePointer).setLength(0);
     this.tape.get(this.tapePointer).append(s);
   }

   /** save the workspace to file "sav.pp" */
   public void writeToFile() {
     try {
       File file = new File("sav.pp");
       Writer out = new BufferedWriter(new OutputStreamWriter(
          new FileOutputStream(file), "UTF8"));
       out.append(this.workspace.toString());
       out.flush(); out.close();
     } catch (Exception e) { 
       System.out.println(e.getMessage());
     }
   }

   public void goToMark(String mark) {
     this.markFound = false; 
     for (var ii = 0; ii < this.marks.size(); ii++) {
       if (this.marks.get(ii).toString().equals(mark)) { 
         this.tapePointer = ii; this.markFound = true; 
       }
     }
     if (this.markFound == false) { 
       System.out.print("badmark '" + mark + "'!"); 
       System.exit(1);
     }
   }

   /** parse/check/compile the input */
   public void parse(InputStreamReader input) {
     //this is where the actual parsing/compiling code should go 
     //but this means that all generated code must use
     //"this." not "mm."
   }

  public static void main(String[] args) throws Exception { 
    String temp = "";    
    marklatex mm = new marklatex(new InputStreamReader(System.in)); 
    // create a dummy newline so that doc structures work even
    // on the first line of the file/stream.
    mm.workspace.append("nl*"); /* add */
    mm.push();
    script: 
    while (!mm.eof) {
      lex: { 
        mm.read(); /* read */
        if (!mm.workspace.toString().matches("^\\p{Space}+$")) {
          // count words per line with the accumulator
          mm.accumulator++; /* a+ */
          /* whilenot */ 
          while (!Character.toString((char)mm.peep).matches("^\\p{Space}+$")) { if (mm.eof) { break; } mm.read(); }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("word*"); /* add */
          mm.push();
          break lex;
        }
        // keep leading space in newline token?
        if (mm.workspace.toString().matches("^[\n]+$")) {
          // set accumulator == 0 so that we can count words 
          // per line (and know which is the first word)
          mm.accumulator = 0; /* zero */
          mm.charsRead = 0; /* nochars */
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[ ]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("nl*"); /* add */
          mm.push();
          break lex;
        }
        if (mm.workspace.toString().matches("^[\r\t ]+$")) {
          mm.workspace.setLength(0);            /* clear */
          if (!mm.eof) {
            continue script;
          }
        }
      }
      parse: 
      while (true) { 
        // for debugging, add % as a latex comment.
        mm.workspace.append("%%> line "); /* add */
        mm.workspace.append(mm.linesRead); /* lines */
        mm.workspace.append(" char "); /* add */
        mm.workspace.append(mm.charsRead); /* chars */
        mm.workspace.append(": "); /* add */
        System.out.print(mm.workspace); /* print */
        mm.workspace.setLength(0);            /* clear */
        while (mm.pop());          /* unstack */
        System.out.print(mm.workspace); /* print */
        while(mm.push());          /* stack */
        mm.workspace.append("\n"); /* add */
        System.out.print(mm.workspace); /* print */
        mm.workspace.setLength(0);            /* clear */
        // -------------
        // 1 token
        mm.pop();
        if (mm.workspace.toString().equals("nl*")) {
          /* nop: no-operation eliminated */
        }
        // here we classify words into other tokens
        // we can use accumulator with a+ a- to determine if current
        // word is the first word of the line, or even count number of 
        // words per line. This should simplify grammar items such as
        // nl/---  and nl/star/ etc
        // another advantage, is that we can dispense with tokens such as 
        // ---, >> etc and not have to get rid of them later.
        if (mm.workspace.toString().equals("word*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          // no numbers in headings!
          if (mm.workspace.toString().matches("^[A-Z]+$")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("uuword*"); /* add */
            mm.push();
            continue parse;
          }
          // at least three --- on a newline marks a code block start
          // use 'count;' here to simplify. The token --- probably doesnt
          // need to exist.
          if (mm.workspace.toString().startsWith("---") && mm.workspace.toString().matches("^[\\-]+$")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("---*"); /* add */
            mm.push();
            continue parse;
          }
          // >> on a newline marks a code line start
          if (mm.workspace.toString().equals(">>")) {
            mm.workspace.append("*"); /* add */
            mm.push();
            continue parse;
          }
          // subheading marker
          if (mm.workspace.toString().startsWith("....") && mm.workspace.toString().matches("^[.]+$")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("4dots*"); /* add */
            mm.push();
            continue parse;
          }
          // dash is used for lists 
          // only make a dash token if it is first word on the line
          if (mm.workspace.toString().equals("-")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.accumulator); /* count */
            if (mm.workspace.toString().equals("1")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("dash*"); /* add */
              mm.push();
              continue parse;
            }
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          // ordered list start token 
          // only make token if it is first word on the line
          if (mm.workspace.toString().equals("o/-") || mm.workspace.toString().equals("O/-") || mm.workspace.toString().equals("0/-")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.accumulator); /* count */
            if (mm.workspace.toString().equals("1")) {
              mm.workspace.setLength(0);            /* clear */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.append("olist*"); /* add */
              mm.push();
              continue parse;
            }
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          // unordered list start token 
          if (mm.workspace.toString().equals("u/-") || mm.workspace.toString().equals("U/-")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.accumulator); /* count */
            if (mm.workspace.toString().equals("1")) {
              mm.workspace.setLength(0);            /* clear */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.append("ulist*"); /* add */
              mm.push();
              continue parse;
            }
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          // definition/description list start token 
          // need to parse a bit differently because of the desc
          if (mm.workspace.toString().equals("d/-") || mm.workspace.toString().equals("D/-")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.accumulator); /* count */
            if (mm.workspace.toString().equals("1")) {
              mm.workspace.setLength(0);            /* clear */
              // read description here, but have to escape special
              // verb cant go in here. Special chars will crash this. 
              mm.workspace.append("\n \\item["); /* add */
              /* whilenot */ 
              while (!Character.toString((char)mm.peep).matches("^[\n:]+$")) { if (mm.eof) { break; } mm.read(); }
              mm.workspace.append("]"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("dlist*"); /* add */
              mm.push();
              continue parse;
            }
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          // star on newline marks emphasis, list or code description 
          // probably dont need star token.
          if (mm.workspace.toString().equals("*")) {
            // check that * is 1st 'word' on line using accumulator
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.accumulator); /* count */
            if (!mm.workspace.toString().equals("1")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("*"); /* add */
            }
            if (mm.workspace.toString().equals("1")) {
              mm.workspace.setLength(0);            /* clear */
              /* while */ 
              while (Character.toString((char)mm.peep).matches("^[ \t\f]+$")) { if (mm.eof) { break; } mm.read(); }
              mm.workspace.setLength(0);            /* clear */
              /* whilenot */ 
              while (!Character.toString((char)mm.peep).matches("^[\n]+$")) { if (mm.eof) { break; } mm.read(); }
              /* cap */ 
              for (int i = 0; i < mm.workspace.length(); i++) { 
                char c = mm.workspace.charAt(i); 
                if (i==0){ mm.workspace.setCharAt(i, Character.toUpperCase(c)); } 
                else { mm.workspace.setCharAt(i, Character.toLowerCase(c)); } 
              }
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              // this is a trick, because we want special LaTeX chars to
              // be escaped. So, will add \\emph{} after next replace code. 
              mm.workspace.append("::EMPH::"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              //add "emline*"; push; .reparse
            }
          }
          // need to escape % # } \ and others
          // & % $ # _ { } ~ ^ \   
          // \textasciitilde, \textasciicircum, and \textbackslash
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\\", "\\textbackslash ");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("&", "\\&");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("%", "\\%");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("$", "\\$");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("#", "\\#");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("_", "\\_");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("{", "\\{");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("}", "\\}");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("~", "\\textasciitilde");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("^", "\\textasciicircum");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace(">", "\\textgreater ");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("<", "\\textless ");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("LaTeX", "\\LaTeX{}");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          // now make the emphasis line token, after special chars have 
          // been escaped.
          if (mm.workspace.toString().startsWith("::EMPH::")) {
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("::EMPH::", " \\emph{");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            mm.workspace.append("}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("emline*"); /* add */
            mm.push();
            continue parse;
          }
          // If a previous test has matched, then the workspace should
          // be clear, and so none of the following will match.
          // graphical key representations
          if (mm.workspace.toString().startsWith("[") && mm.workspace.toString().endsWith("]")) {
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("[esc]", "\\Esc");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("[enter]", "\\Enter");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("[return]", "\\Enter");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("[insert]", "\\Ins");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("[shift]", "\\Shift");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("[delete]", "\\Del");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("[home]", "\\Home");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            // keys defined by 'keystroke' package, can make new ones.
            // \Enter \Del  \Ins    \Esc   \Shift  \Ctrl  \Home
            // \End   \PgUp \PgDown \PrtSc \Scroll \Break
          }
          //replace '\\n' "\\textbackslash n";
          //replace '\\f' "\\textbackslash f";
          //replace '\\r' "\\textbackslash r";
          //replace '\\t' "\\textbackslash t";
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          // urls, not so important for LaTex (and pdf) output.
          // Dont really need a token because we can render immediately
          // Could maybe render them as footnotes
          if (mm.workspace.toString().startsWith("http://") || mm.workspace.toString().startsWith("https://") || mm.workspace.toString().startsWith("www.") || mm.workspace.toString().startsWith("ftp://") || mm.workspace.toString().startsWith("sftp://")) {
            // clear; add "url*"; push; .reparse
            // render as fixed pitch font
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("\\url{"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          // format acronyms as a small capital font, case insensitive
          /* lower */ 
          for (int i = 0; i < mm.workspace.length(); i++) { 
            char c = mm.workspace.charAt(i); 
            mm.workspace.setCharAt(i, Character.toLowerCase(c)); } 
          if (mm.workspace.toString().equals("antlr") || mm.workspace.toString().equals("pdf") || mm.workspace.toString().equals("json") || mm.workspace.toString().equals("ebnf") || mm.workspace.toString().equals("bnf") || mm.workspace.toString().equals("dns") || mm.workspace.toString().equals("html")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("\\textsc{\\textbf{"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("}}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          // restore the mixed-case version of the input word
          if (!mm.workspace.toString().equals("")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          // filenames, could be elided with quoted filenames
          if (mm.workspace.toString().equals("parse>") || mm.workspace.toString().equals("print") || mm.workspace.toString().equals("pop") || mm.workspace.toString().equals("push") || mm.workspace.toString().equals("get") || mm.workspace.toString().equals("put") || mm.workspace.toString().equals(".reparse") || mm.workspace.toString().equals(".restart") || mm.workspace.toString().equals("add") || mm.workspace.toString().equals("sed") || mm.workspace.toString().equals("awk") || mm.workspace.toString().equals("grep") || mm.workspace.toString().equals("pep") || mm.workspace.toString().equals("nom") || mm.workspace.toString().equals("less") || mm.workspace.toString().equals("stdin") || mm.workspace.toString().equals("stdout") || mm.workspace.toString().equals("bash") || mm.workspace.toString().equals("lex") || mm.workspace.toString().equals("yacc") || mm.workspace.toString().equals("flex") || mm.workspace.toString().equals("bison") || mm.workspace.toString().equals("lalr") || mm.workspace.toString().equals("gnu") || mm.workspace.toString().endsWith(".h") || mm.workspace.toString().endsWith(".c") || mm.workspace.toString().endsWith(".a") || mm.workspace.toString().endsWith(".txt") || mm.workspace.toString().endsWith(".doc") || mm.workspace.toString().endsWith(".py") || mm.workspace.toString().endsWith(".rb") || mm.workspace.toString().endsWith(".rs") || mm.workspace.toString().endsWith(".java") || mm.workspace.toString().endsWith(".class") || mm.workspace.toString().endsWith(".tcl") || mm.workspace.toString().endsWith(".tk") || mm.workspace.toString().endsWith(".sw") || mm.workspace.toString().endsWith(".js") || mm.workspace.toString().endsWith(".go") || mm.workspace.toString().endsWith(".pp") || mm.workspace.toString().endsWith(".pss") || mm.workspace.toString().endsWith(".cpp") || mm.workspace.toString().endsWith(".pl") || mm.workspace.toString().endsWith(".html") || mm.workspace.toString().endsWith(".pdf") || mm.workspace.toString().endsWith(".tex") || mm.workspace.toString().endsWith(".sh") || mm.workspace.toString().endsWith(".css") || mm.workspace.toString().endsWith(".out") || mm.workspace.toString().endsWith(".log") || mm.workspace.toString().endsWith(".png") || mm.workspace.toString().endsWith(".jpg") || mm.workspace.toString().endsWith(".jpeg") || mm.workspace.toString().endsWith(".bmp") || mm.workspace.toString().endsWith(".mp3") || mm.workspace.toString().endsWith(".wav") || mm.workspace.toString().endsWith("aux") || mm.workspace.toString().endsWith(".tar") || mm.workspace.toString().endsWith(".gz") || mm.workspace.toString().endsWith("/")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("\\texttt{"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          // mark up language names
          if (mm.workspace.toString().equals("python") || mm.workspace.toString().equals("java") || mm.workspace.toString().equals("ruby") || mm.workspace.toString().equals("perl") || mm.workspace.toString().equals("tcl") || mm.workspace.toString().equals("rust") || mm.workspace.toString().equals("swift") || mm.workspace.toString().equals("markdown") || mm.workspace.toString().equals("c") || mm.workspace.toString().equals("c++")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("\\textit{\\texttt{"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("}}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          // paths and directories ? 
          if (mm.workspace.toString().startsWith("../") && !mm.workspace.toString().equals("../")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("\\texttt{"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          if (mm.workspace.toString().startsWith("\"") && mm.workspace.toString().endsWith("\"") && !mm.workspace.toString().equals("\"\"") && !mm.workspace.toString().equals("\"")) {
            // filenames in quotes
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            // quoted uppercase words in headings
            if (mm.workspace.toString().matches("^[A-Z]+$")) {
              // add LaTeX curly quotes to the heading word
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("``"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("''"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("uuword*"); /* add */
              mm.push();
              continue parse;
            }
            // markup language names
            if (mm.workspace.toString().equals("python") || mm.workspace.toString().equals("java") || mm.workspace.toString().equals("ruby") || mm.workspace.toString().equals("perl") || mm.workspace.toString().equals("tcl") || mm.workspace.toString().equals("rust") || mm.workspace.toString().equals("swift") || mm.workspace.toString().equals("markdown") || mm.workspace.toString().equals("c") || mm.workspace.toString().equals("c++") || mm.workspace.toString().equals("forth")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("``\\textit{\\texttt{"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("}}''"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
            // markup filenames and some unix and pep/nom names as fixed-pitch
            // font. 
            if (mm.workspace.toString().equals("pep") || mm.workspace.toString().equals("parse>") || mm.workspace.toString().equals("print") || mm.workspace.toString().equals("pop") || mm.workspace.toString().equals("push") || mm.workspace.toString().equals("get") || mm.workspace.toString().equals("put") || mm.workspace.toString().equals(".reparse") || mm.workspace.toString().equals(".restart") || mm.workspace.toString().equals("add") || mm.workspace.toString().equals("sed") || mm.workspace.toString().equals("awk") || mm.workspace.toString().equals("grep") || mm.workspace.toString().equals("pep") || mm.workspace.toString().equals("nom") || mm.workspace.toString().equals("less") || mm.workspace.toString().equals("stdin") || mm.workspace.toString().equals("stdout") || mm.workspace.toString().equals("bash") || mm.workspace.toString().endsWith(".h") || mm.workspace.toString().endsWith(".c") || mm.workspace.toString().endsWith(".a") || mm.workspace.toString().endsWith(".txt") || mm.workspace.toString().endsWith(".doc") || mm.workspace.toString().endsWith(".py") || mm.workspace.toString().endsWith(".rb") || mm.workspace.toString().endsWith(".rs") || mm.workspace.toString().endsWith(".java") || mm.workspace.toString().endsWith(".class") || mm.workspace.toString().endsWith(".tcl") || mm.workspace.toString().endsWith(".tk") || mm.workspace.toString().endsWith(".sw") || mm.workspace.toString().endsWith(".js") || mm.workspace.toString().endsWith(".go") || mm.workspace.toString().endsWith(".pp") || mm.workspace.toString().endsWith(".pss") || mm.workspace.toString().endsWith(".cpp") || mm.workspace.toString().endsWith(".pl") || mm.workspace.toString().endsWith(".html") || mm.workspace.toString().endsWith(".pdf") || mm.workspace.toString().endsWith(".tex") || mm.workspace.toString().endsWith(".sh") || mm.workspace.toString().endsWith(".css") || mm.workspace.toString().endsWith(".out") || mm.workspace.toString().endsWith(".log") || mm.workspace.toString().endsWith(".png") || mm.workspace.toString().endsWith(".jpg") || mm.workspace.toString().endsWith(".jpeg") || mm.workspace.toString().endsWith(".bmp") || mm.workspace.toString().endsWith(".mp3") || mm.workspace.toString().endsWith(".wav") || mm.workspace.toString().endsWith("aux") || mm.workspace.toString().endsWith(".tar") || mm.workspace.toString().endsWith(".gz") || mm.workspace.toString().endsWith(";")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("``\\texttt{"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("}''"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
            // everything else in quotes (but only words without spaces!)
            if (!mm.workspace.toString().equals("")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("``\\textit{"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("}''"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
          }
          // filenames 
          // crude pattern checking.
          if (mm.workspace.toString().startsWith("/") && !mm.workspace.toString().equals("/")) {
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            if (mm.workspace.toString().endsWith(".")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("\\texttt{"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("}"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            if (mm.workspace.toString().endsWith(".")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("\\texttt{"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("}"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            if (mm.workspace.toString().endsWith(".")) {
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("\\texttt{"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("}"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
          }
          // emphasis is *likethis* (only words, not phrases) 
          if (mm.workspace.toString().startsWith("*") && mm.workspace.toString().endsWith("*") && !mm.workspace.toString().equals("**")) {
            if (mm.workspace.length() > 0) { /* clip */
              mm.workspace.delete(mm.workspace.length() - 1, 
              mm.workspace.length()); }
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("\\textbf{\\emph{"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("}}"); /* add */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
          }
          // && starting a line marks the document title 
          // the document 'title' after && or first heading, & has already 
          // been escaped
          if (mm.workspace.toString().equals("\\&\\&")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.accumulator); /* count */
            if (mm.workspace.toString().equals("1")) {
              mm.workspace.setLength(0);            /* clear */
              /* while */ 
              while (Character.toString((char)mm.peep).matches("^[ \t\f]+$")) { if (mm.eof) { break; } mm.read(); }
              mm.workspace.setLength(0);            /* clear */
              /* whilenot */ 
              while (!Character.toString((char)mm.peep).matches("^[\n]+$")) { if (mm.eof) { break; } mm.read(); }
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("\\centerline{\\Large \\bf "); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("} \\medskip \n"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
          }
          // A quote, starting the line
          if (mm.workspace.toString().equals("quote:")) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append(mm.accumulator); /* count */
            if (mm.workspace.toString().equals("1")) {
              // \begin{center}
              //    {\huge \`\`}\textit{$quote}{\huge ''}
              //    \textsc{$quoteauthor}
              //  \end{center}
              mm.workspace.setLength(0);            /* clear */
              /* while */ 
              while (Character.toString((char)mm.peep).matches("^[ \t\f]+$")) { if (mm.eof) { break; } mm.read(); }
              mm.workspace.setLength(0);            /* clear */
              /* whilenot */ 
              while (!Character.toString((char)mm.peep).matches("^[\n]+$")) { if (mm.eof) { break; } mm.read(); }
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
              mm.workspace.append("\\begin{center}{\\huge ``}\\textit{"); /* add */
              mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
              mm.workspace.append("}{\\huge ''}\\end{center} \n"); /* add */
              mm.tape.get(mm.tapePointer).setLength(0); /* put */
              mm.tape.get(mm.tapePointer).append(mm.workspace); 
              mm.workspace.setLength(0);            /* clear */
            }
          }
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("word*"); /* add */
        }
        mm.pop();
        // -------------
        // 2 tokens
        // ellide text
        if (mm.workspace.toString().equals("text*text*") || mm.workspace.toString().equals("word*text*") || mm.workspace.toString().equals("word*word*") || mm.workspace.toString().equals("text*word*") || mm.workspace.toString().equals("word*uuword*") || mm.workspace.toString().equals("text*uuword*") || mm.workspace.toString().equals("uutext*word*") || mm.workspace.toString().equals("uuword*word*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        // tokenlist:
        // --- >> 4dots codeblock codeline emline nl text uutext uuword word
        // codeblock,
        // remove pesky newline tokens, 4dots handled elsewhere
        // not really working
        if (mm.workspace.toString().equals("nl*text*") || mm.workspace.toString().equals("nl*word*") || mm.workspace.toString().equals("bl*text*") || mm.workspace.toString().equals("bl*word*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("nl*dash*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("dash*"); /* add */
          mm.push();
          continue parse;
        }
        if (mm.workspace.toString().equals("nl*emline*") || mm.workspace.toString().equals("bl*emline*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("emline*"); /* add */
          mm.push();
          continue parse;
        }
        // We are using a dummy nl* token at the start of the doc, so the 
        // codeblock* codeline* etc tokens are not able to be the first token
        // of the document. So we can remove the !"codeblock*". clause.
        // multiline codeblocks with no caption 
        if (mm.workspace.toString().endsWith("codeblock*") && !mm.workspace.toString().startsWith("emline*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n\n \\begin{tabular}{l}\n  "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append(" \\end{tabular} \n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        // single line code with no caption 
        if (mm.workspace.toString().endsWith("codeline*") && !mm.workspace.toString().startsWith("emline*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n\n \\begin{tabular}{l}\n  "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append(" \\end{tabular} \n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        // eliminate emline* tokens (not followed by codeblock/line)
        // the logic is slightly different because emline* is significant before
        // other tokens, not after.
        // also, consider emline*text*nl*
        if (mm.workspace.toString().startsWith("emline*") && !mm.workspace.toString().endsWith("nl*") && !mm.workspace.toString().endsWith("codeline*") && !mm.workspace.toString().endsWith("codeblock*")) {
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("emline*", "text*");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          mm.push();
          mm.push();
          // make emline display on its own line, even when not
          // followed by codeline/codeblock. LaTeX will treat a blank line 
          // as a paragraph break, but \newline or \\ could be used.
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("\n\n"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n\n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          continue parse;
        }
        // remove insignificant 4dots* tokens, 
        // 4 dots (....) marks a subheading and always comes at the end of 
        // all capitals line. Just replacing the 4dots token with a text
        // token is safer and more logical.
        if (mm.workspace.toString().endsWith("4dots*") && !mm.workspace.toString().startsWith("uutext*") && !mm.workspace.toString().startsWith("uuword*")) {
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("4dots*", "text*");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          mm.push();
          mm.push();
          continue parse;
        }
        // remove insignificant ---* tokens
        if (mm.workspace.toString().endsWith("---*") && !mm.workspace.toString().startsWith("nl*") && !mm.workspace.toString().startsWith("bl*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        // remove insignificant >>* tokens
        // lets assume that codelines cant start a document? Or lets
        // generate a dummy nl* token at the start of the document to 
        // make parsing easier.
        // !">>*".E">>*".!B"nl*" {
        if (mm.workspace.toString().endsWith(">>*") && !mm.workspace.toString().startsWith("nl*") && !mm.workspace.toString().startsWith("bl*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        // ellide upper case text 
        if (mm.workspace.toString().equals("uuword*uuword*") || mm.workspace.toString().equals("uutext*uuword*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("uutext*"); /* add */
          mm.push();
          continue parse;
        }
        // a blank line token for terminating lists etc 
        // bl/bl should not happen really
        if (mm.workspace.toString().equals("nl*nl*") || mm.workspace.toString().equals("bl*nl*") || mm.workspace.toString().equals("bl*bl*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("bl*"); /* add */
          mm.push();
          continue parse;
        }
        // ellide multiple newlines 
        //"nl*nl*" {
        //  clear; get; ++; get; --; put; clear;
        //  add "nl*"; push; .reparse
        //}
        // code line (starts with >>) 
        if (mm.workspace.toString().equals("bl*>>*") || mm.workspace.toString().equals("nl*>>*")) {
          // ignore leading space.
          mm.workspace.setLength(0);            /* clear */
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[ \t\f]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.workspace.setLength(0);            /* clear */
          // escape | so it doesnt terminate the verb environment.
          // but how to do it? or use lstlisting
          /* whilenot */ 
          while (!Character.toString((char)mm.peep).matches("^[\n]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(" \\verb| "); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" |\n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("codeline*"); /* add */
          mm.push();
          continue parse;
        }
        // code block marker 
        if (mm.workspace.toString().equals("bl*---*") || mm.workspace.toString().equals("nl*---*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.until(",,,");
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          // remove excessive indentation.
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("\n   ", "\n");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          /* while */ 
          while (Character.toString((char)mm.peep).matches("^[,]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("\n \\begin{lstlisting}[breaklines]"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n \\end{lstlisting} \n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("codeblock*"); /* add */
          mm.push();
          continue parse;
        }
        // a code block with its preceding description
        if (mm.workspace.toString().equals("emline*codeblock*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("\n\n \\begin{tabular}{l}\n  "); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" \\\\ "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append(" \\end{tabular} \n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        // a code line with its preceding description
        // add some tabular LaTeX markup here.
        if (mm.workspace.toString().equals("emline*codeline*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("\n\n \\begin{tabular}{l}\n  "); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" \\\\ \n"); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append(" \\end{tabular} \n"); /* add */
          //add " \\end{figure}";
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*"); /* add */
          mm.push();
          continue parse;
        }
        // probably indicates an empty - at the end of a list
        // add a dummy text token
        if (mm.workspace.toString().equals("olist*bl*") || mm.workspace.toString().equals("ulist*bl*") || mm.workspace.toString().equals("dlist*bl*")) {
          mm.push();
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("empty"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("\n\n"); /* add */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*bl*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        // or use this to terminate the list, and so allow nested lists
        if (mm.workspace.toString().equals("olist*dash*") || mm.workspace.toString().equals("ulist*dash*") || mm.workspace.toString().equals("dlist*dash*")) {
          mm.push();
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("empty"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*dash*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        mm.pop();
        // -------------
        // 3 tokens
        if (mm.workspace.toString().equals("olist*word*dash*") || mm.workspace.toString().equals("ulist*word*dash*") || mm.workspace.toString().equals("dlist*word*dash*") || mm.workspace.toString().equals("olist*word*bl*") || mm.workspace.toString().equals("ulist*word*bl*") || mm.workspace.toString().equals("dlist*word*bl*")) {
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("word*", "text*");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          // or dont reparse
          // push; push; push; .reparse
        }
        // eliminate dashes that are not part of a list
        // eg: ulist*dash* olist*text*dash* dlist*word*dash*
        // the logic is tricky, how do we know there are really 3 tokens 
        // here, and not 2. This is the problem with negative tests.
        // doesnt matter because not altering attributes here.
        if (mm.workspace.toString().endsWith("dash*")) {
          if (!mm.workspace.toString().startsWith("ulist*text*") && !mm.workspace.toString().startsWith("olist*text*") && !mm.workspace.toString().startsWith("dlist*text*")) {
            /* replace */ 
            if (mm.workspace.length() > 0) { 
              temp = mm.workspace.toString().replace("dash*", "text*");
              mm.workspace.setLength(0); 
              mm.workspace.append(temp);
            } 
            mm.push();
            mm.push();
            mm.push();
            continue parse;
          }
        }
        if (mm.workspace.toString().equals("olist*text*dash*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n \\item "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("olist*"); /* add */
          mm.push();
          continue parse;
        }
        // could be ellided, but for readability, no
        if (mm.workspace.toString().equals("ulist*text*dash*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n \\item "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("ulist*"); /* add */
          mm.push();
          continue parse;
        }
        // 
        if (mm.workspace.toString().equals("dlist*text*dash*")) {
          mm.workspace.setLength(0);            /* clear */
          // already have \item start
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append(" "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          // also, put a \verbatim in [] because text is not escaped??
          mm.workspace.append("\n \\item["); /* add */
          /* whilenot */ 
          while (!Character.toString((char)mm.peep).matches("^[\n:]+$")) { if (mm.eof) { break; } mm.read(); }
          mm.workspace.append("] "); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("dlist*"); /* add */
          mm.push();
          continue parse;
        }
        // finish off the ordered list, also could finish it off with 
        // ulist*dash* ??
        if (mm.workspace.toString().equals("olist*text*bl*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("\n \\begin{enumerate}\n"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n \\item "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("\n \\end{enumerate}\n\n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // insert the blankline attribute
          mm.workspace.append("\n\n"); /* add */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*bl*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        // finish off the unordered list
        if (mm.workspace.toString().equals("ulist*text*bl*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("\n \\begin{itemize}\n"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n \\item "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("\n \\end{itemize}\n\n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // insert the blankline attribute
          mm.workspace.append("\n\n"); /* add */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*bl*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        // finish off the description list
        if (mm.workspace.toString().equals("dlist*text*bl*")) {
          // or check here if it is D/- or d/- for nextline style
          // or use \hfill \\ on each item which also works
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("\n \\begin{description}[style=nextline]\n"); /* add */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.workspace.append("\n "); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("\n \\end{description}\n\n"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // insert the blankline attribute
          mm.workspace.append("\n\n"); /* add */
          mm.increment();                 /* ++ */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append("text*bl*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        // top level headings, all upper case on the line in the source document.
        // dont need a "heading" token because we dont parse the document as a 
        // heirarchy, we just render things as we find them in the stream.
        if (mm.workspace.toString().equals("nl*uutext*nl*") || mm.workspace.toString().equals("nl*uuword*nl*") || mm.workspace.toString().equals("bl*uutext*nl*") || mm.workspace.toString().equals("bl*uuword*nl*")) {
          mm.workspace.setLength(0);            /* clear */
          // Check that heading is at least 4 chars
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.length() > 0) { /* clip */
            mm.workspace.delete(mm.workspace.length() - 1, 
            mm.workspace.length()); }
          if (mm.workspace.toString().equals("")) {
            mm.workspace.append("nl*text*nl*"); /* add */
            mm.push();
            mm.push();
            mm.push();
            continue parse;
          }
          mm.workspace.setLength(0);            /* clear */
          // make headings capital case
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          // capitalise even 1st word in latex curly quotes
          // add "<<heading\n"; print; replace "<<heading\n" "";
          if (mm.workspace.toString().startsWith("``")) {
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
          }
          /* cap */ 
          for (int i = 0; i < mm.workspace.length(); i++) { 
            char c = mm.workspace.charAt(i); 
            if (i==0){ mm.workspace.setCharAt(i, Character.toUpperCase(c)); } 
            else { mm.workspace.setCharAt(i, Character.toLowerCase(c)); } 
          }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("''", "");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          // add open curly quotes if there before.
          if ((!mm.workspace.toString().equals(mm.tape.get(mm.tapePointer).toString()))) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("``"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          // newline
          mm.workspace.append("\\section{"); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("}"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // transfer nl value
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("text*nl*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        // simple reductions 
        if (mm.workspace.toString().equals("nl*text*nl*") || mm.workspace.toString().equals("nl*word*nl*") || mm.workspace.toString().equals("bl*text*nl*") || mm.workspace.toString().equals("bl*word*nl*") || mm.workspace.toString().equals("text*text*nl*") || mm.workspace.toString().equals("emline*text*nl*")) {
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          // transfer newline value
          mm.workspace.append("text*nl*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        mm.pop();
        // -------------
        // 4 tokens
        // sub headings, 
        if (mm.workspace.toString().equals("nl*uutext*4dots*nl*") || mm.workspace.toString().equals("nl*uuword*4dots*nl*") || mm.workspace.toString().equals("bl*uutext*4dots*nl*") || mm.workspace.toString().equals("bl*uuword*4dots*nl*")) {
          mm.workspace.setLength(0);            /* clear */
          // Check that sub heading text is at least 4 chars ?
          // yes but need to transfer 4dots and nl
          // ++; get; --; clip; clip; clip; 
          // "" { add "nl*text*nl*"; push; push; push; .reparse }
          mm.workspace.setLength(0);            /* clear */
          // make subheadings capital case
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          // capitalise even 1st word in latex curly quotes
          if (mm.workspace.toString().startsWith("``")) {
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
            if (mm.workspace.length() > 0) { /* clop */
              mm.workspace.delete(0, 1); }   /* clop */
          }
          /* cap */ 
          for (int i = 0; i < mm.workspace.length(); i++) { 
            char c = mm.workspace.charAt(i); 
            if (i==0){ mm.workspace.setCharAt(i, Character.toUpperCase(c)); } 
            else { mm.workspace.setCharAt(i, Character.toLowerCase(c)); } 
          }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          /* replace */ 
          if (mm.workspace.length() > 0) { 
            temp = mm.workspace.toString().replace("''", "");
            mm.workspace.setLength(0); 
            mm.workspace.append(temp);
          } 
          // add open curly quotes if there before.
          if ((!mm.workspace.toString().equals(mm.tape.get(mm.tapePointer).toString()))) {
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("``"); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          }
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.setLength(0);            /* clear */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          // newline
          mm.workspace.append("\\subsection{"); /* add */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("}"); /* add */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          // transfer nl value
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.increment();                 /* ++ */
          mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.tape.get(mm.tapePointer).setLength(0); /* put */
          mm.tape.get(mm.tapePointer).append(mm.workspace); 
          mm.workspace.setLength(0);            /* clear */
          if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
          mm.workspace.append("text*nl*"); /* add */
          mm.push();
          mm.push();
          continue parse;
        }
        mm.push();
        mm.push();
        mm.push();
        mm.push();
        if (mm.eof) {
          // or use 'unstack' but does it adjust the tape pointer?
          mm.pop();
          mm.pop();
          mm.pop();
          mm.pop();
          mm.pop();
          mm.pop();
          // "nl*word*","nl*text*" have already been dealt with.
          // we would like "permissive" parsing, because this is just
          // a document format, not code, so will just check for starting
          // text token
          //"text*nl*","text*bl","text*" {
          if (mm.workspace.toString().startsWith("text*") || mm.workspace.toString().startsWith("word*")) {
            // show the token parse stack at the top of the document
            mm.increment();                 /* ++ */
            mm.tape.get(mm.tapePointer).setLength(0); /* put */
            mm.tape.get(mm.tapePointer).append(mm.workspace); 
            mm.workspace.setLength(0);            /* clear */
            mm.workspace.append("%% Document parse-stack is: "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            mm.workspace.setLength(0);            /* clear */
            // make a valid LaTeX document
            mm.workspace.append(""); 
            mm.workspace.append("\n  %% <start-document>"); 
            mm.workspace.append("\n  %% -------------------------------------------"); 
            mm.workspace.append("\n  %%  latex generated by: mark.latex.pss "); 
            mm.workspace.append("\n  %%   from source file : "); 
            mm.workspace.append("\n  %%                  on: "); 
            mm.workspace.append("\n  %% -------------------------------------------"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n  \\documentclass[a4paper,12pt]{article}"); 
            mm.workspace.append("\n  \\usepackage[margin=4pt,noheadfoot]{geometry}"); 
            mm.workspace.append("\n  \\usepackage{color}                   %% to use colours, use 'xcolor' for more"); 
            mm.workspace.append("\n  \\usepackage{multicol}                %% for multiple columns"); 
            mm.workspace.append("\n  \\usepackage{keystroke}               %% for keyboard key images"); 
            mm.workspace.append("\n  \\usepackage[toc]{multitoc}           %% for multi column table of contents"); 
            mm.workspace.append("\n  \\usepackage{tocloft}                 %% to customize the table of contents"); 
            mm.workspace.append("\n  \\setcounter{tocdepth}{2}             %% only display 2 levels in the contents"); 
            mm.workspace.append("\n  \\setlength{\\cftbeforesecskip}{0cm}   %% make the toc more compact"); 
            mm.workspace.append("\n  \\usepackage{listings}                %% for nice code listings"); 
            mm.workspace.append("\n  \\usepackage{caption}                 %% "); 
            mm.workspace.append("\n  \\lstset{"); 
            mm.workspace.append("\n    captionpos=t,"); 
            mm.workspace.append("\n    language=bash,"); 
            mm.workspace.append("\n    basicstyle=\\ttfamily,           %% fixed pitch font"); 
            mm.workspace.append("\n    xleftmargin=0pt,                %% margin on the left outside the frames"); 
            mm.workspace.append("\n    framexleftmargin=0pt,"); 
            mm.workspace.append("\n    framexrightmargin=0pt,"); 
            mm.workspace.append("\n    framexbottommargin=5pt,"); 
            mm.workspace.append("\n    framextopmargin=5pt,"); 
            mm.workspace.append("\n    breaklines=true,                %% break long code lines"); 
            mm.workspace.append("\n    breakatwhitespace=false,        %% break long code lines anywhere"); 
            mm.workspace.append("\n    breakindent=10pt,               %% reduce the indent from 20pt to 10"); 
            mm.workspace.append("\n    postbreak=\\mbox{{\\color{blue}\\small$\\Rightarrow$\\space}},  %% mark with arrow"); 
            mm.workspace.append("\n    showstringspaces=false,            %% dont show spaces within strings"); 
            mm.workspace.append("\n    framerule=2pt,                     %% thickness of the frames"); 
            mm.workspace.append("\n    frame=top,frame=bottom,"); 
            mm.workspace.append("\n    rulecolor=\\color{lightgrey}, "); 
            mm.workspace.append("\n    % frame=l"); 
            mm.workspace.append("\n    % define special comment delimiters '##(' and ')'"); 
            mm.workspace.append("\n    % moredelim=[s][\\color{grey}\\itshape\\footnotesize\\ttfamily]{~(}{)},"); 
            mm.workspace.append("\n  }   %% source code settings"); 
            mm.workspace.append("\n  \\usepackage{graphicx}                %% to include images"); 
            mm.workspace.append("\n  \\usepackage{fancybox}                %% boxes with rounded corners"); 
            mm.workspace.append("\n  \\usepackage{wrapfig}                 %% flow text around tables, images"); 
            mm.workspace.append("\n  \\usepackage{tabularx}                %% change width of tables"); 
            mm.workspace.append("\n  \\usepackage[table]{xcolor}           %% alternate row colour tables"); 
            mm.workspace.append("\n  \\usepackage{booktabs}                %% for heavier rules in tables"); 
            mm.workspace.append("\n  \\usepackage[small,compact]{titlesec} %% sections more compact, less space"); 
            mm.workspace.append("\n  \\usepackage{enumitem}                %% more compact and better lists"); 
            mm.workspace.append("\n  \\setlist{noitemsep}                  %% reduce list item spacing"); 
            mm.workspace.append("\n  \\usepackage{hyperref}     %% make urls into hyperlinks"); 
            mm.workspace.append("\n  \\hypersetup{              %% add pdftex if only pdf output is required"); 
            mm.workspace.append("\n     colorlinks=false,       %% set up the colours for the hyperlinks"); 
            mm.workspace.append("\n     linkcolor=black,        %% internal document links black"); 
            mm.workspace.append("\n     urlcolor=black,        %% url links black"); 
            mm.workspace.append("\n     frenchlinks=true,"); 
            mm.workspace.append("\n     bookmarks=true, pdfpagemode=UseOutlines}"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n  \\geometry{ left=1.0in,right=1.0in,top=1.0in,bottom=1.0in }"); 
            mm.workspace.append("\n  %% define some colours to use"); 
            mm.workspace.append("\n  \\definecolor{lightgrey}{gray}{0.70}"); 
            mm.workspace.append("\n  \\definecolor{grey}{gray}{0.30}"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n  %% titlesec: create framed section headings"); 
            mm.workspace.append("\n  %% \\titleformat{\\section}[frame]{\\normalfont}"); 
            mm.workspace.append("\n  %%   {\\filleft \\footnotesize \\enspace Section \\thesection\\enspace\\enspace}"); 
            mm.workspace.append("\n  %%   {3pt} {\\bfseries\\itshape\\filright}"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n  \\title{The Pep/nom parsing language and machine}"); 
            mm.workspace.append("\n  \\author{m.j.bishop}"); 
            mm.workspace.append("\n  \\date{\\today}"); 
            mm.workspace.append("\n  \\setlength{\\parindent}{0pt}"); 
            mm.workspace.append("\n  %% \\setlength{\\parskip}{1ex}"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n  %% label lists with stars"); 
            mm.workspace.append("\n  \\renewcommand{\\labelitemi}{$\\star$}"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n  \\parindent=0pt"); 
            mm.workspace.append("\n  \\parskip=6pt"); 
            mm.workspace.append("\n  \\begin{document}"); 
            mm.workspace.append("\n"); 
            mm.workspace.append("\n  "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n\\end{document} \n"); /* add */
            mm.workspace.append("\n\n %% Document parsed as text*!\n"); /* add */
            // show parse-stack at end of doc as well
            mm.increment();                 /* ++ */
            mm.workspace.append(" %% Document parse-stack is: "); /* add */
            mm.workspace.append(mm.tape.get(mm.tapePointer)); /* get */
            mm.workspace.append("\n"); /* add */
            if (mm.tapePointer > 0) mm.tapePointer--; /* -- */
            System.out.print(mm.workspace); /* print */
            break script;
          }
          while(mm.push());          /* stack */
          mm.workspace.append("Document parsed unusually!\n"); /* add */
          mm.workspace.append("Stack at line "); /* add */
          mm.workspace.append(mm.linesRead); /* lines */
          mm.workspace.append(" char "); /* add */
          mm.workspace.append(mm.charsRead); /* chars */
          mm.workspace.append(": "); /* add */
          System.out.print(mm.workspace); /* print */
          mm.workspace.setLength(0);            /* clear */
          while (mm.pop());          /* unstack */
          System.out.print(mm.workspace); /* print */
          while(mm.push());          /* stack */
          mm.workspace.append("\n"); /* add */
          System.out.print(mm.workspace); /* print */
          mm.workspace.setLength(0);            /* clear */
          break script;
        }
        break parse;
      }
    }
  }
}
