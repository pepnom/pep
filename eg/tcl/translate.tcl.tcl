#!/usr/bin/tclsh

# code generated by "translate.tcl.pss" a pep script
# see bumble.sf.net/books/pars/
#import sys    # 

  # make a new machine. Standard tcl doesnt have objects
  # so I will use an associative array, instead.
  #array set mm {
  #  eof false     # end of stream reached?
  #  charsRead 0   # how many chars already read
  #  linesRead 1   # how many lines already read
  #  escape "\\"
  #  delimiter "*" # push/pop delimiter (default "*")
  #  counter 0     # a counter for anything
  #  work ""       # the workspace
  #  stack {}    # stack for parse tokens 
  #  cell 0      # current tape cell
  #  size 100    # the initial tape/marks list size
  #  tape {}     # a list of attribute for tokens 
  #  marks {}    # marked tape cells
  #  peep [read stdin 1] 
  #}

  # make a new machine. Standard tcl doesnt have objects
  # so I will use an associative array, instead.
  array set mm {
    eof false     
    charsRead 0  
    linesRead 1 
    escape "\\"
    delimiter "*" 
    counter 0    
    work ""     
    stack {}   
    cell 0    
    size 0 
    tape {}  
    marks {}
    peep {} 
  }

  # Adds more elements to the tape and marks lists 
  proc MoreTape {} { 
    global mm
    for {set ii 0} {$ii < 100} {incr ii} { 
      lappend mm(tape) ""; lappend mm(marks) "";
    }
    incr mm(size) 100
  }

  # initialises a machine  
  proc Init {} { 
    global mm
    set mm(peep) [ read stdin 1 ]
    # or Read;
    MoreTape;
  }

  # read one character from the input stream and 
  #    update the machine.
  proc Read {} { 
    # use upvar eg
    # upvar $machine mm
    global mm
    if { $mm(eof) } { exit }
    incr mm(charsRead)
    # increment lines
    if { $mm(peep) eq "\n" } { incr mm(linesRead) }
    append mm(work) $mm(peep)
    set mm(peep) [ read stdin 1 ]
    if {[eof stdin]} { set mm(eof) true; set mm(peep) -1 }
  } 

  # increment tape pointer by one: trivial method? But need
  # to increase tape/marks size if exceeded
  proc Increment {} { global mm; incr mm(cell) } 

  # remove escape character: trivial method ?
  proc UnescapeChar {c} {
    global mm
    #if { $mm(work) ne "" } $mm(work = $mm(work.replace("\\"+c, c)
  }

  # add escape character : trivial
  proc EscapeChar {c} {
    global mm
    #if { $mm(work) ne "" } { $mm(work = $mm(work.replace(c, "\\"+c) }
  }

  # pop the first token from the stack into the workspace */
  proc Pop {} { 
    global mm
    if {[llength $mm(stack)] == 0} { return false }
    # prepend last stack item, and delete the item
    set mm(work) "[lindex $mm(stack) end]$mm(work)"
    set mm(stack) [lrange $mm(stack) 0 [expr [llength $mm(stack)]-2]] 
    if {$mm(cell) > 0} { incr mm(cell) -1 }
    return true
  }
  
  # push the first token from the workspace to the stack 
  proc Push {} {
    # lappend list $value
    # dont increment the tape pointer on an empty push
    global mm
    if { $mm(work) eq "" } { return false }
    # need to get this from the delimiter.
    set firstdelim [string first $mm(delimiter) $mm(work)]
    if {$firstdelim == -1} {
      lappend mm(stack) $mm(work)
      set mm(work) ""
      incr mm(cell) 1
      # a hack because "stack" hangs otherwise (never returns false)
      return false
      #return true
    }
    lappend mm(stack) [string range $mm(work) 0 $firstdelim]
    set mm(work) [string range $mm(work) [expr {$firstdelim+1}] end]
    incr mm(cell) 1
    return true
  }

  # a helper function
  proc IsEscaped {suffix} {
    global mm
    # remove suffix
    set count 0
    set last [expr {[string last $suffix $mm(work)]-1}]
    set new [string range $mm(work) 0 $last]
    # now count trailing escape chars
    while {[string index $new end] eq $mm(escape)} {
      set last [expr {[string last $mm(escape) $new]-1}]
      set new [string range $new 0 $last]
      incr count
    }
    # puts count=$count
    if { $count == 1 } { return true }
    if {[expr {($count % 2) == 0}]} { return false } else { return true }
  }

  # reads the input stream until the workspace end with text 
  proc Until {suffix} { 
    # read at least one character
    global mm
    if { $mm(eof) } { return }
    Read;
    while true { 
      if {$mm(eof)} { return }
      # this must count trailing escapes
      if {[string match *$suffix $mm(work)] && ![IsEscaped $suffix]} { return }
      Read;
    }
  }  

  # maybe not required 
  proc Swap {} { 
    global mm
    set s $mm(work)
    set mm(work) $mm(tape)[$mm(cell)]
    # could be a problem if $s has spaces in it. (becomes a list)
    lset mm(tape) $mm(cell) $s
  }

  proc WriteToFile {} { 
    global mm
    set f [open sav.pp w 0600]  
    puts $f $mm(work)
    close $f
  }

  # useful for debugging, the "state" command
  proc State {} { 
    global mm
    puts "---------- Machine State --------------";
    puts -nonewline " Stack\[[join $mm(stack) {}]\] Work\[$mm(work)\] ";
    puts "Peep\[$mm(peep)\]";
    puts -nonewline " Acc:$mm(counter) Esc:$mm(escape) ";
    puts -nonewline "Delim:$mm(delimiter) Chars:$mm(charsRead) ";
    puts "Lines:$mm(linesRead)";
    puts "---------- Tape (size:$mm(size))  --------------";
    set ii 0
    while { $ii < 7 } {
      puts -nonewline "  $ii";
      if { $ii == $mm(cell) } { 
        puts -nonewline "> "
      } else { puts -nonewline "  " }
      # display marks
      if { [lindex $mm(marks) $ii] ne "" } { 
        puts -nonewline "\"[lindex $mm(marks) $ii]\" "
      } else { puts -nonewline ". " }

      puts "\[[lindex $mm(tape) $ii]\]";
      incr ii
    }
  }
  # end of tcl pep Machine "class" (array) definition

  # a flag var to make .restart work in run-once loops
  set restart false
  # initialise the machine
  Init;
 
while !$mm(eof) { 
  
  # lex block 
  while true { 
    Read;           # read
    #--------------
    if {[regexp {^[[:space:]]+$} $mm(work)]} {
      set mm(work) "";       # clear
      break;  # .reparse 
    }
    #---------------
    # We can ellide all these single character tests, because
    # the stack token is just the character itself with a *
    # Braces \{\} are used for blocks of commands, ',' and '.' for concatenating
    # tests with OR or AND logic. 'B' and 'E' for begin and end
    # tests, '!' is used for negation, ';' is used to terminate a 
    # command.
    if {$mm(work) eq "\{" || $mm(work) eq "\}" || $mm(work) eq ";" || $mm(work) eq "," || $mm(work) eq "." || $mm(work) eq "!" || $mm(work) eq "B" || $mm(work) eq "E"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      append mm(work) "*"
      Push;
      break;  # .reparse 
    }
    #---------------
    # format: "text"
    if {$mm(work) eq "\""} {
      # save the start line number (for error messages) in case 
      # there is no terminating quote character.
      set mm(work) "";       # clear
      append mm(work) "line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ") "
      # safer to use braces for quotes??
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "\""
      Until {\"};
      if {![string match *\" $mm(work)] } {
        set mm(work) "";       # clear
        append mm(work) "Unterminated quote character (\") starting at "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) " !\n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      # just escape \[ and \$ because they cause string interpolation
      # in tcl
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      set mm(work) [string map {"\[" "\\\["} $mm(work)]
      set mm(work) [string map {"\]" "\\\]"} $mm(work)]
      set mm(work) [string map {"\$" "\\\$"} $mm(work)]
      set mm(work) [string map {"\{" "\\\{"} $mm(work)]
      set mm(work) [string map {"\}" "\\\}"} $mm(work)]
      append mm(work) "\""
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "quote*"
      Push;
      break;  # .reparse 
    }
    #---------------
    # format: 'text', single quotes are converted to double quotes
    # but we must escape embedded double quotes.
    if {$mm(work) eq "'"} {
      # save the start line number (for error messages) in case 
      # there is no terminating quote character.
      set mm(work) "";       # clear
      append mm(work) "line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ") "
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      Until {'};
      if {![string match *' $mm(work)] } {
        set mm(work) "";       # clear
        append mm(work) "Unterminated quote (') starting at "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "!\n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      # \[ and \$ cause interpolation in tcl so must be escaped
      set mm(work) [string map {"\[" "\\\["} $mm(work)]
      set mm(work) [string map {"\]" "\\\]"} $mm(work)]
      set mm(work) [string map {"\$" "\\\$"} $mm(work)]
      set mm(work) [string map {"\{" "\\\{"} $mm(work)]
      set mm(work) [string map {"\}" "\\\}"} $mm(work)]
      set mm(work) [string map {"\"" "\\\""} $mm(work)]
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "\""
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\""
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "quote*"
      Push;
      break;  # .reparse 
    }
    #---------------
    # formats: \[:space:\] \[a-z\] \[abcd\] \[:alpha:\] etc 
    # should class tests really be multiline??!
    if {$mm(work) eq "\["} {
      # save the start line number (for error messages) in case 
      # there is no terminating bracket character.
      set mm(work) "";       # clear
      append mm(work) "line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ") "
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "\["
      Until {\]};
      if {$mm(work) eq "\[\]"} {
        set mm(work) "";       # clear
        append mm(work) "pep script error at line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) " (character "
        append mm(work) $mm(charsRead); # chars 
        append mm(work) "): \n"
        append mm(work) "  empty character class \[\] \n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      if {![string match *\] $mm(work)] } {
        set mm(work) "";       # clear
        append mm(work) "Unterminated class text (\[...\]) starting at "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "" 
        append mm(work) "\n      class text can be used in tests or with the 'while' and " 
        append mm(work) "\n      'whilenot' commands. For example: " 
        append mm(work) "\n        \[:alpha:\] \{ while \[:alpha:\]; print; clear; \}" 
        append mm(work) "\n      "
        puts -nonewline $mm(work);    # print
        exit;
      }
      # need to escape \{ and \} so they dont interfere with the
      # quote braces used for regexp. Dont need to escape \[ and \] because 
      # the script writer has to escape them any way. (but what about in quotes?)
      set mm(work) [string map {"\}" "\\\}"} $mm(work)]
      set mm(work) [string map {"\{" "\\\{"} $mm(work)]
      # the caret is not a negation operator in pep scripts
      set mm(work) [string map {"^" "\\^"} $mm(work)]
      # the line below also works
      #replace "^" "\\^";
      # save the class on the tape
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(work) ne "" } { 
        set mm(work) [string range $mm(work) 1 end] } ; # clop
      if { $mm(work) ne "" } { 
        set mm(work) [string range $mm(work) 1 end] } ; # clop
      if {![string match -* $mm(work)] } {
        # not a range class, eg \[a-z\] so need to escape '-' chars. yes
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        set mm(work) [string map {"-" "\\-"} $mm(work)]
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {[string match {-*} $mm(work)]} {
        # a range class, eg \[a-z\], check if it is correct
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if {$mm(work) ne "-"} {
          set mm(work) "";       # clear
          append mm(work) "Error in pep script at line "
          append mm(work) $mm(linesRead); # lines 
          append mm(work) " (character "
          append mm(work) $mm(charsRead); # chars 
          append mm(work) "): \n"
          append mm(work) " Incorrect character range class "
          append mm(work) [lindex $mm(tape) $mm(cell)]; # get
          append mm(work) "" 
          append mm(work) "\n   For example:" 
          append mm(work) "\n     \[a-g\]  # correct" 
          append mm(work) "\n     \[f-gh\] # error! \n"
          puts -nonewline $mm(work);    # print
          set mm(work) "";       # clear
          exit;
        }
      }
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # restore class text
      if {[string match {\[:*} $mm(work)] && ![string match *:\] $mm(work)] } {
        set mm(work) "";       # clear
        append mm(work) "malformed character class starting at "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "!\n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      if {[string match {\[:*} $mm(work)] && $mm(work) ne "\[:\]"} {
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        # unicode posix character classes in tcl
        # Also, abbreviations (not implemented in gh.c yet.)
        # abbreviations are written \[:A:\] etc
        if {$mm(work) eq "alnum" || $mm(work) eq "N"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:alnum:\]\]"
        }
        if {$mm(work) eq "alpha" || $mm(work) eq "A"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:alpha:\]\]"
        }
        if {$mm(work) eq "ascii" || $mm(work) eq "I"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:ascii:\]\]"
        }
        if {$mm(work) eq "blank" || $mm(work) eq "B"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:blank:\]\]"
        }
        if {$mm(work) eq "cntrl" || $mm(work) eq "C"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:cntrl:\]\]"
        }
        if {$mm(work) eq "digit" || $mm(work) eq "D"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:digit:\]\]"
        }
        if {$mm(work) eq "graph" || $mm(work) eq "G"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:graph:\]\]"
        }
        if {$mm(work) eq "lower" || $mm(work) eq "L"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:lower:\]\]"
        }
        if {$mm(work) eq "print" || $mm(work) eq "P"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:print:\]\]"
        }
        if {$mm(work) eq "punct" || $mm(work) eq "T"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:punct:\]\]"
        }
        if {$mm(work) eq "space" || $mm(work) eq "S"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:space:\]\]"
        }
        if {$mm(work) eq "upper" || $mm(work) eq "U"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:upper:\]\]"
        }
        if {$mm(work) eq "xdigit" || $mm(work) eq "X"} {
          set mm(work) "";       # clear
          append mm(work) "\[\[:xdigit:\]\]"
        }
      }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      # add quotes around the class and limits around the 
      # class so it can be used with the string.matches() method
      # (must match the whole string, not just one character)
      append mm(work) "^"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "+\$"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "class*"
      Push;
      break;  # .reparse 
    }
    #---------------
    # formats: (eof) (EOF) (==) etc. 
    if {$mm(work) eq "("} {
      set mm(work) "";       # clear
      Until {)};
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if {$mm(work) eq "eof" || $mm(work) eq "EOF"} {
        set mm(work) "";       # clear
        append mm(work) "eof*"
        Push;
        break;  # .reparse 
      }
      if {$mm(work) eq "=="} {
        set mm(work) "";       # clear
        append mm(work) "tapetest*"
        Push;
        break;  # .reparse 
      }
      append mm(work) " << unknown test near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " of script.\n"
      append mm(work) " bracket () tests are \n"
      append mm(work) "   (eof) test if end of stream reached. \n"
      append mm(work) "   (==)  test if workspace is same as current tape cell \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    #---------------
    # multiline and single line comments, eg #... and #* ... *#
    if {$mm(work) eq "#"} {
      set mm(work) "";       # clear
      Read;           # read
      if {$mm(work) eq "\n"} {
        set mm(work) "";       # clear
        break;  # .reparse 
      }
      # checking for multiline comments of the form "#* \n\n\n *#"
      # these are just ignored at the moment (deleted) 
      if {$mm(work) eq "*"} {
        # save the line number for possible error message later
        set mm(work) "";       # clear
        append mm(work) $mm(linesRead); # lines 
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        Until {*#};
        if {[string match {**#} $mm(work)]} {
          # no, need to convert to multiple single line comments
          # or a if \{0\} \{ \} block for tcl
          if { $mm(work) ne "" } {
            set mm(work) [string range $mm(work) 0 end-1]
          }; # clip
          if { $mm(work) ne "" } {
            set mm(work) [string range $mm(work) 0 end-1]
          }; # clip
          lset mm(tape) $mm(cell) $mm(work);  # put 
          set mm(work) "";       # clear
          append mm(work) "if \{0\} \{"
          append mm(work) [lindex $mm(tape) $mm(cell)]; # get
          append mm(work) "\}"
          # create a "comment" parse token
          lset mm(tape) $mm(cell) $mm(work);  # put 
          set mm(work) "";       # clear
          # comment-out this line to remove multiline comments from the 
          # compiled code 
          # add "comment*"; push; 
          break;  # .reparse 
        }
        # make an unterminated multiline comment an error
        # to ease debugging of scripts.
        set mm(work) "";       # clear
        append mm(work) "Unterminated multiline comment #* ... *# \n"
        append mm(work) "starting at line number "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      # single line comments. some will get lost.
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "#"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      Until {\n};
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      # escape special chars for tcl, since it looks for 
      # these even in comments! (I know, strange but true)
      set mm(work) [string map {"\[" "\\\["} $mm(work)]
      set mm(work) [string map {"\]" "\\\]"} $mm(work)]
      set mm(work) [string map {"\$" "\\\$"} $mm(work)]
      set mm(work) [string map {"\{" "\\\{"} $mm(work)]
      set mm(work) [string map {"\}" "\\\}"} $mm(work)]
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      # I am removing comments from translated scripts because
      # tcl doesnt like unbalanced braces in comments!
      append mm(work) "comment*"
      Push;
      break;  # .reparse 
    }
    #----------------------------------
    # parse command words (and abbreviations)
    # legal characters for keywords (commands)
    if {![regexp {^[abcdefghijklmnopqrstuvwxyzBEKGPRUWS+\-<>0\^]+$} $mm(work)]} {
      # error message about a misplaced character
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "!! Misplaced character '"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "' in script near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ") \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    # my testclass implementation cannot handle complex lists
    # eg \[a-z+-\] this is why I have to write out the whole alphabet
    # while  
    while {[regexp {^[abcdefghijklmnopqrstuvwxyzBEOFKGPRUWS+\-<>0\^]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
    #----------------------------------
    # KEYWORDS 
    # here we can test for all the keywords (command words) and their
    # abbreviated one letter versions (eg: clip k, clop K etc). Then
    # we can print an error message and abort if the word is not a 
    # legal keyword for the parse-edit language
    # make ll an alias for "lines" and cc an alias for chars
    if {$mm(work) eq "ll"} {
      set mm(work) "";       # clear
      append mm(work) "lines"
    }
    if {$mm(work) eq "cc"} {
      set mm(work) "";       # clear
      append mm(work) "chars"
    }
    # one letter command abbreviations
    if {$mm(work) eq "a"} {
      set mm(work) "";       # clear
      append mm(work) "add"
    }
    if {$mm(work) eq "k"} {
      set mm(work) "";       # clear
      append mm(work) "clip"
    }
    if {$mm(work) eq "K"} {
      set mm(work) "";       # clear
      append mm(work) "clop"
    }
    if {$mm(work) eq "D"} {
      set mm(work) "";       # clear
      append mm(work) "replace"
    }
    if {$mm(work) eq "d"} {
      set mm(work) "";       # clear
      append mm(work) "clear"
    }
    if {$mm(work) eq "t"} {
      set mm(work) "";       # clear
      append mm(work) "print"
    }
    if {$mm(work) eq "p"} {
      set mm(work) "";       # clear
      append mm(work) "pop"
    }
    if {$mm(work) eq "P"} {
      set mm(work) "";       # clear
      append mm(work) "push"
    }
    if {$mm(work) eq "u"} {
      set mm(work) "";       # clear
      append mm(work) "unstack"
    }
    if {$mm(work) eq "U"} {
      set mm(work) "";       # clear
      append mm(work) "stack"
    }
    if {$mm(work) eq "G"} {
      set mm(work) "";       # clear
      append mm(work) "put"
    }
    if {$mm(work) eq "g"} {
      set mm(work) "";       # clear
      append mm(work) "get"
    }
    if {$mm(work) eq "x"} {
      set mm(work) "";       # clear
      append mm(work) "swap"
    }
    if {$mm(work) eq ">"} {
      set mm(work) "";       # clear
      append mm(work) "++"
    }
    if {$mm(work) eq "<"} {
      set mm(work) "";       # clear
      append mm(work) "--"
    }
    if {$mm(work) eq "m"} {
      set mm(work) "";       # clear
      append mm(work) "mark"
    }
    if {$mm(work) eq "M"} {
      set mm(work) "";       # clear
      append mm(work) "go"
    }
    if {$mm(work) eq "r"} {
      set mm(work) "";       # clear
      append mm(work) "read"
    }
    if {$mm(work) eq "R"} {
      set mm(work) "";       # clear
      append mm(work) "until"
    }
    if {$mm(work) eq "w"} {
      set mm(work) "";       # clear
      append mm(work) "while"
    }
    if {$mm(work) eq "W"} {
      set mm(work) "";       # clear
      append mm(work) "whilenot"
    }
    if {$mm(work) eq "n"} {
      set mm(work) "";       # clear
      append mm(work) "count"
    }
    if {$mm(work) eq "+"} {
      set mm(work) "";       # clear
      append mm(work) "a+"
    }
    if {$mm(work) eq "-"} {
      set mm(work) "";       # clear
      append mm(work) "a-"
    }
    if {$mm(work) eq "0"} {
      set mm(work) "";       # clear
      append mm(work) "zero"
    }
    if {$mm(work) eq "c"} {
      set mm(work) "";       # clear
      append mm(work) "chars"
    }
    if {$mm(work) eq "l"} {
      set mm(work) "";       # clear
      append mm(work) "lines"
    }
    if {$mm(work) eq "^"} {
      set mm(work) "";       # clear
      append mm(work) "escape"
    }
    if {$mm(work) eq "v"} {
      set mm(work) "";       # clear
      append mm(work) "unescape"
    }
    if {$mm(work) eq "z"} {
      set mm(work) "";       # clear
      append mm(work) "delim"
    }
    if {$mm(work) eq "S"} {
      set mm(work) "";       # clear
      append mm(work) "state"
    }
    if {$mm(work) eq "q"} {
      set mm(work) "";       # clear
      append mm(work) "quit"
    }
    if {$mm(work) eq "s"} {
      set mm(work) "";       # clear
      append mm(work) "write"
    }
    if {$mm(work) eq "o"} {
      set mm(work) "";       # clear
      append mm(work) "nop"
    }
    if {$mm(work) eq "rs"} {
      set mm(work) "";       # clear
      append mm(work) "restart"
    }
    if {$mm(work) eq "rp"} {
      set mm(work) "";       # clear
      append mm(work) "reparse"
    }
    # some extra syntax for testeof and testtape
    if {$mm(work) eq "<eof>" || $mm(work) eq "<EOF>"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "eof*"
      Push;
      break;  # .reparse 
    }
    if {$mm(work) eq "<==>"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "tapetest*"
      Push;
      break;  # .reparse 
    }
    if {$mm(work) eq "jump" || $mm(work) eq "jumptrue" || $mm(work) eq "jumpfalse" || $mm(work) eq "testis" || $mm(work) eq "testclass" || $mm(work) eq "testbegins" || $mm(work) eq "testends" || $mm(work) eq "testeof" || $mm(work) eq "testtape"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "The instruction '"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "' near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")\n"
      append mm(work) "can be used in pep assembly code but not scripts. \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    # show information if these "deprecated" commands are used
    if {$mm(work) eq "Q" || $mm(work) eq "bail"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "The instruction '"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "' near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")\n"
      append mm(work) "is no longer part of the pep language (july 2020). \n"
      append mm(work) "use 'quit' instead of 'bail'\n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "add" || $mm(work) eq "clip" || $mm(work) eq "clop" || $mm(work) eq "replace" || $mm(work) eq "upper" || $mm(work) eq "lower" || $mm(work) eq "cap" || $mm(work) eq "clear" || $mm(work) eq "print" || $mm(work) eq "pop" || $mm(work) eq "push" || $mm(work) eq "unstack" || $mm(work) eq "stack" || $mm(work) eq "put" || $mm(work) eq "get" || $mm(work) eq "swap" || $mm(work) eq "++" || $mm(work) eq "--" || $mm(work) eq "mark" || $mm(work) eq "go" || $mm(work) eq "read" || $mm(work) eq "until" || $mm(work) eq "while" || $mm(work) eq "whilenot" || $mm(work) eq "count" || $mm(work) eq "a+" || $mm(work) eq "a-" || $mm(work) eq "zero" || $mm(work) eq "chars" || $mm(work) eq "lines" || $mm(work) eq "nochars" || $mm(work) eq "nolines" || $mm(work) eq "escape" || $mm(work) eq "unescape" || $mm(work) eq "delim" || $mm(work) eq "quit" || $mm(work) eq "state" || $mm(work) eq "write" || $mm(work) eq "nop" || $mm(work) eq "reparse" || $mm(work) eq "restart"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "word*"
      Push;
      break;  # .reparse 
    }
    #------------ 
    # the .reparse command and "parse label" is a simple way to 
    # make sure that all shift-reductions occur. It should be used inside
    # a block test, so as not to create an infinite loop. There is
    # no "goto" in java so we need to use labelled loops to 
    # implement .reparse/parse>
    if {$mm(work) eq "parse>"} {
      set mm(work) "";       # clear
      append mm(work) $mm(counter); # count 
      if {$mm(work) ne "0"} {
        set mm(work) "";       # clear
        append mm(work) "\[error\] pep script error:\n"
        append mm(work) "  extra parse> label at line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) ".\n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      set mm(work) "";       # clear
      append mm(work) "// parse>"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "parse>*"
      Push;
      # use accumulator to indicate after parse> label
      incr mm(counter);  # a+ 
      break;  # .reparse 
    }
    # --------------------
    # implement "begin-blocks", which are only executed
    # once, at the beginning of the script (similar to awk's BEGIN \{\} rules)
    if {$mm(work) eq "begin"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      append mm(work) "*"
      Push;
      break;  # .reparse 
    }
    append mm(work) " << unknown command on line "
    append mm(work) $mm(linesRead); # lines 
    append mm(work) " (char "
    append mm(work) $mm(charsRead); # chars 
    append mm(work) ")"
    append mm(work) " of source file. \n"
    append mm(work) " " 
    append mm(work) "\n   Valid commands are:" 
    append mm(work) "\n     add,clip,clop,replace,upper,lower,cap,clear,print," 
    append mm(work) "\n     pop,push,unstack,stack,put,get,swap," 
    append mm(work) "\n     ++,--,mark,go,read,until,while,whilenot," 
    append mm(work) "\n     count,a+,a-,zero,chars,lines,nochars,nolines," 
    append mm(work) "\n     escape,unescape,delim,quit,state," 
    append mm(work) "\n     write,nop,.reparse,.restart \n"
    puts -nonewline $mm(work);    # print
    set mm(work) "";       # clear
    exit;
    # ----------------------------------
    # PARSING PHASE:
    # Below is the parse/compile phase of the script. Here we pop tokens off the
    # stack and check for sequences of tokens eg "word*semicolon*". If we find a
    # valid series of tokens, we "shift-reduce" or "resolve" the token series eg
    # word*semicolon* --> command*
    # At the same time, we manipulate (transform) the attributes on the tape, as
    # required. 
    break;
  }
  if {$restart == true} { set restart false; continue; }
  
  # parse block 
  while true {  
    #-------------------------------------
    # 2 tokens
    #-------------------------------------
    Pop;
    Pop;
    # All of the patterns below are currently errors, but may not
    # be in the future if we expand the syntax of the parse
    # language. Also consider:
    #    begintext* endtext* quoteset* notclass*, !* ,* ;* B* E*
    # It is nice to trap the errors here because we can emit some
    # (hopefully not very cryptic) error messages with a line number.
    # Otherwise the script writer has to debug with
    #   pep -a asm.pp -I scriptfile 
    if {$mm(work) eq "word*word*" || $mm(work) eq "word*\}*" || $mm(work) eq "word*begintext*" || $mm(work) eq "word*endtext*" || $mm(work) eq "word*!*" || $mm(work) eq "word*,*" || $mm(work) eq "quote*word*" || $mm(work) eq "quote*class*" || $mm(work) eq "quote*state*" || $mm(work) eq "quote*\}*" || $mm(work) eq "quote*begintext*" || $mm(work) eq "quote*endtext*" || $mm(work) eq "class*word*" || $mm(work) eq "class*quote*" || $mm(work) eq "class*class*" || $mm(work) eq "class*state*" || $mm(work) eq "class*\}*" || $mm(work) eq "class*begintext*" || $mm(work) eq "class*endtext*" || $mm(work) eq "class*!*" || $mm(work) eq "notclass*word*" || $mm(work) eq "notclass*quote*" || $mm(work) eq "notclass*class*" || $mm(work) eq "notclass*state*" || $mm(work) eq "notclass*\}*"} {
      append mm(work) " (Token stack) \nValue: \n"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\nValue: \n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) "\n"
      append mm(work) "Error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of pep script (missing semicolon?) \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "\{*;*" || $mm(work) eq ";*;*" || $mm(work) eq "\}*;*"} {
      Push;
      Push;
      append mm(work) "Error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of pep script: misplaced semi-colon? ; \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq ",*\{*"} {
      Push;
      Push;
      append mm(work) "Error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script: extra comma in list? \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "command*;*" || $mm(work) eq "commandset*;*"} {
      Push;
      Push;
      append mm(work) "Error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script: extra semi-colon? \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "!*!*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script: \n double negation '!!' is not implemented \n"
      append mm(work) " and probably won't be, because what would be the point? \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "!*\{*" || $mm(work) eq "!*;*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script: misplaced negation operator (!)? \n"
      append mm(work) " The negation operator precedes tests, for example: \n"
      append mm(work) "   !B'abc'\{ ... \} or !(eof),!'abc'\{ ... \} \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq ",*command*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script: misplaced comma? \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "!*command*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (at char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ") \n"
      append mm(work) " The negation operator (!) cannot precede a command \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq ";*\{*" || $mm(work) eq "command*\{*" || $mm(work) eq "commandset*\{*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script: no test for brace block? \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "\{*\}*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " of script: empty braces \{\}. \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "B*class*" || $mm(work) eq "E*class*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " of script:\n  classes (\[a-z\], \[:space:\] etc). \n"
      append mm(work) "  cannot use the 'begin' or 'end' modifiers (B/E) \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "comment*\{*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " of script: comments cannot occur between \n"
      append mm(work) " a test and a brace (\{). \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "\}*command*"} {
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " of script: extra closing brace '\}' ?. \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    #------------ 
    # The .restart command jumps to the first instruction after the
    # begin block (if there is a begin block), or the first instruction
    # of the script.
    if {$mm(work) eq ".*word*"} {
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if {$mm(work) eq "restart"} {
        set mm(work) "";       # clear
        append mm(work) $mm(counter); # count 
        #"0" \{ clear; add "continue;   # .restart "; \}
        if {$mm(work) eq "0"} {
          set mm(work) "";       # clear
          # use the comment '# restart' so we can replace
          # this with 'break' if the parse> label appears later
          append mm(work) "set restart true; continue; # restart"
        }
        if {$mm(work) eq "1"} {
          set mm(work) "";       # clear
          append mm(work) "break;   # .restart "
        }
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "reparse"} {
        set mm(work) "";       # clear
        append mm(work) $mm(counter); # count 
        # no labelled loops in tcl
        # check accumulator to see if we are in the "lex" block
        # or the "parse" block and adjust the .reparse compilation
        # accordingly.
        if {$mm(work) eq "0"} {
          set mm(work) "";       # clear
          append mm(work) "break;  # .reparse "
        }
        if {$mm(work) eq "1"} {
          set mm(work) "";       # clear
          append mm(work) "continue;   # .reparse "
        }
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      Push;
      Push;
      append mm(work) "error near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script:  \n"
      append mm(work) " misplaced dot '.' (use for AND logic or in .reparse/.restart \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    #---------------------------------
    # Compiling comments so as to transfer them to the java 
    if {$mm(work) eq "comment*command*" || $mm(work) eq "command*comment*" || $mm(work) eq "commandset*comment*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "command*"
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "comment*comment*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "comment*"
      Push;
      continue;   # .reparse 
    }
    # -----------------------
    # negated tokens.
    # This is a new more elegant way to negate a whole set of 
    # tests (tokens) where the negation logic is stored on the 
    # stack, not in the current tape cell. We just add "not" to 
    # the stack token.
    # eg: !\[:alpha:\] !\[a-z\] !\[abcd\] !"abc" !B"abc" !E"xyz"
    #  This format is used to indicate a negative test for 
    #  a brace block. eg: !\[aeiou\] \{ add "< not a vowel"; print; clear; \}
    if {$mm(work) eq "!*quote*" || $mm(work) eq "!*class*" || $mm(work) eq "!*begintext*" || $mm(work) eq "!*endtext*" || $mm(work) eq "!*eof*" || $mm(work) eq "!*tapetest*"} {
      # a simplification: store the token name "quote*/class*/..."
      # in the tape cell corresponding to the "!*" token. 
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"!*" "not"} $mm(work)] }
      
      Push;
      # this was a bug?? a missing ++; ??
      # now get the token-value
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      set mm(work) "";       # clear
      continue;   # .reparse 
    }
    #-----------------------------------------
    # format: E"text" or E'text'
    #  This format is used to indicate a "workspace-ends-with" text before
    #  a brace block.
    if {$mm(work) eq "E*quote*"} {
      set mm(work) "";       # clear
      append mm(work) "endtext*"
      Push;
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {$mm(work) eq "\"\""} {
        # empty argument is an error
        set mm(work) "";       # clear
        append mm(work) "pep script error near line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) " (character "
        append mm(work) $mm(charsRead); # chars 
        append mm(work) "): \n"
        append mm(work) "  empty argument for end-test (E\"\") \n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      set mm(work) "";       # clear
      continue;   # .reparse 
    }
    #-----------------------------------------
    # format: B"sometext" or B'sometext' 
    #   A 'B' preceding some quoted text is used to indicate a 
    #   'workspace-begins-with' test, before a brace block.
    if {$mm(work) eq "B*quote*"} {
      set mm(work) "";       # clear
      append mm(work) "begintext*"
      Push;
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {$mm(work) eq "\"\""} {
        # empty argument is an error
        set mm(work) "";       # clear
        append mm(work) "pep script error near line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) " (character "
        append mm(work) $mm(charsRead); # chars 
        append mm(work) "): \n"
        append mm(work) "  empty argument for begin-test (B\"\") \n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      set mm(work) "";       # clear
      continue;   # .reparse 
    }
    #--------------------------------------------
    # ebnf: command := word, ';' ;
    # formats: "pop; push; clear; print; " etc
    # all commands need to end with a semi-colon except for 
    # .reparse and .restart
    if {$mm(work) eq "word*;*"} {
      set mm(work) "";       # clear
      # check if command requires parameter
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {$mm(work) eq "add" || $mm(work) eq "until" || $mm(work) eq "while" || $mm(work) eq "whilenot" || $mm(work) eq "mark" || $mm(work) eq "go" || $mm(work) eq "escape" || $mm(work) eq "unescape" || $mm(work) eq "delim" || $mm(work) eq "replace"} {
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "'"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "'"
        append mm(work) " << command needs an argument, on line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) " of script.\n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      if {$mm(work) eq "clip"} {
        set mm(work) "";       # clear
        append mm(work) "if \{ \$mm(work) ne \"\" \} \{\n"
        append mm(work) "  set mm(work) \[string range \$mm(work) 0 end-1\]\n"
        append mm(work) "\}; # clip"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "clop"} {
        set mm(work) "";       # clear
        append mm(work) "if \{ \$mm(work) ne \"\" \} \{ \n"
        append mm(work) "  set mm(work) \[string range \$mm(work) 1 end\] \} ; # clop"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "clear"} {
        set mm(work) "";       # clear
        append mm(work) "set mm(work) \"\";       # clear"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "upper"} {
        set mm(work) "";       # clear
        append mm(work) "set mm(work) \[string toupper \$mm(work)\]; # upper"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "lower"} {
        set mm(work) "";       # clear
        append mm(work) "set mm(work) \[string tolower \$mm(work)\]; # lower"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "cap"} {
        set mm(work) "";       # clear
        append mm(work) "set mm(work) \[string totitle \$mm(work)\];   # cap"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "print"} {
        set mm(work) "";       # clear
        # flush doesnt seem necessary
        #add "puts -nonewline \$mm(work); flush stdout; # print"; 
        append mm(work) "puts -nonewline \$mm(work);    # print"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "pop"} {
        set mm(work) "";       # clear
        append mm(work) "Pop;"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "push"} {
        set mm(work) "";       # clear
        append mm(work) "Push;"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "unstack"} {
        set mm(work) "";       # clear
        append mm(work) "while \{\[Pop\]\} \{\};           # unstack "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "stack"} {
        set mm(work) "";       # clear
        append mm(work) "while \{\[Push\]\} \{\};          # stack "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "put"} {
        set mm(work) "";       # clear
        append mm(work) "lset mm(tape) \$mm(cell) \$mm(work);  # put "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "get"} {
        set mm(work) "";       # clear
        append mm(work) "append mm(work) \[lindex \$mm(tape) \$mm(cell)\]; # get"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "swap"} {
        set mm(work) "";       # clear
        # other ways to swap 2 vars, but tricky with list
        # lassign "\$a \$b \$c \$d" b a d c
        # foreach \{x y\} \[list \$y \$x\] \{break\}
        append mm(work) "set s \$mm(work); \n"
        append mm(work) "set mm(work) \[lindex \$mm(tape) \$mm(cell)\]; # swap \n"
        append mm(work) "lset mm(tape) \$mm(cell) \$s;                # swap "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "++"} {
        set mm(work) "";       # clear
        append mm(work) "if \{ \$mm(cell) >= \$mm(size) \} \{ MoreTape; \}\n"
        append mm(work) "incr mm(cell);                             # ++"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "--"} {
        set mm(work) "";       # clear
        append mm(work) "if \{ \$mm(cell) > 0 \} \{ incr mm(cell) -1 \};  # --"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "read"} {
        set mm(work) "";       # clear
        append mm(work) "Read;           # read"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "count"} {
        set mm(work) "";       # clear
        append mm(work) "append mm(work) \$mm(counter); # count "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "a+"} {
        set mm(work) "";       # clear
        append mm(work) "incr mm(counter);  # a+ "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "a-"} {
        set mm(work) "";       # clear
        append mm(work) "incr mm(counter) -1;  # a- "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "zero"} {
        set mm(work) "";       # clear
        append mm(work) "set mm(counter) 0; # zero "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "chars"} {
        set mm(work) "";       # clear
        append mm(work) "append mm(work) \$mm(charsRead); # chars "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "lines"} {
        set mm(work) "";       # clear
        append mm(work) "append mm(work) \$mm(linesRead); # lines "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "nochars"} {
        set mm(work) "";       # clear
        append mm(work) "set mm(charsRead) 0; # nochars "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "nolines"} {
        set mm(work) "";       # clear
        append mm(work) "set mm(linesRead) 0; # nolines "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      # use a labelled loop to quit script.
      if {$mm(work) eq "quit"} {
        set mm(work) "";       # clear
        append mm(work) "exit;"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "state"} {
        set mm(work) "";       # clear
        append mm(work) "State;  # state"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if {$mm(work) eq "write"} {
        set mm(work) "";       # clear
        append mm(work) "WriteToFile;"
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      # just eliminate since it does nothing.
      if {$mm(work) eq "nop"} {
        set mm(work) "";       # clear
        append mm(work) "# nop: no operation "
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      set mm(work) "";       # clear
      append mm(work) "command*"
      Push;
      continue;   # .reparse 
    }
    #-----------------------------------------
    # ebnf: commandset := command , command ;
    if {$mm(work) eq "command*command*" || $mm(work) eq "commandset*command*"} {
      set mm(work) "";       # clear
      append mm(work) "commandset*"
      Push;
      # format the tape attributes. Add the next command on a newline 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      set mm(work) "";       # clear
      continue;   # .reparse 
    }
    #-------------------
    # here we begin to parse "test*" and "ortestset*" and "andtestset*"
    # 
    #-------------------
    # eg: B"abc" \{\} or E"xyz" \{\}
    # transform and markup the different test types
    if {$mm(work) eq "begintext*,*" || $mm(work) eq "endtext*,*" || $mm(work) eq "quote*,*" || $mm(work) eq "class*,*" || $mm(work) eq "eof*,*" || $mm(work) eq "tapetest*,*" || $mm(work) eq "begintext*.*" || $mm(work) eq "endtext*.*" || $mm(work) eq "quote*.*" || $mm(work) eq "class*.*" || $mm(work) eq "eof*.*" || $mm(work) eq "tapetest*.*" || $mm(work) eq "begintext*\{*" || $mm(work) eq "endtext*\{*" || $mm(work) eq "quote*\{*" || $mm(work) eq "class*\{*" || $mm(work) eq "eof*\{*" || $mm(work) eq "tapetest*\{*"} {
      # use glob matching for begin and end tests
      if {[string match {begin*} $mm(work)]} {
        # remove quotes, add \{\}
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "\[string match \{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "*\} \$mm(work)\]"
      }
      if {[string match {end*} $mm(work)]} {
        # remove quotes
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "\[string match \{*"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\} \$mm(work)\]"
      }
      if {[string match {quote*} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "\$mm(work) eq "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      }
      if {[string match {class*} $mm(work)]} {
        # use tcl brace quotes to stop special character problems in patterns.
        set mm(work) "";       # clear
        append mm(work) "\[regexp \{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\} \$mm(work)\]"
      }
      if {[string match {eof*} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "\$mm(eof)"
      }
      if {[string match {tapetest*} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "\$mm(work) eq \[lindex \$mm(tape) \$mm(cell)\]"
      }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "test*"
      Push;
      # the trick below pushes the right token back on the stack.
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "*"
      Push;
      continue;   # .reparse 
    }
    #-------------------
    # negated tests
    # eg: !B"xyz \{\} !(eof) \{\} !(==) \{\}
    #     !E"xyz" \{\} 
    #     !"abc" \{\}
    #     !\[a-z\] \{\}
    if {$mm(work) eq "notbegintext*,*" || $mm(work) eq "notendtext*,*" || $mm(work) eq "notquote*,*" || $mm(work) eq "notclass*,*" || $mm(work) eq "noteof*,*" || $mm(work) eq "nottapetest*,*" || $mm(work) eq "notbegintext*.*" || $mm(work) eq "notendtext*.*" || $mm(work) eq "notquote*.*" || $mm(work) eq "notclass*.*" || $mm(work) eq "noteof*.*" || $mm(work) eq "nottapetest*.*" || $mm(work) eq "notbegintext*\{*" || $mm(work) eq "notendtext*\{*" || $mm(work) eq "notquote*\{*" || $mm(work) eq "notclass*\{*" || $mm(work) eq "noteof*\{*" || $mm(work) eq "nottapetest*\{*"} {
      if {[string match {notbegin*} $mm(work)]} {
        # remove quotes, add \{\}
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "!\[string match "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "* \$mm(work)\] "
      }
      if {[string match {notend*} $mm(work)]} {
        # remove quotes, add \{\}
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "!\[string match *"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) " \$mm(work)\] "
      }
      if {[string match {notquote*} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "\$mm(work) ne "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      }
      if {[string match {notclass*} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "!\[regexp \{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\} \$mm(work)\]"
      }
      if {[string match {noteof*} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "!\$mm(eof)"
      }
      if {[string match {nottapetest*} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "\$mm(work) ne \[lindex \$mm(tape) \$mm(cell)\]"
      }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "test*"
      Push;
      # the trick below pushes the right token back on the stack.
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "*"
      Push;
      continue;   # .reparse 
    }
    #-------------------
    # 3 tokens
    #-------------------
    Pop;
    #-----------------------------
    # some 3 token errors!!!
    # not a comprehensive list of 3 token errors
    if {$mm(work) eq "\{*quote*;*" || $mm(work) eq "\{*begintext*;*" || $mm(work) eq "\{*endtext*;*" || $mm(work) eq "\{*class*;*" || $mm(work) eq "commandset*quote*;*" || $mm(work) eq "command*quote*;*"} {
      Push;
      Push;
      Push;
      append mm(work) "\[pep error\]\n invalid syntax near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ")"
      append mm(work) " of script (misplaced semicolon?) \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    # to simplify subsequent tests, transmogrify a single command
    # to a commandset (multiple commands).
    if {$mm(work) eq "\{*command*\}*"} {
      set mm(work) "";       # clear
      append mm(work) "\{*commandset*\}*"
      Push;
      Push;
      Push;
      continue;   # .reparse 
    }
    # errors! mixing AND and OR concatenation
    if {$mm(work) eq ",*andtestset*\{*" || $mm(work) eq ".*ortestset*\{*"} {
      # push the tokens back to make debugging easier
      Push;
      Push;
      Push;
      append mm(work) " error: mixing AND (.) and OR (,) concatenation in \n"
      append mm(work) " in pep script near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ") \n"
      append mm(work) " " 
      append mm(work) "\n  For example:" 
      append mm(work) "\n     B\".\".!E\"/\".\[abcd./\] \{ print; \}  # Correct!" 
      append mm(work) "\n     B\".\".!E\"/\",\[abcd./\] \{ print; \}  # Error! \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    #--------------------------------------------
    # ebnf: command := keyword , quoted-text , ";" ;
    # format: add "text";
    if {$mm(work) eq "word*quote*;*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {$mm(work) eq "replace"} {
        # error 
        append mm(work) "< command requires 2 parameters, not 1 \n"
        append mm(work) "near line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) " of script. \n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      # check whether argument is single character, otherwise
      # throw and error
      if {$mm(work) eq "escape" || $mm(work) eq "unescape" || $mm(work) eq "while" || $mm(work) eq "whilenot"} {
        # This is trickier than I thought it would be.
        set mm(work) "";       # clear
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        # check that arg not empty, (but an empty quote is ok 
        # for the second arg of 'replace'
        if {$mm(work) eq "\"\""} {
          set mm(work) "";       # clear
          append mm(work) "\[pep error\] near line "
          append mm(work) $mm(linesRead); # lines 
          append mm(work) " (or char "
          append mm(work) $mm(charsRead); # chars 
          append mm(work) "): \n"
          append mm(work) "  command '"
          append mm(work) [lindex $mm(tape) $mm(cell)]; # get
          append mm(work) "\' cannot have an empty argument (\"\") \n"
          puts -nonewline $mm(work);    # print
          exit;
        }
        # quoted text has the quotes still around it.
        # also handle escape characters like \n \r etc
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        # B "\\" \{ clip; \} 
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if {$mm(work) ne ""} {
          set mm(work) "";       # clear
          append mm(work) "Pep script error near line "
          append mm(work) $mm(linesRead); # lines 
          append mm(work) " (character "
          append mm(work) $mm(charsRead); # chars 
          append mm(work) "): \n"
          append mm(work) "  command '"
          append mm(work) [lindex $mm(tape) $mm(cell)]; # get
          append mm(work) "' takes only a single character argument. \n"
          puts -nonewline $mm(work);    # print
          exit;
        }
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      }
      if {$mm(work) eq "mark"} {
        set mm(work) "";       # clear
        append mm(work) "lset mm(marks) \$mm(cell) "
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) "; # mark"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "go"} {
        set mm(work) "";       # clear
        # or use tcls lsearch here.
        append mm(work) "# go\n"
        append mm(work) "set ii \[lsearch -exact \$mm(marks) "
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) "\] \n"
        append mm(work) "if \{\$ii >= 0\} \{ set mm(cell) \$ii \} "
        append mm(work) "else \{ puts \"Mark not found!\"; exit; \} \n"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "delim"} {
        set mm(work) "";       # clear
        # only the first character of the delimiter argument is used. 
        append mm(work) "set mm(delimiter) "
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) "; # delim "
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "add"} {
        set mm(work) "";       # clear
        append mm(work) "append mm(work) "
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        # handle multiline text
        # tcl can handle multiline text but I will leave this
        # anyway because of indenting issues.
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\" \nappend mm(work) \"\\n"} $mm(work)] }
        
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "while"} {
        set mm(work) "";       # clear
        append mm(work) "# while \n"
        append mm(work) "while \{\$mm(peep) eq "
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) "\} \{  \n"
        append mm(work) "  if \{\$mm(eof)\} \{ break; \} Read; \} "
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "whilenot"} {
        set mm(work) "";       # clear
        append mm(work) "# whilenot \n"
        append mm(work) "while \{\$mm(peep) ne "
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) "\} \{  \n"
        append mm(work) "  if \{\$mm(eof)\} \{ break; \} Read \}"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "until"} {
        set mm(work) "";       # clear
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        # error until cannot have empty argument
        if {$mm(work) eq "\"\""} {
          set mm(work) "";       # clear
          append mm(work) "Pep script error near line "
          append mm(work) $mm(linesRead); # lines 
          append mm(work) " (character "
          append mm(work) $mm(charsRead); # chars 
          append mm(work) "): \n"
          append mm(work) " empty argument for 'until' \n"
          append mm(work) " " 
          append mm(work) "\n   For example:" 
          append mm(work) "\n     until '.txt'; until \">\";    # correct   " 
          append mm(work) "\n     until '';  until \"\";        # errors! \n"
          puts -nonewline $mm(work);    # print
          exit;
        }
        # remove quotes
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "Until \{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # handle multiline argument
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\\n"} $mm(work)] }
        
        append mm(work) "\};"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      # but hard code escape here!
      if {$mm(work) eq "escape"} {
        set mm(work) "";       # clear
        # use "string map"
        # remove quotes from escape argument
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "set mm(work) \[string map \{\""
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\" \"\\\\"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\"\} \$mm(work)\]"
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      # could just use replace instead ?
      # but unescape should probably 'walk the string' to 
      # work out what is really escaped
      if {$mm(work) eq "unescape"} {
        set mm(work) "";       # clear
        # remove quotes from escape argument
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "set mm(work) \[string map \{\"\\"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\" \""
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\"\} \$mm(work)\]"
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      # error, superfluous argument
      append mm(work) ": command does not take an argument \n"
      append mm(work) "near line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " of script. \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      #state
      exit;
    }
    #----------------------------------
    # format: "while \[:alpha:\] ;" or whilenot \[a-z\] ;
    if {$mm(work) eq "word*class*;*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {$mm(work) eq "while"} {
        set mm(work) "";       # clear
        append mm(work) "# while  \n"
        append mm(work) "while \{\[regexp \{"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) "\} \$mm(peep)\]\} \{ if \{\$mm(eof)\} \{ break; \} Read \}"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      if {$mm(work) eq "whilenot"} {
        set mm(work) "";       # clear
        append mm(work) "# whilenot  \n"
        append mm(work) "while \{!\[regexp \{"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) "\} \$mm(peep)\]\} \{ if \{\$mm(eof)\} \{ break; \} Read \}"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      # error 
      append mm(work) " < command cannot have a class argument \n"
      append mm(work) "line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) ": error in script \n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    # arrange the parse> label loops
    if {$mm(eof)} {
      if {$mm(work) eq "commandset*parse>*commandset*" || $mm(work) eq "command*parse>*commandset*" || $mm(work) eq "commandset*parse>*command*" || $mm(work) eq "command*parse>*command*"} {
        set mm(work) "";       # clear
        # indent both code blocks
        append mm(work) "  "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\n  "} $mm(work)] }
        
        # change .restart code before parse> label
        # this make .restart work both before, after and without a 
        # parse> label
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"continue; # restart" "break; # restart"} $mm(work)] }
        
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) "  "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\n  "} $mm(work)] }
        
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        # add a block so that .reparse works before the parse> label.
        # but no labelled loops in tcl
        append mm(work) "\n# lex block \n"
        append mm(work) "while true \{ \n"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n  break;\n\}\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) "if \{\$restart == true\} \{ set restart false; continue; \}\n"
        # indent code block
        # add "  "; get; replace "\n" "\n  "; put; clear;
        # tcl doesnt support labelled loops
        # add "parse: \n";
        append mm(work) "\n# parse block \n"
        append mm(work) "while true \{  \n"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n  break; \n"
        append mm(work) "\}\n"
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "commandset*"
        Push;
        continue;   # .reparse 
      }
    }
    # -------------------------------
    # 4 tokens
    # -------------------------------
    Pop;
    #-------------------------------------
    # bnf:     command := replace , quote , quote , ";" ;
    # example:  replace "and" "AND" ; 
    if {$mm(work) eq "word*quote*quote*;*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {$mm(work) eq "replace"} {
        #---------------------------
        # a command plus 2 arguments, eg replace "this" "that"
        # the empty string test is not really necessary here.
        # note!
        set mm(work) "";       # clear
        append mm(work) "# replace \n"
        append mm(work) "if \{\$mm(work) ne \"\"\} \{ \n"
        append mm(work) "set mm(work) \[string map \{"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) " "
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\} \$mm(work)\] \}\n"
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "command*"
        Push;
        continue;   # .reparse 
      }
      append mm(work) "pep script error on line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " (character "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) "): \n"
      append mm(work) "  command does not take 2 quoted arguments. \n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    #-------------------------------------
    # format: begin \{ #* commands *# \}
    # "begin" blocks which are only executed once (they
    # will are assembled before the "start:" label. They must come before
    # all other commands.
    # "begin*\{*command*\}*",
    if {$mm(work) eq "begin*\{*commandset*\}*"} {
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "beginblock*"
      Push;
      continue;   # .reparse 
    }
    # -------------
    # parses and compiles concatenated tests
    # eg: 'a',B'b',E'c',\[def\],\[:space:\],\[g-k\] \{ ...
    # these 2 tests should be all that is necessary
    if {$mm(work) eq "test*,*ortestset*\{*" || $mm(work) eq "test*,*test*\{*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " || "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "ortestset*\{*"
      Push;
      Push;
      continue;   # .reparse 
    }
    # dont mix AND and OR concatenations 
    # -------------
    # AND logic 
    # parses and compiles concatenated AND tests
    # eg: 'a',B'b',E'c',\[def\],\[:space:\],\[g-k\] \{ ...
    # it is possible to elide this block with the negated block
    # for compactness but maybe readability is not as good.
    # negated tests can be chained with non negated tests.
    # eg: B'http' . !E'.txt' \{ ... \}
    if {$mm(work) eq "test*.*andtestset*\{*" || $mm(work) eq "test*.*test*\{*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " && "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "andtestset*\{*"
      Push;
      Push;
      continue;   # .reparse 
    }
    #-------------------------------------
    # we should not have to check for the \{*command*\}* pattern
    # because that has already been transformed to \{*commandset*\}*
    if {$mm(work) eq "test*\{*commandset*\}*" || $mm(work) eq "andtestset*\{*commandset*\}*" || $mm(work) eq "ortestset*\{*commandset*\}*"} {
      set mm(work) "";       # clear
      # indent the java code for readability
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) "  "
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\n" "\n  "} $mm(work)] }
      
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      append mm(work) "if \{"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\} \{\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n\}"
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "command*"
      Push;
      # always reparse/compile
      continue;   # .reparse 
    }
    # -------------
    # multi-token end-of-stream errors
    # not a comprehensive list of errors...
    if {$mm(eof)} {
      if {[string match {*begintext*} $mm(work)] || [string match {*endtext*} $mm(work)] || [string match {*test*} $mm(work)] || [string match {*ortestset*} $mm(work)] || [string match {*andtestset*} $mm(work)]} {
        append mm(work) "  Error near end of script at line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) ". Test with no brace block? \n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      if {[string match {*quote*} $mm(work)] || [string match {*class*} $mm(work)] || [string match {*word*} $mm(work)]} {
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "Error at end of pep script near line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) ": missing semi-colon? \n"
        append mm(work) "Parse stack: "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      # A begin block with no other commands is not really an
      # error...
      if {$mm(work) eq "beginblock*"} {
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "" 
        append mm(work) "\n   Pep script error: begin block with no other commands." 
        append mm(work) "\n   Follow the begin block with other script commands. Eg:" 
        append mm(work) "\n     begin \{ add \"starting script...\"; print; clear; \}" 
        append mm(work) "\n     read; print; clear;" 
        append mm(work) "\n   Or use \"nop;\" after the begin block \n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      if {[string match {*\{*} $mm(work)] || [string match {*\}*} $mm(work)] || [string match {*;*} $mm(work)] || [string match {*,*} $mm(work)] || [string match {*.*} $mm(work)] || [string match {*!*} $mm(work)] || [string match {*B*} $mm(work)] || [string match {*E*} $mm(work)]} {
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "Error: misplaced terminal character at end of script! (line "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) "). \n"
        append mm(work) "Parse stack: "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
    }
    # put the 4 (or less) tokens back on the stack
    Push;
    Push;
    Push;
    Push;
    if {$mm(eof)} {
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      # create the virtual machine object code and save it
      # somewhere on the tape.
      append mm(work) "#!/usr/bin/tclsh" 
      append mm(work) "\n" 
      append mm(work) "\n# code generated by \"translate.tcl.pss\" a pep script" 
      append mm(work) "\n# see bumble.sf.net/books/pars/" 
      append mm(work) "\n#import sys    # " 
      append mm(work) "\n" 
      append mm(work) "\n  # make a new machine. Standard tcl doesnt have objects" 
      append mm(work) "\n  # so I will use an associative array, instead." 
      append mm(work) "\n  #array set mm \{" 
      append mm(work) "\n  #  eof false     # end of stream reached?" 
      append mm(work) "\n  #  charsRead 0   # how many chars already read" 
      append mm(work) "\n  #  linesRead 1   # how many lines already read" 
      append mm(work) "\n  #  escape \"\\\\\"" 
      append mm(work) "\n  #  delimiter \"*\" # push/pop delimiter (default \"*\")" 
      append mm(work) "\n  #  counter 0     # a counter for anything" 
      append mm(work) "\n  #  work \"\"       # the workspace" 
      append mm(work) "\n  #  stack \{\}    # stack for parse tokens " 
      append mm(work) "\n  #  cell 0      # current tape cell" 
      append mm(work) "\n  #  size 100    # the initial tape/marks list size" 
      append mm(work) "\n  #  tape \{\}     # a list of attribute for tokens " 
      append mm(work) "\n  #  marks \{\}    # marked tape cells" 
      append mm(work) "\n  #  peep \[read stdin 1\] " 
      append mm(work) "\n  #\}" 
      append mm(work) "\n" 
      append mm(work) "\n  # make a new machine. Standard tcl doesnt have objects" 
      append mm(work) "\n  # so I will use an associative array, instead." 
      append mm(work) "\n  array set mm \{" 
      append mm(work) "\n    eof false     " 
      append mm(work) "\n    charsRead 0  " 
      append mm(work) "\n    linesRead 1 " 
      append mm(work) "\n    escape \"\\\\\"" 
      append mm(work) "\n    delimiter \"*\" " 
      append mm(work) "\n    counter 0    " 
      append mm(work) "\n    work \"\"     " 
      append mm(work) "\n    stack \{\}   " 
      append mm(work) "\n    cell 0    " 
      append mm(work) "\n    size 0 " 
      append mm(work) "\n    tape \{\}  " 
      append mm(work) "\n    marks \{\}" 
      append mm(work) "\n    peep \{\} " 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # Adds more elements to the tape and marks lists " 
      append mm(work) "\n  proc MoreTape \{\} \{ " 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    for \{set ii 0\} \{\$ii < 100\} \{incr ii\} \{ " 
      append mm(work) "\n      lappend mm(tape) \"\"; lappend mm(marks) \"\";" 
      append mm(work) "\n    \}" 
      append mm(work) "\n    incr mm(size) 100" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # initialises a machine  " 
      append mm(work) "\n  proc Init \{\} \{ " 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    set mm(peep) \[ read stdin 1 \]" 
      append mm(work) "\n    # or Read;" 
      append mm(work) "\n    MoreTape;" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # read one character from the input stream and " 
      append mm(work) "\n  #    update the machine." 
      append mm(work) "\n  proc Read \{\} \{ " 
      append mm(work) "\n    # use upvar eg" 
      append mm(work) "\n    # upvar \$machine mm" 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    if \{ \$mm(eof) \} \{ exit \}" 
      append mm(work) "\n    incr mm(charsRead)" 
      append mm(work) "\n    # increment lines" 
      append mm(work) "\n    if \{ \$mm(peep) eq \"\\n\" \} \{ incr mm(linesRead) \}" 
      append mm(work) "\n    append mm(work) \$mm(peep)" 
      append mm(work) "\n    set mm(peep) \[ read stdin 1 \]" 
      append mm(work) "\n    if \{\[eof stdin\]\} \{ set mm(eof) true; set mm(peep) -1 \}" 
      append mm(work) "\n  \} " 
      append mm(work) "\n" 
      append mm(work) "\n  # increment tape pointer by one: trivial method? But need" 
      append mm(work) "\n  # to increase tape/marks size if exceeded" 
      append mm(work) "\n  proc Increment \{\} \{ global mm; incr mm(cell) \} " 
      append mm(work) "\n" 
      append mm(work) "\n  # remove escape character: trivial method ?" 
      append mm(work) "\n  proc UnescapeChar \{c\} \{" 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    #if \{ \$mm(work) ne \"\" \} \$mm(work = \$mm(work.replace(\"\\\\\"+c, c)" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # add escape character : trivial" 
      append mm(work) "\n  proc EscapeChar \{c\} \{" 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    #if \{ \$mm(work) ne \"\" \} \{ \$mm(work = \$mm(work.replace(c, \"\\\\\"+c) \}" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # pop the first token from the stack into the workspace */" 
      append mm(work) "\n  proc Pop \{\} \{ " 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    if \{\[llength \$mm(stack)\] == 0\} \{ return false \}" 
      append mm(work) "\n    # prepend last stack item, and delete the item" 
      append mm(work) "\n    set mm(work) \"\[lindex \$mm(stack) end\]\$mm(work)\"" 
      append mm(work) "\n    set mm(stack) \[lrange \$mm(stack) 0 \[expr \[llength \$mm(stack)\]-2\]\] " 
      append mm(work) "\n    if \{\$mm(cell) > 0\} \{ incr mm(cell) -1 \}" 
      append mm(work) "\n    return true" 
      append mm(work) "\n  \}" 
      append mm(work) "\n  " 
      append mm(work) "\n  # push the first token from the workspace to the stack " 
      append mm(work) "\n  proc Push \{\} \{" 
      append mm(work) "\n    # lappend list \$value" 
      append mm(work) "\n    # dont increment the tape pointer on an empty push" 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    if \{ \$mm(work) eq \"\" \} \{ return false \}" 
      append mm(work) "\n    # need to get this from the delimiter." 
      append mm(work) "\n    set firstdelim \[string first \$mm(delimiter) \$mm(work)\]" 
      append mm(work) "\n    if \{\$firstdelim == -1\} \{" 
      append mm(work) "\n      lappend mm(stack) \$mm(work)" 
      append mm(work) "\n      set mm(work) \"\"" 
      append mm(work) "\n      incr mm(cell) 1" 
      append mm(work) "\n      # a hack because \"stack\" hangs otherwise (never returns false)" 
      append mm(work) "\n      return false" 
      append mm(work) "\n      #return true" 
      append mm(work) "\n    \}" 
      append mm(work) "\n    lappend mm(stack) \[string range \$mm(work) 0 \$firstdelim\]" 
      append mm(work) "\n    set mm(work) \[string range \$mm(work) \[expr \{\$firstdelim+1\}\] end\]" 
      append mm(work) "\n    incr mm(cell) 1" 
      append mm(work) "\n    return true" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # a helper function" 
      append mm(work) "\n  proc IsEscaped \{suffix\} \{" 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    # remove suffix" 
      append mm(work) "\n    set count 0" 
      append mm(work) "\n    set last \[expr \{\[string last \$suffix \$mm(work)\]-1\}\]" 
      append mm(work) "\n    set new \[string range \$mm(work) 0 \$last\]" 
      append mm(work) "\n    # now count trailing escape chars" 
      append mm(work) "\n    while \{\[string index \$new end\] eq \$mm(escape)\} \{" 
      append mm(work) "\n      set last \[expr \{\[string last \$mm(escape) \$new\]-1\}\]" 
      append mm(work) "\n      set new \[string range \$new 0 \$last\]" 
      append mm(work) "\n      incr count" 
      append mm(work) "\n    \}" 
      append mm(work) "\n    # puts count=\$count" 
      append mm(work) "\n    if \{ \$count == 1 \} \{ return true \}" 
      append mm(work) "\n    if \{\[expr \{(\$count % 2) == 0\}\]\} \{ return false \} else \{ return true \}" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # reads the input stream until the workspace end with text " 
      append mm(work) "\n  proc Until \{suffix\} \{ " 
      append mm(work) "\n    # read at least one character" 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    if \{ \$mm(eof) \} \{ return \}" 
      append mm(work) "\n    Read;" 
      append mm(work) "\n    while true \{ " 
      append mm(work) "\n      if \{\$mm(eof)\} \{ return \}" 
      append mm(work) "\n      # this must count trailing escapes" 
      append mm(work) "\n      if \{\[string match *\$suffix \$mm(work)\] && !\[IsEscaped \$suffix\]\} \{ return \}" 
      append mm(work) "\n      Read;" 
      append mm(work) "\n    \}" 
      append mm(work) "\n  \}  " 
      append mm(work) "\n" 
      append mm(work) "\n  # maybe not required " 
      append mm(work) "\n  proc Swap \{\} \{ " 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    set s \$mm(work)" 
      append mm(work) "\n    set mm(work) \$mm(tape)\[\$mm(cell)\]" 
      append mm(work) "\n    # could be a problem if \$s has spaces in it. (becomes a list)" 
      append mm(work) "\n    lset mm(tape) \$mm(cell) \$s" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  proc WriteToFile \{\} \{ " 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    set f \[open sav.pp w 0600\]  " 
      append mm(work) "\n    puts \$f \$mm(work)" 
      append mm(work) "\n    close \$f" 
      append mm(work) "\n  \}" 
      append mm(work) "\n" 
      append mm(work) "\n  # useful for debugging, the \"state\" command" 
      append mm(work) "\n  proc State \{\} \{ " 
      append mm(work) "\n    global mm" 
      append mm(work) "\n    puts \"---------- Machine State --------------\";" 
      append mm(work) "\n    puts -nonewline \" Stack\\\[\[join \$mm(stack) \{\}\]\\\] Work\\\[\$mm(work)\\\] \";" 
      append mm(work) "\n    puts \"Peep\\\[\$mm(peep)\\\]\";" 
      append mm(work) "\n    puts -nonewline \" Acc:\$mm(counter) Esc:\$mm(escape) \";" 
      append mm(work) "\n    puts -nonewline \"Delim:\$mm(delimiter) Chars:\$mm(charsRead) \";" 
      append mm(work) "\n    puts \"Lines:\$mm(linesRead)\";" 
      append mm(work) "\n    puts \"---------- Tape (size:\$mm(size))  --------------\";" 
      append mm(work) "\n    set ii 0" 
      append mm(work) "\n    while \{ \$ii < 7 \} \{" 
      append mm(work) "\n      puts -nonewline \"  \$ii\";" 
      append mm(work) "\n      if \{ \$ii == \$mm(cell) \} \{ " 
      append mm(work) "\n        puts -nonewline \"> \"" 
      append mm(work) "\n      \} else \{ puts -nonewline \"  \" \}" 
      append mm(work) "\n      # display marks" 
      append mm(work) "\n      if \{ \[lindex \$mm(marks) \$ii\] ne \"\" \} \{ " 
      append mm(work) "\n        puts -nonewline \"\\\"\[lindex \$mm(marks) \$ii\]\\\" \"" 
      append mm(work) "\n      \} else \{ puts -nonewline \". \" \}" 
      append mm(work) "\n" 
      append mm(work) "\n      puts \"\\\[\[lindex \$mm(tape) \$ii\]\\\]\";" 
      append mm(work) "\n      incr ii" 
      append mm(work) "\n    \}" 
      append mm(work) "\n  \}" 
      append mm(work) "\n  # end of tcl pep Machine \"class\" (array) definition" 
      append mm(work) "\n" 
      append mm(work) "\n  # a flag var to make .restart work in run-once loops" 
      append mm(work) "\n  set restart false" 
      append mm(work) "\n  # initialise the machine" 
      append mm(work) "\n  Init;" 
      append mm(work) "\n \n"
      # save the code in the current tape cell
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      #---------------------
      # check if the script correctly parsed (there should only
      # be one or two tokens on the stack, namely "commandset*" or "command*").
      # or beginblock commandset
      Pop;
      Pop;
      if {$mm(work) eq "commandset*" || $mm(work) eq "command*"} {
        set mm(work) "";       # clear
        # indent generated code (6 spaces) for readability.
        append mm(work) "  "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\n  "} $mm(work)] }
        
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        # restore the java preamble from the tape
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        #add 'script: \n';
        append mm(work) "while !\$mm(eof) \{ \n"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # end block marker 
        append mm(work) "\n\}\n"
        append mm(work) "# end of generated code\n"
        # put a copy of the final compilation into the tapecell
        # so it can be inspected interactively.
        lset mm(tape) $mm(cell) $mm(work);  # put 
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      if {$mm(work) eq "beginblock*commandset*" || $mm(work) eq "beginblock*command*"} {
        set mm(work) "";       # clear
        # indentation not needed here 
        #add ""; get; 
        #replace "\n" "\n"; put; clear; 
        # indent main code for readability.
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) "  "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\n  "} $mm(work)] }
        
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        # get tcl preamble from tape
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        # a labelled loop for "quit" (but quit can just exit?)
        #add "script: \n";
        append mm(work) "while !\$mm(eof) \{ \n"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # end block marker required 
        append mm(work) "\n\}\n"
        append mm(work) "# end of generated code\n"
        # put a copy of the final compilation into the tapecell
        # for interactive debugging.
        lset mm(tape) $mm(cell) $mm(work);  # put 
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        exit;
      }
      Push;
      Push;
      # try to explain some more errors
      while {[Pop]} {};           # unstack 
      if {[string match {parse>*} $mm(work)]} {
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "\[error\] pep syntax error:\n"
        append mm(work) "  The parse> label cannot be the 1st item \n"
        append mm(work) "  of a script \n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "After compiling with 'translate.tcl.pss' (at EOF): \n "
      append mm(work) "  parse error in input script. \n "
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      # unstack; put; clear;
      append mm(work) "Parse stack: "
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      append mm(work) "   * debug script "
      append mm(work) "   >> pep -If script -i 'some input' \n "
      append mm(work) "   *  debug compilation. \n "
      append mm(work) "   >> pep -Ia asm.pp script' \n "
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    # not eof
    # there is an implicit .restart command here (jump start)
    break; 
  }
  
}
# end of generated code
