#!/usr/bin/tclsh

# code generated by "translate.tcl.pss" a pep script
# see bumble.sf.net/books/pars/
#import sys    # 

  # make a new machine. Standard tcl doesnt have objects
  # so I will use an associative array, instead.
  #array set mm {
  #  eof false     # end of stream reached?
  #  charsRead 0   # how many chars already read
  #  linesRead 1   # how many lines already read
  #  escape "\\"
  #  delimiter "*" # push/pop delimiter (default "*")
  #  counter 0     # a counter for anything
  #  work ""       # the workspace
  #  stack {}    # stack for parse tokens 
  #  cell 0      # current tape cell
  #  size 100    # the initial tape/marks list size
  #  tape {}     # a list of attribute for tokens 
  #  marks {}    # marked tape cells
  #  peep [read stdin 1] 
  #}

  # make a new machine. Standard tcl doesnt have objects
  # so I will use an associative array, instead.
  array set mm {
    eof false     
    charsRead 0  
    linesRead 1 
    escape "\\"
    delimiter "*" 
    counter 0    
    work ""     
    stack {}   
    cell 0    
    size 0 
    tape {}  
    marks {}
    peep {} 
  }

  # Adds more elements to the tape and marks lists 
  proc MoreTape {} { 
    global mm
    for {set ii 0} {$ii < 100} {incr ii} { 
      lappend mm(tape) ""; lappend mm(marks) "";
    }
    incr mm(size) 100
  }

  # initialises a machine  
  proc Init {} { 
    global mm
    set mm(peep) [ read stdin 1 ]
    # or Read;
    MoreTape;
  }

  # read one character from the input stream and 
  #    update the machine.
  proc Read {} { 
    # use upvar eg
    # upvar $machine mm
    global mm
    if { $mm(eof) } { exit }
    incr mm(charsRead)
    # increment lines
    if { $mm(peep) eq "\n" } { incr mm(linesRead) }
    append mm(work) $mm(peep)
    set mm(peep) [ read stdin 1 ]
    if {[eof stdin]} { set mm(eof) true; set mm(peep) -1 }
  } 

  # increment tape pointer by one: trivial method? But need
  # to increase tape/marks size if exceeded
  proc Increment {} { global mm; incr mm(cell) } 

  # remove escape character: trivial method ?
  proc UnescapeChar {c} {
    global mm
    #if { $mm(work) ne "" } $mm(work = $mm(work.replace("\\"+c, c)
  }

  # add escape character : trivial
  proc EscapeChar {c} {
    global mm
    #if { $mm(work) ne "" } { $mm(work = $mm(work.replace(c, "\\"+c) }
  }

  # pop the first token from the stack into the workspace */
  proc Pop {} { 
    global mm
    if {[llength $mm(stack)] == 0} { return false }
    # prepend last stack item, and delete the item
    set mm(work) "[lindex $mm(stack) end]$mm(work)"
    set mm(stack) [lrange $mm(stack) 0 [expr [llength $mm(stack)]-2]] 
    if {$mm(cell) > 0} { incr mm(cell) -1 }
    return true
  }
  
  # push the first token from the workspace to the stack 
  proc Push {} {
    # lappend list $value
    # dont increment the tape pointer on an empty push
    global mm
    if { $mm(work) eq "" } { return false }
    # need to get this from the delimiter.
    set firstdelim [string first $mm(delimiter) $mm(work)]
    if {$firstdelim == -1} {
      lappend mm(stack) $mm(work)
      set mm(work) ""
      incr mm(cell) 1
      # a hack because "stack" hangs otherwise (never returns false)
      return false
      #return true
    }
    lappend mm(stack) [string range $mm(work) 0 $firstdelim]
    set mm(work) [string range $mm(work) [expr {$firstdelim+1}] end]
    incr mm(cell) 1
    return true
  }

  # a helper function
  proc CountEscapes {suffix} {
    if {$mm(work)} {}
  }

  # a helper function
  proc CountEscaped {suffix} {
  }

  # reads the input stream until the workspace end with text 
  proc Until {suffix} { 
    # read at least one character
    global mm
    if { $mm(eof) } { return }
    Read;
    while true { 
      if {$mm(eof)} { return }
      # no! check! this must count trailing escapes
      if {[string match *$suffix $mm(work)] && 
           ![string match *"$mm(escape)$suffix" $mm(work)] } { return }
      Read;
    }
  }  

  # maybe not required 
  proc Swap {} { 
    global mm
    set s $mm(work)
    set mm(work) $mm(tape)[$mm(cell)]
    # could be a problem if $s has spaces in it. (becomes a list)
    lset mm(tape) $mm(cell) $s
  }

  proc WriteToFile {} { 
    global mm
    set f [open sav.pp w 0600]  
    puts $f $mm(work)
    close $f
  }

  # useful for debugging, the "state" command
  proc State {} { 
    global mm
    puts "---------- Machine State --------------";
    puts -nonewline " Stack\[[join $mm(stack) {}]\] Work\[$mm(work)\] ";
    puts "Peep\[$mm(peep)\]";
    puts -nonewline " Acc:$mm(counter) Esc:$mm(escape) ";
    puts -nonewline "Delim:$mm(delimiter) Chars:$mm(charsRead) ";
    puts "Lines:$mm(linesRead)";
    puts "---------- Tape (size:$mm(size))  --------------";
    set ii 0
    while { $ii < 7 } {
      puts -nonewline "  $ii";
      if { $ii == $mm(cell) } { 
        puts -nonewline "> "
      } else { puts -nonewline "  " }
      # display marks
      if { [lindex $mm(marks) $ii] ne "" } { 
        puts -nonewline "\"[lindex $mm(marks) $ii]\" "
      } else { puts -nonewline ". " }

      puts "\[[lindex $mm(tape) $ii]\]";
      incr ii
    }
  }
  # end of tcl pep Machine "class" (array) definition

  # initialise the machine
  Init;
 
# create a dummy newline so that doc structures work even
# on the first line of the file/stream.
append mm(work) "nl*"
Push;
while !$mm(eof) { 
  
  # lex block 
  while true { 
    Read;           # read
    if {![regexp {^[[:space:]]+$} $mm(work)]} {
      # whilenot  
      while {![regexp {^[[:space:]]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "word*"
      Push;
      break;  # .reparse 
    }
    # keep leading space in newline token?
    if {[regexp {^[\n]+$} $mm(work)]} {
      # while  
      while {[regexp {^[ ]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "nl*"
      Push;
      break;  # .reparse 
    }
    if {[regexp {^[\r\t ]+$} $mm(work)]} {
      set mm(work) "";       # clear
      break;   # .restart but behaving like .reparse !
    }
    break;
  }
  
  # parse block 
  while true {  
    # for debugging
    #add "line "; lines; add " char "; chars; add ": "; print; clear; 
    #unstack; print; stack; add "\n"; print; clear;
    # -------------
    # 1 token
    Pop;
    if {$mm(work) eq "nl*"} {
      # nop: no operation 
    }
    # here we classify words into other tokens
    if {$mm(work) eq "word*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # no numbers in headings!
      if {[regexp {^[A-Z]+$} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "uuword*"
        Push;
        continue;   # .reparse 
      }
      # at least three --- on a newline marks a code block start
      if {[string match {---*} $mm(work)] && [regexp {^[\-]+$} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "---*"
        Push;
        continue;   # .reparse 
      }
      # >> on a newline marks a code block start
      if {$mm(work) eq ">>"} {
        append mm(work) "*"
        Push;
        continue;   # .reparse 
      }
      # star on newline marks emphasis, list or code description 
      if {$mm(work) eq "*"} {
        set mm(work) "";       # clear
        append mm(work) "star*"
        Push;
        continue;   # .reparse 
      }
      # subheading marker
      if {[string match {....*} $mm(work)] && [regexp {^[.]+$} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "4dots*"
        Push;
        continue;   # .reparse 
      }
      # need to escape % # } \ and others
      # & % $ # _ { } ~ ^ \
          # \textasciitilde, \textasciicircum, and \textbackslash
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\\" "\\textbackslash "} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"&" "\\&"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"%" "\\%"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\$" "\\\$"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"#" "\\#"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"_" "\\_"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\{" "\\\{"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\}" "\\\}"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"~" "\\textasciitilde"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"^" "\\textasciicircum"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"LaTeX" "\\LaTeX\{\}"} $mm(work)] }
      
      #replace '\\n' "\\textbackslash n";
      #replace '\\f' "\\textbackslash f";
      #replace '\\r' "\\textbackslash r";
      #replace '\\t' "\\textbackslash t";
      lset mm(tape) $mm(cell) $mm(work);  # put 
      # urls, not so important for LaTex but anyway 
      # dont really need tokens because we can render immediately
      # we could maybe render them as footnotes
      if {[string match {http://*} $mm(work)] || [string match {https://*} $mm(work)] || [string match {www.*} $mm(work)] || [string match {ftp://*} $mm(work)] || [string match {sftp://*} $mm(work)]} {
        # clear; add "url*"; push; .reparse
        # render as fixed pitch font
        set mm(work) "";       # clear
        append mm(work) "\\url\{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\}"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
      }
      # filenames
      if {[string match {*/} $mm(work)] || [string match {*.c} $mm(work)] || [string match {*.txt} $mm(work)] || [string match {*.html} $mm(work)] || [string match {*.pss} $mm(work)] || [string match {*.pp} $mm(work)] || [string match {*.js} $mm(work)] || [string match {*.java} $mm(work)] || [string match {*.tcl} $mm(work)] || [string match {*.py} $mm(work)] || [string match {*.pl} $mm(work)] || [string match {*.jpeg} $mm(work)] || [string match {*.jpg} $mm(work)] || [string match {*.png} $mm(work)]} {
        set mm(work) "";       # clear
        append mm(work) "\\texttt\{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\}"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
      }
      # filenames 
      if {[string match {../*} $mm(work)] && $mm(work) ne "../"} {
        set mm(work) "";       # clear
        append mm(work) "\\texttt\{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\}"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
      }
      # filenames 
      # crude pattern checking.
      if {[string match {/*} $mm(work)] && $mm(work) ne "/"} {
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if {[string match {*.} $mm(work)]} {
          set mm(work) "";       # clear
          append mm(work) "\\texttt\{"
          append mm(work) [lindex $mm(tape) $mm(cell)]; # get
          append mm(work) "\}"
          lset mm(tape) $mm(cell) $mm(work);  # put 
          set mm(work) "";       # clear
        }
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if {[string match {*.} $mm(work)]} {
          set mm(work) "";       # clear
          append mm(work) "\\texttt\{"
          append mm(work) [lindex $mm(tape) $mm(cell)]; # get
          append mm(work) "\}"
          lset mm(tape) $mm(cell) $mm(work);  # put 
          set mm(work) "";       # clear
        }
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if {[string match {*.} $mm(work)]} {
          set mm(work) "";       # clear
          append mm(work) "\\texttt\{"
          append mm(work) [lindex $mm(tape) $mm(cell)]; # get
          append mm(work) "\}"
          lset mm(tape) $mm(cell) $mm(work);  # put 
          set mm(work) "";       # clear
        }
      }
      # emphasis is *likethis* (only words, not phrases) 
      if {[string match {**} $mm(work)] && [string match {**} $mm(work)] && $mm(work) ne "**"} {
        if { $mm(work) ne "" } {
          set mm(work) [string range $mm(work) 0 end-1]
        }; # clip
        if { $mm(work) ne "" } { 
          set mm(work) [string range $mm(work) 1 end] } ; # clop
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "\\textbf\{\\emph\{"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\}\}"
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
      }
      set mm(work) "";       # clear
      append mm(work) "word*"
    }
    Pop;
    # -------------
    # 2 tokens
    # ellide text
    if {$mm(work) eq "word*word*" || $mm(work) eq "text*word*" || $mm(work) eq "word*uuword*" || $mm(work) eq "text*uuword*" || $mm(work) eq "uutext*word*" || $mm(work) eq "uuword*word*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # remove insignificant nl* newline tokens. This may need more thought
    # We are using a dummy nl* token at the start of the doc, so the 
    # codeblock* codeline* etc tokens are not able to be the first token
    # of the document. So we can remove the !"codeblock*". clause.
    # remove insignificant codeblock* tokens
    if {[string match {*codeblock*} $mm(work)] && ![string match emline** $mm(work)] } {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # remove insignificant codeline* tokens
    if {[string match {*codeline*} $mm(work)] && ![string match emline** $mm(work)] } {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # remove insignificant emline* tokens (not followed by codeblock/line)
    # the logic is slightly diffferent because emline* is significant before
    # other tokens, not after.
    # also, consider emline*text*nl*
    if {[string match {emline**} $mm(work)] && ![string match *nl* $mm(work)]  && ![string match *codeline* $mm(work)]  && ![string match *codeblock* $mm(work)] } {
      # clear; get; add " "; ++; get; --; put; clear;
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"emline*" "text*"} $mm(work)] }
      
      Push;
      Push;
      continue;   # .reparse 
    }
    # remove insignificant 4dots* tokens
    if {[string match {*4dots*} $mm(work)] && ![string match uutext** $mm(work)]  && ![string match uuword** $mm(work)] } {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # remove insignificant star* tokens
    if {[string match {*star*} $mm(work)] && ![string match nl** $mm(work)] } {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # remove insignificant ---* tokens
    if {[string match {*---*} $mm(work)] && ![string match nl** $mm(work)] } {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # remove insignificant >>* tokens
    # lets assume that codelines cant start a document? Or lets
    # generate a dummy nl* token at the start of the document to 
    # make parsing easier.
    # !">>*".E">>*".!B"nl*" {
    if {[string match {*>>*} $mm(work)] && ![string match nl** $mm(work)] } {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # ellide upper case text 
    if {$mm(work) eq "uuword*uuword*" || $mm(work) eq "uutext*uuword*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "uutext*"
      Push;
      continue;   # .reparse 
    }
    # ellide multiple newlines 
    if {$mm(work) eq "nl*nl*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "nl*"
      Push;
      continue;   # .reparse 
    }
    # emphasis line (starts with *) 
    if {$mm(work) eq "nl*star*"} {
      set mm(work) "";       # clear
      # whilenot  
      while {![regexp {^[\n]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      # need to escape % # } \ and others
      # & % $ # _ { } ~ ^ \
          # \textasciitilde, \textasciicircum, and \textbackslash
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\\" "\\textbackslash "} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"&" "\\&"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"%" "\\%"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\$" "\\\$"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"#" "\\#"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"_" "\\_"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\{" "\\\{"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\}" "\\\}"} $mm(work)] }
      
      #replace "[" "\\[";
      #replace "]" "\\]";
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"~" "\\textasciitilde"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"^" "\\textasciicircum"} $mm(work)] }
      
      #replace '\\n' "\\textbackslash n";
      #replace '\\f' "\\textbackslash f";
      #replace '\\t' "\\textbackslash t";
      #replace '\\r' "\\textbackslash r";
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"latex" "\\LaTeX\{\}"} $mm(work)] }
      
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "\n \\emph\{"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " \}"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "emline*"
      Push;
      continue;   # .reparse 
    }
    # code line (starts with >>) 
    if {$mm(work) eq "nl*>>*"} {
      set mm(work) "";       # clear
      # whilenot  
      while {![regexp {^[\n]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "\n \\verb|"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " |\n"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "codeline*"
      Push;
      continue;   # .reparse 
    }
    # code block marker 
    if {$mm(work) eq "nl*---*"} {
      set mm(work) "";       # clear
      Until {,,,};
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      lset mm(tape) $mm(cell) $mm(work);  # put 
      # while  
      while {[regexp {^[,]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      set mm(work) "";       # clear
      append mm(work) "\n \\begin\{lstlisting\}\[breaklines\] \n"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n \\end\{lstlisting\} \n"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "codeblock*"
      Push;
      continue;   # .reparse 
    }
    # a code block with its preceding description
    if {$mm(work) eq "emline*codeblock*"} {
      set mm(work) "";       # clear
      append mm(work) "\n \\begin\{figure\}"
      append mm(work) "\n \\begin\{tabular\}\{ l \}"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " \\\\ "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) " \\end\{tabular\} \n"
      append mm(work) "\n \\end\{figure\}"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    # a code line with its preceding description
    # add some tabular LaTeX markup here.
    if {$mm(work) eq "emline*codeline*"} {
      set mm(work) "";       # clear
      append mm(work) "\n \\begin\{figure\}"
      append mm(work) "\n \\begin\{tabular\}\{ l \}"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " \\\\ "
      # add " \\\\ \\hline";
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) " \\end\{tabular\} \n"
      append mm(work) " \\end\{figure\}"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "text*"
      Push;
      continue;   # .reparse 
    }
    Pop;
    # -------------
    # 3 tokens
    # top level headings, all upper case on the line in the source document
    # dont need a "heading" token because we dont parse the document as a 
    # heirarchy, we just render things as we find them in the stream.
    if {$mm(work) eq "nl*uutext*nl*" || $mm(work) eq "nl*uuword*nl*"} {
      set mm(work) "";       # clear
      # Check that heading is at least 4 chars
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      if { $mm(work) ne "" } {
        set mm(work) [string range $mm(work) 0 end-1]
      }; # clip
      if {$mm(work) eq ""} {
        append mm(work) "nl*text*nl*"
        Push;
        Push;
        Push;
        continue;   # .reparse 
      }
      set mm(work) "";       # clear
      # make headings capital case
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      set mm(work) [string totitle $mm(work)];   # cap
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # newline
      append mm(work) "\\section\{"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) "\}"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      # transfer nl value
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) "text*nl*"
      Push;
      Push;
      continue;   # .reparse 
    }
    # simple reductions 
    if {$mm(work) eq "nl*text*nl*" || $mm(work) eq "nl*word*nl*" || $mm(work) eq "text*text*nl*" || $mm(work) eq "emline*text*nl*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      # transfer newline value
      append mm(work) "text*nl*"
      Push;
      Push;
      continue;   # .reparse 
    }
    Pop;
    # -------------
    # 4 tokens
    # sub headings, 
    if {$mm(work) eq "nl*uutext*4dots*nl*" || $mm(work) eq "nl*uuword*4dots*nl*"} {
      set mm(work) "";       # clear
      # Check that sub heading text is at least 4 chars ?
      # yes but need to transfer 4dots and nl
      # ++; get; --; clip; clip; clip; 
      # "" { add "nl*text*nl*"; push; push; push; .reparse }
      set mm(work) "";       # clear
      # make subheadings capital case
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      set mm(work) [string totitle $mm(work)];   # cap
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # newline
      append mm(work) "\\subsection\{"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) "\}"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      # transfer nl value
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) "text*nl*"
      Push;
      Push;
      continue;   # .reparse 
    }
    Push;
    Push;
    Push;
    Push;
    if {$mm(eof)} {
      Pop;
      Pop;
      Pop;
      if {$mm(work) eq "text*nl*" || $mm(work) eq "text*"} {
        set mm(work) "";       # clear
        # make a valid LaTeX document
        append mm(work) "" 
        append mm(work) "\n  %% -------------------------------------------" 
        append mm(work) "\n  %%  latex generated by: mark.latex.pss " 
        append mm(work) "\n  %%   from source file : " 
        append mm(work) "\n  %%                  on: " 
        append mm(work) "\n  %% -------------------------------------------" 
        append mm(work) "\n" 
        append mm(work) "\n  \\documentclass\[a4paper,12pt\]\{article\}" 
        append mm(work) "\n  \\usepackage\[margin=4pt,noheadfoot\]\{geometry\}" 
        append mm(work) "\n  \\usepackage\{color\}                   %% to use colours, use 'xcolor' for more" 
        append mm(work) "\n  \\usepackage\{multicol\}                %% for multiple columns" 
        append mm(work) "\n  \\usepackage\{keystroke\}               %% for keyboard key images" 
        append mm(work) "\n  \\usepackage\[toc\]\{multitoc\}           %% for multi column table of contents" 
        append mm(work) "\n  \\usepackage\{tocloft\}                 %% to customize the table of contents" 
        append mm(work) "\n  \\setcounter\{tocdepth\}\{2\}             %% only display 2 levels in the contents" 
        append mm(work) "\n  \\setlength\{\\cftbeforesecskip\}\{0cm\}   %% make the toc more compact" 
        append mm(work) "\n  \\usepackage\{listings\}                %% for nice code listings" 
        append mm(work) "\n  \\usepackage\{caption\}                 %% " 
        append mm(work) "\n  \\lstset\{" 
        append mm(work) "\n    captionpos=t," 
        append mm(work) "\n    language=bash," 
        append mm(work) "\n    basicstyle=\\ttfamily,           %% fixed pitch font" 
        append mm(work) "\n    xleftmargin=0pt,                %% margin on the left outside the frames" 
        append mm(work) "\n    framexleftmargin=10pt," 
        append mm(work) "\n    framexrightmargin=10pt," 
        append mm(work) "\n    framexbottommargin=5pt," 
        append mm(work) "\n    framextopmargin=5pt," 
        append mm(work) "\n    breaklines=true,                %% break long code lines" 
        append mm(work) "\n    breakatwhitespace=false,        %% break long code lines anywhere" 
        append mm(work) "\n    breakindent=10pt,               %% reduce the indent from 20pt to 10" 
        append mm(work) "\n    postbreak=\\mbox\{\{\\color\{blue\}\\small\$\\Rightarrow\$\\space\}\},  %% mark with arrow" 
        append mm(work) "\n    showstringspaces=false,            %% dont show spaces within strings" 
        append mm(work) "\n    framerule=2pt,                     %% thickness of the frames" 
        append mm(work) "\n    frame=top,frame=bottom," 
        append mm(work) "\n    rulecolor=\\color\{lightgrey\}, " 
        append mm(work) "\n    % frame=l" 
        append mm(work) "\n    % define special comment delimiters '##(' and ')'" 
        append mm(work) "\n    % moredelim=\[s\]\[\\color\{grey\}\\itshape\\footnotesize\\ttfamily\]\{~(\}\{)\}," 
        append mm(work) "\n  \}   %% source code settings" 
        append mm(work) "\n  \\usepackage\{graphicx\}                %% to include images" 
        append mm(work) "\n  \\usepackage\{fancybox\}                %% boxes with rounded corners" 
        append mm(work) "\n  \\usepackage\{wrapfig\}                 %% flow text around tables, images" 
        append mm(work) "\n  \\usepackage\{tabularx\}                %% change width of tables" 
        append mm(work) "\n  \\usepackage\[table\]\{xcolor\}           %% alternate row colour tables" 
        append mm(work) "\n  \\usepackage\{booktabs\}                %% for heavier rules in tables" 
        append mm(work) "\n  \\usepackage\[small,compact\]\{titlesec\} %% sections more compact, less space" 
        append mm(work) "\n  \\usepackage\{enumitem\}                %% more compact and better lists" 
        append mm(work) "\n  \\setlist\{noitemsep\}                  %% reduce list item spacing" 
        append mm(work) "\n  \\usepackage\{hyperref\}     %% make urls into hyperlinks" 
        append mm(work) "\n  \\hypersetup\{              %% add pdftex if only pdf output is required" 
        append mm(work) "\n     colorlinks=true,       %% set up the colours for the hyperlinks" 
        append mm(work) "\n     linkcolor=black,       %% internal document links black" 
        append mm(work) "\n     urlcolor=black,        %% url links black" 
        append mm(work) "\n     filecolor=red," 
        append mm(work) "\n     citecolor=red," 
        append mm(work) "\n     bookmarks=true, pdfpagemode=UseOutlines\}" 
        append mm(work) "\n" 
        append mm(work) "\n  \\geometry\{ left=1.0in,right=1.0in,top=1.0in,bottom=1.0in \}" 
        append mm(work) "\n  %% define some colours to use" 
        append mm(work) "\n  \\definecolor\{lightgrey\}\{gray\}\{0.70\}" 
        append mm(work) "\n  \\definecolor\{grey\}\{gray\}\{0.30\}" 
        append mm(work) "\n" 
        append mm(work) "\n  \\titleformat\{\\section\}\[frame\]    %% titlesec: create framed section headings" 
        append mm(work) "\n     \{\\normalfont\}" 
        append mm(work) "\n     \{\\filleft \\footnotesize \\enspace Section \\thesection\\enspace\\enspace\}" 
        append mm(work) "\n     \{3pt\} \{\\bfseries\\itshape\\filright\}" 
        append mm(work) "\n" 
        append mm(work) "\n  \\title\{The Pep parsing language and machine\}" 
        append mm(work) "\n  \\author\{mjbishop\}" 
        append mm(work) "\n  \\date\{June 2021\}" 
        append mm(work) "\n  \\setlength\{\\parindent\}\{4pt\}" 
        append mm(work) "\n  %% \\setlength\{\\parskip\}\{1ex\}" 
        append mm(work) "\n" 
        append mm(work) "\n  %% label lists with stars" 
        append mm(work) "\n  \\renewcommand\{\\labelitemi\}\{\$\\star\$\}" 
        append mm(work) "\n" 
        append mm(work) "\n  \\parindent=10pt" 
        append mm(work) "\n  \\parskip=12pt" 
        append mm(work) "\n  \\begin\{document\}" 
        append mm(work) "\n" 
        append mm(work) "\n  "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n\\end\{document\} \n"
        puts -nonewline $mm(work);    # print
        set mm(work) "";       # clear
        append mm(work) "\n\n %% Document parsed as text*!\n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      Push;
      Push;
      append mm(work) "Document parsed unusually!\n"
      append mm(work) "Stack at line "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) " char "
      append mm(work) $mm(charsRead); # chars 
      append mm(work) ": "
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      while {[Pop]} {};           # unstack 
      puts -nonewline $mm(work);    # print
      while {[Push]} {};          # stack 
      append mm(work) "\n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    break; 
  }
  
}
# end of generated code
