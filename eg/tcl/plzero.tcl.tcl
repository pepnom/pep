#!/usr/bin/tclsh

# code generated by "translate.tcl.pss" a pep script
# see bumble.sf.net/books/pars/
#import sys    # 

  # make a new machine. Standard tcl doesnt have objects
  # so I will use an associative array, instead.
  #array set mm {
  #  eof false     # end of stream reached?
  #  charsRead 0   # how many chars already read
  #  linesRead 1   # how many lines already read
  #  escape "\\"
  #  delimiter "*" # push/pop delimiter (default "*")
  #  counter 0     # a counter for anything
  #  work ""       # the workspace
  #  stack {}    # stack for parse tokens 
  #  cell 0      # current tape cell
  #  size 100    # the initial tape/marks list size
  #  tape {}     # a list of attribute for tokens 
  #  marks {}    # marked tape cells
  #  peep [read stdin 1] 
  #}

  # make a new machine. Standard tcl doesnt have objects
  # so I will use an associative array, instead.
  array set mm {
    eof false     
    charsRead 0  
    linesRead 1 
    escape "\\"
    delimiter "*" 
    counter 0    
    work ""     
    stack {}   
    cell 0    
    size 0 
    tape {}  
    marks {}
    peep {} 
  }

  # Adds more elements to the tape and marks lists 
  proc MoreTape {} { 
    global mm
    for {set ii 0} {$ii < 100} {incr ii} { 
      lappend mm(tape) ""; lappend mm(marks) "";
    }
    incr mm(size) 100
  }

  # initialises a machine  
  proc Init {} { 
    global mm
    set mm(peep) [ read stdin 1 ]
    # or Read;
    MoreTape;
  }

  # read one character from the input stream and 
  #    update the machine.
  proc Read {} { 
    # use upvar eg
    # upvar $machine mm
    global mm
    if { $mm(eof) } { exit }
    incr mm(charsRead)
    # increment lines
    if { $mm(peep) eq "\n" } { incr mm(linesRead) }
    append mm(work) $mm(peep)
    set mm(peep) [ read stdin 1 ]
    if {[eof stdin]} { set mm(eof) true; set mm(peep) -1 }
  } 

  # increment tape pointer by one: trivial method? But need
  # to increase tape/marks size if exceeded
  proc Increment {} { global mm; incr mm(cell) } 

  # remove escape character: trivial method ?
  proc UnescapeChar {c} {
    global mm
    #if { $mm(work) ne "" } $mm(work = $mm(work.replace("\\"+c, c)
  }

  # add escape character : trivial
  proc EscapeChar {c} {
    global mm
    #if { $mm(work) ne "" } { $mm(work = $mm(work.replace(c, "\\"+c) }
  }

  # pop the first token from the stack into the workspace */
  proc Pop {} { 
    global mm
    if {[llength $mm(stack)] == 0} { return false }
    # prepend last stack item, and delete the item
    set mm(work) "[lindex $mm(stack) end]$mm(work)"
    set mm(stack) [lrange $mm(stack) 0 [expr [llength $mm(stack)]-2]] 
    if {$mm(cell) > 0} { incr mm(cell) -1 }
    return true
  }
  
  # push the first token from the workspace to the stack 
  proc Push {} {
    # lappend list $value
    # dont increment the tape pointer on an empty push
    global mm
    if { $mm(work) eq "" } { return false }
    # need to get this from the delimiter.
    set firstdelim [string first $mm(delimiter) $mm(work)]
    if {$firstdelim == -1} {
      lappend mm(stack) $mm(work)
      set mm(work) ""
      incr mm(cell) 1
      # a hack because "stack" hangs otherwise (never returns false)
      return false
      #return true
    }
    lappend mm(stack) [string range $mm(work) 0 $firstdelim]
    set mm(work) [string range $mm(work) [expr {$firstdelim+1}] end]
    incr mm(cell) 1
    return true
  }

  # a helper function
  proc IsEscaped {suffix} {
    global mm
    # remove suffix
    set count 0
    set last [expr {[string last $suffix $mm(work)]-1}]
    set new [string range $mm(work) 0 $last]
    # now count trailing escape chars
    while {[string index $new end] eq $mm(escape)} {
      set last [expr {[string last $mm(escape) $new]-1}]
      set new [string range $new 0 $last]
      incr count
    }
    # puts count=$count
    if { $count == 1 } { return true }
    if {[expr {($count % 2) == 0}]} { return false } else { return true }
  }

  # reads the input stream until the workspace end with text 
  proc Until {suffix} { 
    # read at least one character
    global mm
    if { $mm(eof) } { return }
    Read;
    while true { 
      if {$mm(eof)} { return }
      # this must count trailing escapes
      if {[string match *$suffix $mm(work)] && ![IsEscaped $suffix]} { return }
      Read;
    }
  }  

  # maybe not required 
  proc Swap {} { 
    global mm
    set s $mm(work)
    set mm(work) $mm(tape)[$mm(cell)]
    # could be a problem if $s has spaces in it. (becomes a list)
    lset mm(tape) $mm(cell) $s
  }

  proc WriteToFile {} { 
    global mm
    set f [open sav.pp w 0600]  
    puts $f $mm(work)
    close $f
  }

  # useful for debugging, the "state" command
  proc State {} { 
    global mm
    puts "---------- Machine State --------------";
    puts -nonewline " Stack\[[join $mm(stack) {}]\] Work\[$mm(work)\] ";
    puts "Peep\[$mm(peep)\]";
    puts -nonewline " Acc:$mm(counter) Esc:$mm(escape) ";
    puts -nonewline "Delim:$mm(delimiter) Chars:$mm(charsRead) ";
    puts "Lines:$mm(linesRead)";
    puts "---------- Tape (size:$mm(size))  --------------";
    set ii 0
    while { $ii < 7 } {
      puts -nonewline "  $ii";
      if { $ii == $mm(cell) } { 
        puts -nonewline "> "
      } else { puts -nonewline "  " }
      # display marks
      if { [lindex $mm(marks) $ii] ne "" } { 
        puts -nonewline "\"[lindex $mm(marks) $ii]\" "
      } else { puts -nonewline ". " }

      puts "\[[lindex $mm(tape) $ii]\]";
      incr ii
    }
  }
  # end of tcl pep Machine "class" (array) definition

  # a flag var to make .restart work in run-once loops
  set restart false
  # initialise the machine
  Init;
 
while !$mm(eof) { 
  
  # lex block 
  while true { 
    Read;           # read
    # make character numbers (for error messages) relative
    # to line numbers
    if {$mm(work) eq "\n"} {
      set mm(work) "";       # clear
      set mm(charsRead) 0; # nochars 
      break;  # .reparse 
    }
    if {[regexp {^[[:space:]]+$} $mm(work)]} {
      set mm(work) "";       # clear
      break;  # .reparse 
    }
    if {$mm(work) eq "+" || $mm(work) eq "-"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "opadd*"
      Push;
      break;  # .reparse 
    }
    if {$mm(work) eq "*" || $mm(work) eq "/"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "opmul*"
      Push;
      break;  # .reparse 
    }
    # modern pascal style comments, but not (* ... *) because 
    # they are tricky to parse.
    if {$mm(work) eq "\{"} {
      # save the line number for possible error message later
      set mm(work) "";       # clear
      append mm(work) $mm(linesRead); # lines 
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "\{"
      Until {\}};
      if {[string match {*\}} $mm(work)]} {
        # can convert to another format
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        # create a "comment" parse token
        # comment-out this line to remove multiline comments from the 
        # translated code
        # add "comment*"; push; 
        break;  # .reparse 
      }
      # make an unterminated multiline comment an error
      # to ease debugging of scripts.
      set mm(work) "";       # clear
      append mm(work) "\[pl/0 error\] Unterminated pascal comment \{ ... \} \n"
      append mm(work) "stating at line number "
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      puts -nonewline $mm(work);    # print
      set mm(work) "";       # clear
      exit;
    }
    if {$mm(work) eq "*" || $mm(work) eq "/"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "opmul*"
      Push;
      break;  # .reparse 
    }
    # literal tokens
    # '!' is the print command in pl/0
    # '?' is the read command in pl/0
    # '#' means != 
    # '.' marks the end of a program. 
    if {$mm(work) eq "." || $mm(work) eq "," || $mm(work) eq "=" || $mm(work) eq ";" || $mm(work) eq "(" || $mm(work) eq ")"} {
      lset mm(tape) $mm(cell) $mm(work);  # put 
      append mm(work) "*"
      Push;
      break;  # .reparse 
    }
    if {$mm(work) eq "!"} {
      set mm(work) "";       # clear
      append mm(work) "write"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "!*"
      Push;
      break;  # .reparse 
    }
    if {$mm(work) eq "?"} {
      set mm(work) "";       # clear
      append mm(work) "read"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "?*"
      Push;
      break;  # .reparse 
    }
    # also need to parse <= >= comparison operators
    # '=' is comparison and also constant assignment.
    if {$mm(work) eq "<" || $mm(work) eq ">" || $mm(work) eq "#"} {
      # while  
      while {[regexp {^[=]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      if {$mm(work) ne "<" && $mm(work) ne ">" && $mm(work) ne ">=" && $mm(work) ne "<=" && $mm(work) ne "#"} {
        # error, message and quit
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "\[pl/0 error\] unrecognised operator "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) " at line/char "
        append mm(work) $mm(linesRead); # lines 
        append mm(work) "/"
        append mm(work) $mm(charsRead); # chars 
        append mm(work) "\n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      if {$mm(work) eq "#"} {
        set mm(work) "";       # clear
        append mm(work) "!="
      }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "compare*"
      Push;
    }
    if {$mm(work) eq ":"} {
      Read;           # read
      if {$mm(work) eq ":="} {
        lset mm(tape) $mm(cell) $mm(work);  # put 
        append mm(work) "*"
        Push;
        break;  # .reparse 
      }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "\[pl/0 error\] unrecognised operator "
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " at line/char "
      append mm(work) $mm(linesRead); # lines 
      append mm(work) "/"
      append mm(work) $mm(charsRead); # chars 
      append mm(work) "\n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    if {[regexp {^[0-9]+$} $mm(work)]} {
      # while  
      while {[regexp {^[0-9]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "number*"
      Push;
      break;  # .reparse 
    }
    if {[regexp {^[[:alpha:]]+$} $mm(work)]} {
      # while  
      while {[regexp {^[[:alpha:]]+$} $mm(peep)]} { if {$mm(eof)} { break; } Read }
      # make keywords case insensitive
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) [string tolower $mm(work)]; # lower
      # synonym with !
      if {$mm(work) eq "write" || $mm(work) eq "writeln"} {
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "!*"
        Push;
        break;  # .reparse 
      }
      # keywords in pl/0
      if {$mm(work) eq "const" || $mm(work) eq "var" || $mm(work) eq "if" || $mm(work) eq "then" || $mm(work) eq "while" || $mm(work) eq "do" || $mm(work) eq "begin" || $mm(work) eq "end" || $mm(work) eq "proc" || $mm(work) eq "procedure" || $mm(work) eq "call" || $mm(work) eq "odd"} {
        # or add ".key*" to remind us that these are keywords,
        # not parse tokens
        # add a space here for pretty printing later
        lset mm(tape) $mm(cell) $mm(work);  # put 
        if {$mm(work) eq "procedure"} {
          set mm(work) "";       # clear
          append mm(work) "proc"
        }
        append mm(work) "*"
        Push;
        break;  # .reparse 
      }
      # restore non-lower case identifier
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "ident*"
      Push;
      break;  # .reparse 
    }
    if {$mm(work) ne ""} {
      # error unrecognised character
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) $mm(linesRead); # lines 
      append mm(work) ":"
      append mm(work) $mm(charsRead); # chars 
      append mm(work) " \[pl/0 error\] incorrect character '"
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "'\n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    break;
  }
  if {$restart == true} { set restart false; continue; }
  
  # parse block 
  while true {  
    # To visualise token reduction uncomment this below:
    append mm(work) $mm(linesRead); # lines 
    append mm(work) ":"
    append mm(work) $mm(charsRead); # chars 
    append mm(work) " "
    puts -nonewline $mm(work);    # print
    set mm(work) "";       # clear
    append mm(work) "\n"
    while {[Pop]} {};           # unstack 
    puts -nonewline $mm(work);    # print
    if { $mm(work) ne "" } {
      set mm(work) [string range $mm(work) 0 end-1]
    }; # clip
    while {[Push]} {};          # stack 
    #-----------------
    # 1 token
    Pop;
    #-----------------
    # 2 tokens
    Pop;
    # Some errors
    if {$mm(work) eq "ident*ident*"} {
      set mm(work) "";       # clear
      append mm(work) $mm(linesRead); # lines 
      append mm(work) ":"
      append mm(work) $mm(charsRead); # chars 
      append mm(work) " \[pl/0 error\] 2 variable names in a row (is there a \n"
      append mm(work) " missing operator?) \n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    if {$mm(work) eq "vardec*const*"} {
      set mm(work) "";       # clear
      append mm(work) $mm(linesRead); # lines 
      append mm(work) ":"
      append mm(work) $mm(charsRead); # chars 
      append mm(work) " \[pl/0 error\] Constant declarations must precede variable \n"
      append mm(work) " declarations in pl/0 \n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    if {$mm(work) eq "condec*const*"} {
      set mm(work) "";       # clear
      append mm(work) $mm(linesRead); # lines 
      append mm(work) ":"
      append mm(work) $mm(charsRead); # chars 
      append mm(work) " \[pl/0 error\] only 1 constant declaration block is allowed \n"
      append mm(work) " in each scope \n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    if {$mm(work) eq "vardec*var*"} {
      set mm(work) "";       # clear
      append mm(work) $mm(linesRead); # lines 
      append mm(work) ":"
      append mm(work) $mm(charsRead); # chars 
      append mm(work) " \[pl/0 error\] only 1 variable declaration block is allowed \n"
      append mm(work) " in each scope \n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    if {$mm(work) eq ";*end*"} {
      set mm(work) "";       # clear
      append mm(work) $mm(linesRead); # lines 
      append mm(work) ":"
      append mm(work) $mm(charsRead); # chars 
      append mm(work) " \[pl/0 error\] Last statement in block does not require \n"
      append mm(work) " a semi-colon ';' \n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    # add an empty procset* (set of procedures) if there is
    # not one already. This simplifies program reduction later
    # it doesnt matter if there is 1 or 2 tokens here.
    if {[string match {*proc*} $mm(work)] && ![string match procset** $mm(work)] } {
      if {$mm(work) ne "proc*"} {
        # need to conserve the preceding token
        Push;
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        lset mm(tape) $mm(cell) $mm(work);  # put 
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        set mm(work) "";       # clear
        lset mm(tape) $mm(cell) $mm(work);  # put 
        append mm(work) "procset*proc*"
        Push;
        Push;
        continue;   # .reparse 
      }
      # only 1 token
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      lset mm(tape) $mm(cell) $mm(work);  # put 
      append mm(work) "procset*proc*"
      Push;
      Push;
      continue;   # .reparse 
    }
    # procedure headers (name etc)
    if {$mm(work) eq "procset*proceed*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "procset*"
      Push;
      continue;   # .reparse 
    }
    # "=" can be used for constant assignment but also as
    # a comparison operator
    if {$mm(work) eq "=*ident*" || $mm(work) eq "=*exp*"} {
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"=*" "compare*"} $mm(work)] }
      
      Push;
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "exp*=*"} {
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"=*" "compare*"} $mm(work)] }
      
      Push;
      Push;
      continue;   # .reparse 
    }
    # expression transmog
    if {$mm(work) eq "opmul*ident*" || $mm(work) eq "opadd*ident*" || $mm(work) eq "opmul*number*" || $mm(work) eq "opadd*number*" || $mm(work) eq "compare*ident*" || $mm(work) eq "compare*number*" || $mm(work) eq ":=*ident*" || $mm(work) eq ":=*number*" || $mm(work) eq "if*ident*" || $mm(work) eq "if*number*" || $mm(work) eq "while*ident*" || $mm(work) eq "while*number*" || $mm(work) eq "(*ident*" || $mm(work) eq "(*number*" || $mm(work) eq "!*ident*" || $mm(work) eq "!*number*"} {
      Push;
      set mm(work) "";       # clear
      append mm(work) "exp*"
      Push;
      continue;   # .reparse 
    }
    # expression transmutation
    if {$mm(work) eq "ident*opmul*" || $mm(work) eq "ident*opadd*" || $mm(work) eq "number*opmul*" || $mm(work) eq "number*opadd*" || $mm(work) eq "ident*compare*" || $mm(work) eq "number*compare*"} {
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"ident*" "exp*"} $mm(work)] }
      
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"number*" "exp*"} $mm(work)] }
      
      Push;
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "const*conlist*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "condec*"
      Push;
      continue;   # .reparse 
    }
    # non-tail reduction for variables
    if {$mm(work) eq "var*ident*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "varlist*"
      Push;
      continue;   # .reparse 
    }
    # variable decs
    if {$mm(work) eq "varlist*;*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "vardec*"
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "block*.*"} {
      set mm(work) "";       # clear
      append mm(work) "program*"
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "call*ident*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "statement*"
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "?*ident*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "statement*"
      Push;
      continue;   # .reparse 
    }
    # a multi statement block, between begin/end
    if {$mm(work) eq "begin*statementset*"} {
      # ident statements,
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\n" "\n  "} $mm(work)] }
      
      append mm(work) "\nend"
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "statement*"
      Push;
      continue;   # .reparse 
    }
    # tail reduction for statementsets 
    if {$mm(work) eq "statement*end*"} {
      set mm(work) "";       # clear
      #get; ++; get; --; put; clear;
      append mm(work) "statementset*"
      Push;
      continue;   # .reparse 
    }
    #-----------------
    # 3 tokens
    Pop;
    # ! expression must be parsed while looked at the 
    # trailing token, like all expression parsing
    if {[string match {!*exp**} $mm(work)] && $mm(work) ne "!*exp*" && ![string match *opmul* $mm(work)]  && ![string match *opadd* $mm(work)] } {
      # need to conserve the "invisible" last token 
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"!*exp*" "statement*"} $mm(work)] }
      
      Push;
      Push;
      # also transfer attributes 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      continue;   # .reparse 
    }
    # procedure headers (name etc)
    if {$mm(work) eq "proc*ident*;*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "prochead*"
      Push;
      continue;   # .reparse 
    }
    # procedure headers (name etc)
    if {$mm(work) eq "prochead*statement*;*"} {
      # indent the statement if it is not a begin/end construct
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {![string match begin* $mm(work)] } {
        set mm(work) "";       # clear
        append mm(work) "  "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\n  "} $mm(work)] }
        
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "proceed*"
      Push;
      continue;   # .reparse 
    }
    # expressions, this could be the trickiest aspect of 
    # the grammar. transmog ident/number to exp
    if {$mm(work) eq "exp*opmul*exp*" || $mm(work) eq "exp*opadd*exp*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "exp*"
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "(*exp*)*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "exp*"
      Push;
      continue;   # .reparse 
    }
    if {$mm(work) eq "statement*;*statementset*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) ";\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "statementset*"
      Push;
      continue;   # .reparse 
    }
    # variable decs 
    if {$mm(work) eq "varlist*,*ident*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "varlist*"
      Push;
      continue;   # .reparse 
    }
    #-----------------
    # 4 tokens
    Pop;
    # procedure headers (name etc). Need to indent the variable decs etc
    if {$mm(work) eq "prochead*vardec*statement*;*" || $mm(work) eq "prochead*condec*statement*;*"} {
      # indent the variable/constant declaration
      set mm(work) "";       # clear
      append mm(work) "  "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\n" "\n  "} $mm(work)] }
      
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "proceed*"
      Push;
      continue;   # .reparse 
    }
    # ident and number have already been transmog'ed into exp*
    # and =* into compare*
    if {[string match {exp*compare*exp**} $mm(work)] && $mm(work) ne "exp*compare*exp*" && ![string match *opmul* $mm(work)]  && ![string match *opadd* $mm(work)] } {
      # need to conserve the "invisible" last token 
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"exp*compare*exp*" "condition*"} $mm(work)] }
      
      Push;
      Push;
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      # transfer trailing token value
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      set mm(work) "";       # clear
      continue;   # .reparse 
    }
    # also see the 5 token reduction, because of the trailing token
    # required by exp*
    if {$mm(work) eq "if*condition*then*statement*" || $mm(work) eq "while*condition*do*statement*"} {
      # indent the statement if it is not a begin/end construct
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if {![string match begin* $mm(work)] } {
        set mm(work) "";       # clear
        append mm(work) "  "
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        # replace 
        if {$mm(work) ne ""} { 
        set mm(work) [string map {"\n" "\n  "} $mm(work)] }
        
        lset mm(tape) $mm(cell) $mm(work);  # put 
      }
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "statement*"
      Push;
      continue;   # .reparse 
    }
    # lookahead for expressions in statements 
    # the problem is: x:=4*3+1 will be parsed at 
    # statement*+1 if no lookahead.
    # If the expression
    # is not followed by a */+- then it is a complete statement
    # and can be reduced. lets transmog ident and number to make simpler
    if {[string match {ident*:=*exp**} $mm(work)] && $mm(work) ne "ident*:=*exp*" && ![string match *opmul* $mm(work)]  && ![string match *opadd* $mm(work)] } {
      # need to conserve the "invisible" last token 
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"ident*:=*exp*" "statement*"} $mm(work)] }
      
      Push;
      Push;
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      continue;   # .reparse 
    }
    # tail reduction for constant decs
    if {$mm(work) eq "ident*=*number*;*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "conlist*"
      Push;
      continue;   # .reparse 
    }
    # 
    if {$mm(work) eq "ident*;*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "varlist*"
      Push;
      continue;   # .reparse 
    }
    #-----------------
    # 5 tokens
    Pop;
    # procedure headers (name etc), need to indent condec vardec
    if {$mm(work) eq "prochead*condec*vardec*statement*;*"} {
      # indent the variable and constant declarations
      set mm(work) "";       # clear
      append mm(work) "  "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\n" "\n  "} $mm(work)] }
      
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "  "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"\n" "\n  "} $mm(work)] }
      
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "proceed*"
      Push;
      continue;   # .reparse 
    }
    # sometimes statements are terminated by expressions, which
    # in turn must be terminated by something else, so there is a 
    # trailing token there
    if {[string match {if*condition*then*statement**} $mm(work)] && $mm(work) ne "if*condition*then*statement*"} {
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"if*condition*then*statement*" "statement*"} $mm(work)] }
      
      Push;
      Push;
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) " "
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      # transfer invisible token value
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      continue;   # .reparse 
    }
    if {[string match {while*condition*do*statement**} $mm(work)] && $mm(work) ne "while*condition*do*statement*"} {
      # replace 
      if {$mm(work) ne ""} { 
      set mm(work) [string map {"while*condition*do*statement*" "statement*"} $mm(work)] }
      
      Push;
      Push;
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) " "
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      # transfer invisible token value, and realign tape pointer
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      set mm(work) "";       # clear
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      continue;   # .reparse 
    }
    # constant declarations, tail reduction, but tail redux not
    # necessary
    if {$mm(work) eq "ident*=*number*,*conlist*"} {
      set mm(work) "";       # clear
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) " "
      if { $mm(cell) >= $mm(size) } { MoreTape; }
      incr mm(cell);                             # ++
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "conlist*"
      Push;
      continue;   # .reparse 
    }
    # program reduction
    if {$mm(eof)} {
      if {$mm(work) eq "statement*.*"} {
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "program*"
      }
      if {$mm(work) eq "vardec*statement*.*" || $mm(work) eq "condec*statement*.*" || $mm(work) eq "procset*statement*.*"} {
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n\{ main program \}\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "program*"
      }
      if {$mm(work) eq "condec*vardec*statement*.*" || $mm(work) eq "vardec*procset*statement*.*" || $mm(work) eq "condec*procset*statement*.*"} {
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n\{ main program \}\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "program*"
      }
      if {$mm(work) eq "condec*vardec*procset*statement*.*"} {
        set mm(work) "";       # clear
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n\{ main program \}\n"
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) >= $mm(size) } { MoreTape; }
        incr mm(cell);                             # ++
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        if { $mm(cell) > 0 } { incr mm(cell) -1 };  # --
        lset mm(tape) $mm(cell) $mm(work);  # put 
        set mm(work) "";       # clear
        append mm(work) "program*"
      }
    }
    if {$mm(eof)} {
      while {[Pop]} {};           # unstack 
      if {$mm(work) eq "program*"} {
        set mm(work) "";       # clear
        append mm(work) "\{ ok pl/0 \}\n"
        append mm(work) "\{ code checked and formatted by eg/plzero.pss \}\n"
        append mm(work) [lindex $mm(tape) $mm(cell)]; # get
        append mm(work) "\n"
        puts -nonewline $mm(work);    # print
        exit;
      }
      lset mm(tape) $mm(cell) $mm(work);  # put 
      set mm(work) "";       # clear
      append mm(work) "Pl/0 program did not parse well \n"
      append mm(work) "The final parse tokens were: "
      append mm(work) [lindex $mm(tape) $mm(cell)]; # get
      append mm(work) "\n"
      puts -nonewline $mm(work);    # print
      exit;
    }
    Push;
    Push;
    Push;
    Push;
    Push;
    break; 
  }
  
}
# end of generated code
