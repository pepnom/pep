

 /* Rust code generated by "translate.rust.pss" */

 // use std::mem;     // for swap
 use std::io;
 use std::io::Read;
 use std::io::BufReader;
 use std::io::BufRead;
 use std::process;
 use std::fs;

 pub struct Machine {
   accumulator: i32,          // counter for anything
   peep: char,                // next char in input stream
   charsRead: u32,            // No. of chars read so far
   linesRead: u32,            // No. of lines read so far
   work: String,          // text accumulator
   stack: Vec<String>,    // parse token stack
   LENGTH: u32,           // tape initial length
   // vectors are growable in rust
   tape: Vec<String>,     // array of token attributes, growable
   marks: Vec<String>,    // tape marks
   cell: u32,             // pointer to current cell
   input: BufReader<File>,   // text input stream
   eof: bool,             // end of stream reached?
   flag: bool,          // not used here
   escape: String,      // char used to "escape" others "\"
   delimiter: String    // push/pop delimiter (default is "*")
   
 }

 impl Machine {

   // read from stdin or from a file or a string.
   // BufReader::new(io::stdin())
   // BufReader::new(fs::File::open(filename).unwrap())
   // let mut streader = StringReader::new("Line 1\nLine 2");
   // let mut bufreader = BufReader::new(streader);

   /** make a new machine with input from stdin */
   /*
   pub fn new() -> Self {
     return Machine::new(BufReader::new(io::stdin()));
   }
   */
   
   /** make a new machine with input from a string and
       output to a string */
   /*
   stringreader is a crate. 
   pub fn new(input: String, output: String) -> Self {
     let mut reader = StringReader::new(input);
     return Machine::new(BufReader::new(reader));
   }
   */
   
   /** make a new machine with a buffered stream reader */
   pub fn new<R: BufRead>(reader: R) -> Self {
     Self {
       LENGTH: 100,
       // BufReader::new(io::stdin())
       input: reader,
       eof: false,
       flag: false,
       charsRead: 0, 
       linesRead: 1, 
       escape: String::from("\\"),
       delimiter: String::from("*"),
       accumulator: 0,
       work: String::new(),
       stack: vec!["".to_string(),100],
       cell: 0,
       tape: vec!["".to_string(),100],
       marks: vec!["".to_string(),100],
       cell: 0,
       marks: Vec::new(),
       peep: Self.input.read()
     } // self
   }

   /** read one character from the input stream and 
       update the machine. */
   pub fn readNext(&mut self) {
     //int iChar;
     if self.eof { process::exit(0); }
     self.charsRead += 1;
     // increment lines
     if self.peep == '\n' { self.linesRead += 1; }
     self.work.push(self.peep);
     self.peep = self.input.read(); 
     if self.peep == -1 { self.eof = true; }
   }

   /** increment tape pointer by one */
   pub fn increment(&mut self) {
     self.cell += 1;
     if self.cell >= self.LENGTH {
       self.tape.push(String::from(""));
       self.marks.push(String::from(""));
       self.LENGTH += 1;
     }
   }
   
   /** remove escape character  */
   pub fn unescapeChar(&mut self, c: char) {
     if !self.work.is_empty() {
       let s: String = self.work.replace("\\"+c, c+"");
       self.work.clear(); self.work.push_str(s);
     }
   }

   /** add escape character  */
   pub fn escapeChar(&mut self, c: char) {
     if !self.work.is_empty() {
       let s: String = self.work.replace(c+"", "\\"+c);
       self.work.clear(); self.work.push_str(s);
     }
   }

   /** whether trailing escapes \\ are even or odd */
   // untested code. check! eg try: add "x \\"; print; etc
   pub fn isEscaped(&mut self, ss: String, sSuffix: String) -> bool {
     let count: i32 = 0; 
     if ss.chars().count() < 2 { return false; }
     if ss.chars().count() <= sSuffix.chars().count() { return false; }
     if ss.indexOf(self.escape.charAt(0)) == -1 
       { return false; }
     let pos: i32 = ss.chars().count()-sSuffix.length();
     while (pos > -1) && (ss.charAt(pos) == self.escape.charAt(0)) {
       count += 1; pos -= 1;
     }
     if count % 2 == 0 { return false; }
     return true;
   }

   /* a helper to see how many trailing \\ escape chars */
   pub fn countEscaped(&mut self, sSuffix: String) -> u32 {
     let mut s = String::new();
     let count: i32 = 0;
     let index: i32 = self.work.lastIndexOf(sSuffix);
     // remove suffix if it exists
     if index > 0 {
       s = self.work.substring(0, index);
     }
     while s.ends_with(self.escape) {
       count += 1;
       s = s.substring(0, s.lastIndexOf(self.escape));
     }
     return count;
   }

   /** reads the input stream until the work end with text */
   // can test this with
   pub fn until(&mut self, sSuffix: String) {
     // read at least one character
     if self.eof { return; }
     self.readNext();
     loop {
       if self.eof { return; }
       if self.work.ends_with(sSuffix) {
         if self.countEscaped(sSuffix) % 2 == 0 { return; }
       }
       self.readNext();
     }
   }

   /** pop the first token from the stack into the workspace */
   pub fn pop(&mut self) -> bool {
     if self.stack.len() == 0 { return false; }
     self.work.insert_str(0, self.stack.pop().as_str());     
     if self.cell > 0 { self.cell -= 1; }
     return true;
   }

   // push the first token from the workspace to the stack 
   pub fn push(&mut self) -> bool {
     let sItem: String = String::new();
     // dont increment the tape pointer on an empty push
     if self.work.is_empty() { return false; }
     // need to get this from self.delim not "*"
     let iFirstStar: u32 = self.work.indexOf(self.delimiter);
     if iFirstStar != -1 {
       sItem = self.work.substring(0, iFirstStar + 1);
       self.work.delete(0, iFirstStar + 1);
     }
     else {
       sItem = self.work;
       self.work.clear();
     }
     self.stack.push(sItem);     
     self.increment(); 
     return true;
   }

   // swap not required, use mem::swap

   // save the workspace to file "sav.pp" */
   // not required.
   pub fn writeToFile(&mut self) {
     fs::write("sav.pp", self.work).expect("Unable to write file");
   }

   pub fn goToMark(&mut self, mark: String) {
     for (ii, thismark) in self.marks.iter().enumerate() {
       if thismark.eq(&mark) { self.cell = ii; return; }
     }
     print!("badmark '{}'!", mark); 
     process::exit(1);
   }

   /** parse/check/compile the input */
   pub fn parse(&mut self) {
     //this is where the actual parsing/compiling code should go 
     //but this means that all generated code must use
     //"self." not "mm."
     let ii = 1;
   }
 }

 fn main() -> io::Result<()> { 
    // BufReader::new(io::stdin())
    let temp: String = String::new();    
    let mm: Machine = Machine::new(BufReader::new(io::stdin())); 

    'script: 
    while !mm.eof {
      mm.read(); /* read */
      print!("{}", mm.work); /* print */
    }
  }
