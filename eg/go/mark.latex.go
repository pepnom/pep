
// code generated by "translate.go.pss" a pep script
// http://bumble.sf.net/books/pars/tr/


// s.HasPrefix can be used instead of strings.HasPrefix
package main
import (
  "fmt"
  "bufio"  
  "strings"
  "strconv"
  "unicode"
  "io"  
  "os"
  "unicode/utf8"
)

// an alias for Println for brevity
var pr = fmt.Println

  /* a machine for parsing */
  type machine struct {
    SIZE int
    eof bool
    charsRead int
    linesRead int
    escape rune 
    delimiter rune
    counter int
    work string
    stack []string
    cell int
    tape []string
    marks []string
    peep rune
    reader *bufio.Reader
  }

  // there is no special init for structures
  func newMachine(size int) *machine { 
    mm := machine{SIZE: size}
    // mm.SIZE = 200      // how many elements in stack/tape/marks
    mm.eof = false     // end of stream reached?
    mm.charsRead = 0   // how many chars already read
    mm.linesRead = 1   // how many lines already read
    mm.escape = '\\'
    mm.delimiter = '*'    // push/pop delimiter (default "*")
    mm.counter = 0        // a counter for anything
    mm.work = ""          // the workspace
    mm.stack = make([]string, 0, mm.SIZE)   // stack for parse tokens 
    mm.cell = 0                             // current tape cell
    // slices not arrays
    mm.tape = make([]string, mm.SIZE, mm.SIZE)  // a list of attribute for tokens 
    mm.marks = make([]string, mm.SIZE, mm.SIZE) // marked tape cells
    // or dont initialse peep until "parse()" calls "setInput()"
    // check! this is not so simple
    mm.reader = bufio.NewReader(os.Stdin)
    var err error
    mm.peep, _, err = mm.reader.ReadRune()
    if err == io.EOF { 
      mm.eof = true 
    } else if err != nil {
      fmt.Fprintln(os.Stderr, "error:", err)
      os.Exit(1)
    }
    return &mm
  }

  // method syntax.
  // func (v * vertex) abs() float64 { ... }
  // multiline strings are ok ?

  func (mm *machine) printSizeError() {
    /*
    fmt.Println("Tape max size exceeded! " +
    "tape maximum size = (mm.size) 
" +
    "tape cell (current) = (mm.cell) 
" +
    " You can increase the array value in the go script " +
    " but normally this error indicates an error in your parsing " +
    " script. The only exception would be massively nested structures " +
    "  in the source data.");
    */
  }

  func (mm *machine) setInput(newInput string) {
    print("to be implemented")
  }

  // read one utf8 character from the input stream and 
  // update the machine.
  func (mm *machine) read() { 
    var err error
    if mm.eof { os.Exit(0) }
    mm.charsRead += 1
    // increment lines
    if mm.peep == '\n' { mm.linesRead += 1 }
    mm.work += string(mm.peep)
    // check!
    mm.peep, _, err = mm.reader.ReadRune()
    if err == io.EOF { 
      mm.eof = true 
    } else if err != nil {
      fmt.Fprintln(os.Stderr, "error:", err)
      os.Exit(1)
    }
  }

  // remove escape character: trivial method ?
  // check the python code for this, and the c code in machine.interp.c
  func (mm *machine) unescapeChar(c string) {
    // if mm.work = "" { return }
    mm.work = strings.Replace(mm.work, "\\"+c, c, -1)
  }

  // add escape character : trivial
  func (mm *machine) escapeChar(c string) {
    mm.work = strings.Replace(mm.work, c, "\\"+c, -1)
  }

  /** a helper function to count trailing escapes */
  func (mm *machine) countEscapes(suffix string) int {
    count := 0
    ss := ""
    if strings.HasSuffix(mm.work, suffix) {
      ss = strings.TrimSuffix(mm.work, suffix)
    }
    for (strings.HasSuffix(ss, string(mm.escape))) { 
      ss = strings.TrimSuffix(ss, string(mm.escape))
      count++
    }
    return count
  }

  // reads the input stream until the workspace ends with the
  // given character or text, ignoring escaped characters
  func (mm *machine) until(suffix string) {
    if mm.eof { return; }
    // read at least one character
    mm.read()
    for true { 
      if mm.eof { return; }
      // we need to count the mm.Escape chars preceding suffix
      // if odd, keep reading, if even, stop
      if strings.HasSuffix(mm.work, suffix) {
        if (mm.countEscapes(suffix) % 2 == 0) { return }
      }
      mm.read()
    }
  }  

  /* pop the last token from the stack into the workspace */
  func (mm *machine) pop() bool { 
    if len(mm.stack) == 0 { return false }
    // no, get last element of stack
    // a[len(a)-1]
    mm.work = mm.stack[len(mm.stack)-1] + mm.work
    // a = a[:len(a)-1]
    mm.stack = mm.stack[:len(mm.stack)-1]
    if mm.cell > 0 { mm.cell -= 1 }
    return true
  }

  // push the first token from the workspace to the stack 
  func (mm *machine) push() bool { 
    // dont increment the tape pointer on an empty push
    if mm.work == "" { return false }
    // push first token, or else whole string if no delimiter
    aa := strings.SplitN(mm.work, string(mm.delimiter), 2)
    if len(aa) == 1 {
      mm.stack = append(mm.stack, mm.work)
      mm.work = ""
    } else {
      mm.stack = append(mm.stack, aa[0]+string(mm.delimiter))
      mm.work = aa[1]
    }
    mm.cell++
    if mm.cell > mm.SIZE {
      // fix!
      mm.printState()
    }
    return true
  }

  // no interpolation in go so change
  func (mm *machine) printState() { 
    fmt.Printf("Stack[mm.stack.join(, ))] Work[(mm.work)] Peep[(mm.peep)]")
    fmt.Printf("Acc:(mm.counter) Esc:((mm.escape) Delim:(mm.delimiter) Chars:(mm.CharsRead)" +
         " Lines:(mm.linesRead) Cell:(mm.cell)")
  } 

  // this is where the actual parsing/compiling code should go
  // so that it can be used by other go classes/objects. Also
  // should have a stream argument.
  func (mm *machine) parse(s string) {
  } 

  /* adapt for clop and clip */
  func trimLastChar(s string) string {
    r, size := utf8.DecodeLastRuneInString(s)
    if r == utf8.RuneError && (size == 0 || size == 1) {
        size = 0
    }
    return s[:len(s)-size]
  }

  func (mm *machine) clip() {
    cc, _ := utf8.DecodeLastRuneInString(mm.work)
    mm.work = strings.TrimSuffix(mm.work, string(cc))  
  }

  func (mm *machine) clop() {
    _, size := utf8.DecodeRuneInString(mm.work) 
    mm.work = mm.work[size:]  
  }

  type fn func(rune) bool
  // eg unicode.IsLetter('x')
  /* check whether the string s only contains runes of type
     determined by the typeFn function */
  func isInClass(typeFn fn, s string) bool {
    //loop through each char in s
    for _, rr := range s {
      //if !unicode.IsLetter(rr) {
      if !typeFn(rr) { return false }
    }
    return true
  }

  /* range in format 'a,z' */
  func isInRange(start rune, end rune, s string) bool {
    for _, rr := range s {
      if (rr < start) || (rr > end) { return false }
    }
    return true
  }

  /* list of runes (unicode chars ) */
  func isInList(list string, s string) bool {
    return strings.ContainsAny(s, list)
  }

func main() {
  var size = 200
  var mm = newMachine(size);
  var restart = false; 
  // the go compiler complains when modules are imported but
  // not used, also if vars are not used.
  if restart {}; unicode.IsDigit('0'); strconv.Itoa(0);
  // create a dummy newline so that doc structures work even
// on the first line of the file/stream.
mm.work += "nl*"
mm.push();
for !mm.eof { 
    
    /* lex block */
    for true { 
      mm.read()             /* read */
      if (!isInClass(unicode.IsSpace, mm.work)) {
        /* whilenot */
        for !isInClass(unicode.IsSpace, string(mm.peep)) {
          if mm.eof { break; }
          mm.read()
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "word*"
        mm.push();
        break
      }
      // keep leading space in newline token?
      if (isInList("\n", mm.work)) {
        /* while */
        for isInList(" ", string(mm.peep)) {
          if mm.eof { break }
          mm.read()
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "nl*"
        mm.push();
        break
      }
      if (isInList("\r\t ", mm.work)) {
        mm.work = ""          // clear
        restart = true; break // restart
      }
      break 
    }
    if restart { restart = false; continue; }
    // parse block 
    for true {
      // for debugging
      mm.work += "line "
      mm.work += strconv.Itoa(mm.linesRead) /* lines */
      mm.work += " char "
      mm.work += strconv.Itoa(mm.charsRead) /* chars */
      mm.work += ": "
      fmt.Printf("%s", mm.work)    // print
      mm.work = ""          // clear
      for mm.pop() {}   /* unstack */ 
      fmt.Printf("%s", mm.work)    // print
      for mm.push() {}  /* stack */
      mm.work += "\n"
      fmt.Printf("%s", mm.work)    // print
      mm.work = ""          // clear
      // -------------
      // 1 token
      mm.pop();
      if (mm.work == "nl*") {
        /* nop eliminated */
      }
      // here we classify words into other tokens
      if (mm.work == "word*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        // no numbers in headings!
        if (isInRange('A','Z', mm.work)) {
          mm.work = ""          // clear
          mm.work += "uuword*"
          mm.push();
          continue
        }
        // at least three --- on a newline marks a code block start
        if (strings.HasPrefix(mm.work, "---") && isInList("-", mm.work)) {
          mm.work = ""          // clear
          mm.work += "---*"
          mm.push();
          continue
        }
        // >> on a newline marks a code line start
        if (mm.work == ">>") {
          mm.work += "*"
          mm.push();
          continue
        }
        // star on newline marks emphasis, list or code description 
        if (mm.work == "*") {
          mm.work = ""          // clear
          mm.work += "star*"
          mm.push();
          continue
        }
        // subheading marker
        if (strings.HasPrefix(mm.work, "....") && isInList(".", mm.work)) {
          mm.work = ""          // clear
          mm.work += "4dots*"
          mm.push();
          continue
        }
        // need to escape % # } \ and others
        // & % $ # _ { } ~ ^ \   
        // \textasciitilde, \textasciicircum, and \textbackslash
        /* replace */
        mm.work = strings.Replace(mm.work, "\\", "\\textbackslash ", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "&", "\\&", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "%", "\\%", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "$", "\\$", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "#", "\\#", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "_", "\\_", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "{", "\\{", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "}", "\\}", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "~", "\\textasciitilde", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "^", "\\textasciicircum", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "LaTeX", "\\LaTeX{}", -1)
        
        //replace '\\n' "\\textbackslash n";
        //replace '\\f' "\\textbackslash f";
        //replace '\\r' "\\textbackslash r";
        //replace '\\t' "\\textbackslash t";
        mm.tape[mm.cell] = mm.work  /* put */
        // urls, not so important for LaTex but anyway 
        // dont really need tokens because we can render immediately
        // we could maybe render them as footnotes
        if (strings.HasPrefix(mm.work, "http://") || strings.HasPrefix(mm.work, "https://") || strings.HasPrefix(mm.work, "www.") || strings.HasPrefix(mm.work, "ftp://") || strings.HasPrefix(mm.work, "sftp://")) {
          // clear; add "url*"; push; .reparse
          // render as fixed pitch font
          mm.work = ""          // clear
          mm.work += "\\url{"
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "}"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
        }
        // filenames
        if (strings.HasSuffix(mm.work, "/") || strings.HasSuffix(mm.work, ".c") || strings.HasSuffix(mm.work, ".txt") || strings.HasSuffix(mm.work, ".html") || strings.HasSuffix(mm.work, ".pss") || strings.HasSuffix(mm.work, ".pp") || strings.HasSuffix(mm.work, ".js") || strings.HasSuffix(mm.work, ".java") || strings.HasSuffix(mm.work, ".tcl") || strings.HasSuffix(mm.work, ".py") || strings.HasSuffix(mm.work, ".pl") || strings.HasSuffix(mm.work, ".jpeg") || strings.HasSuffix(mm.work, ".jpg") || strings.HasSuffix(mm.work, ".png")) {
          mm.work = ""          // clear
          mm.work += "\\texttt{"
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "}"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
        }
        // filenames 
        if (strings.HasPrefix(mm.work, "../") && mm.work != "../") {
          mm.work = ""          // clear
          mm.work += "\\texttt{"
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "}"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
        }
        // filenames 
        // crude pattern checking.
        if (strings.HasPrefix(mm.work, "/") && mm.work != "/") {
          mm.clip()
          if (strings.HasSuffix(mm.work, ".")) {
            mm.work = ""          // clear
            mm.work += "\\texttt{"
            mm.work += mm.tape[mm.cell] /* get */
            mm.work += "}"
            mm.tape[mm.cell] = mm.work  /* put */
            mm.work = ""          // clear
          }
          mm.clip()
          if (strings.HasSuffix(mm.work, ".")) {
            mm.work = ""          // clear
            mm.work += "\\texttt{"
            mm.work += mm.tape[mm.cell] /* get */
            mm.work += "}"
            mm.tape[mm.cell] = mm.work  /* put */
            mm.work = ""          // clear
          }
          mm.clip()
          if (strings.HasSuffix(mm.work, ".")) {
            mm.work = ""          // clear
            mm.work += "\\texttt{"
            mm.work += mm.tape[mm.cell] /* get */
            mm.work += "}"
            mm.tape[mm.cell] = mm.work  /* put */
            mm.work = ""          // clear
          }
        }
        // emphasis is *likethis* (only words, not phrases) 
        if (strings.HasPrefix(mm.work, "*") && strings.HasSuffix(mm.work, "*") && mm.work != "**") {
          mm.clip()
          mm.clop()
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
          mm.work += "\\textbf{\\emph{"
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "}}"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
        }
        mm.work = ""          // clear
        mm.work += "word*"
      }
      mm.pop();
      // -------------
      // 2 tokens
      // ellide text
      if (mm.work == "word*word*" || mm.work == "text*word*" || mm.work == "word*uuword*" || mm.work == "text*uuword*" || mm.work == "uutext*word*" || mm.work == "uuword*word*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // remove insignificant nl* newline tokens. This may need more thought
      // We are using a dummy nl* token at the start of the doc, so the 
      // codeblock* codeline* etc tokens are not able to be the first token
      // of the document. So we can remove the !"codeblock*". clause.
      // remove insignificant codeblock* tokens
      if (strings.HasSuffix(mm.work, "codeblock*") && !strings.HasPrefix(mm.work,"emline*")) {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // remove insignificant codeline* tokens
      if (strings.HasSuffix(mm.work, "codeline*") && !strings.HasPrefix(mm.work,"emline*")) {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // remove insignificant emline* tokens (not followed by codeblock/line)
      // the logic is slightly diffferent because emline* is significant before
      // other tokens, not after.
      // also, consider emline*text*nl*
      if (strings.HasPrefix(mm.work, "emline*") && !strings.HasSuffix(mm.work,"nl*") && !strings.HasSuffix(mm.work,"codeline*") && !strings.HasSuffix(mm.work,"codeblock*")) {
        // clear; get; add " "; ++; get; --; put; clear;
        /* replace */
        mm.work = strings.Replace(mm.work, "emline*", "text*", -1)
        
        mm.push();
        mm.push();
        continue
      }
      // remove insignificant 4dots* tokens
      if (strings.HasSuffix(mm.work, "4dots*") && !strings.HasPrefix(mm.work,"uutext*") && !strings.HasPrefix(mm.work,"uuword*")) {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // remove insignificant star* tokens
      if (strings.HasSuffix(mm.work, "star*") && !strings.HasPrefix(mm.work,"nl*")) {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // remove insignificant ---* tokens
      if (strings.HasSuffix(mm.work, "---*") && !strings.HasPrefix(mm.work,"nl*")) {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // remove insignificant >>* tokens
      // lets assume that codelines cant start a document? Or lets
      // generate a dummy nl* token at the start of the document to 
      // make parsing easier.
      // !">>*".E">>*".!B"nl*" {
      if (strings.HasSuffix(mm.work, ">>*") && !strings.HasPrefix(mm.work,"nl*")) {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // ellide upper case text 
      if (mm.work == "uuword*uuword*" || mm.work == "uutext*uuword*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "uutext*"
        mm.push();
        continue
      }
      // ellide multiple newlines 
      if (mm.work == "nl*nl*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "nl*"
        mm.push();
        continue
      }
      // emphasis line (starts with *) 
      if (mm.work == "nl*star*") {
        mm.work = ""          // clear
        /* whilenot */
        for !isInList("\n", string(mm.peep)) {
          if mm.eof { break; }
          mm.read()
        }
        // need to escape % # } \ and others
        // & % $ # _ { } ~ ^ \  
        //# \textasciitilde, \textasciicircum, and \textbackslash
        /* replace */
        mm.work = strings.Replace(mm.work, "\\", "\\textbackslash ", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "&", "\\&", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "%", "\\%", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "$", "\\$", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "#", "\\#", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "_", "\\_", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "{", "\\{", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "}", "\\}", -1)
        
        //replace "[" "\\[";
        //replace "]" "\\]";
        /* replace */
        mm.work = strings.Replace(mm.work, "~", "\\textasciitilde", -1)
        
        /* replace */
        mm.work = strings.Replace(mm.work, "^", "\\textasciicircum", -1)
        
        //replace '\\n' "\\textbackslash n";
        //replace '\\f' "\\textbackslash f";
        //replace '\\t' "\\textbackslash t";
        //replace '\\r' "\\textbackslash r";
        /* replace */
        mm.work = strings.Replace(mm.work, "latex", "\\LaTeX{}", -1)
        
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "\n \\emph{"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " }"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "emline*"
        mm.push();
        continue
      }
      // code line (starts with >>) 
      if (mm.work == "nl*>>*") {
        mm.work = ""          // clear
        /* whilenot */
        for !isInList("\n", string(mm.peep)) {
          if mm.eof { break; }
          mm.read()
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "\n \\verb|"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " |\n"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "codeline*"
        mm.push();
        continue
      }
      // code block marker 
      if (mm.work == "nl*---*") {
        mm.work = ""          // clear
        mm.until(",,,");
        mm.clip()
        mm.clip()
        mm.clip()
        mm.tape[mm.cell] = mm.work  /* put */
        /* while */
        for isInList(",", string(mm.peep)) {
          if mm.eof { break }
          mm.read()
        }
        mm.work = ""          // clear
        mm.work += "\n \\begin{lstlisting}[breaklines] \n"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "\n \\end{lstlisting} \n"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "codeblock*"
        mm.push();
        continue
      }
      // a code block with its preceding description
      if (mm.work == "emline*codeblock*") {
        mm.work = ""          // clear
        mm.work += "\n \\begin{figure}"
        mm.work += "\n \\begin{tabular}{ l }"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " \\\\ "
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work += " \\end{tabular} \n"
        mm.work += "\n \\end{figure}"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      // a code line with its preceding description
      // add some tabular LaTeX markup here.
      if (mm.work == "emline*codeline*") {
        mm.work = ""          // clear
        mm.work += "\n \\begin{figure}"
        mm.work += "\n \\begin{tabular}{ l }"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " \\\\ "
        // add " \\\\ \\hline";
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work += " \\end{tabular} \n"
        mm.work += " \\end{figure}"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "text*"
        mm.push();
        continue
      }
      mm.pop();
      // -------------
      // 3 tokens
      // top level headings, all upper case on the line in the source document
      // dont need a "heading" token because we dont parse the document as a 
      // heirarchy, we just render things as we find them in the stream.
      if (mm.work == "nl*uutext*nl*" || mm.work == "nl*uuword*nl*") {
        mm.work = ""          // clear
        // Check that heading is at least 4 chars
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.clip()
        mm.clip()
        mm.clip()
        if (mm.work == "") {
          mm.work += "nl*text*nl*"
          mm.push();
          mm.push();
          mm.push();
          continue
        }
        mm.work = ""          // clear
        // make headings capital case
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        mm.work = strings.Title(strings.ToLower(mm.work)) // capital
        mm.tape[mm.cell] = mm.work  /* put */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        // newline
        mm.work += "\\section{"
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work += "}"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // transfer nl value
        mm.cell++                     /* ++ */
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work += "text*nl*"
        mm.push();
        mm.push();
        continue
      }
      // simple reductions 
      if (mm.work == "nl*text*nl*" || mm.work == "nl*word*nl*" || mm.work == "text*text*nl*" || mm.work == "emline*text*nl*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.cell++                     /* ++ */
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work = ""          // clear
        // transfer newline value
        mm.work += "text*nl*"
        mm.push();
        mm.push();
        continue
      }
      mm.pop();
      // -------------
      // 4 tokens
      // sub headings, 
      if (mm.work == "nl*uutext*4dots*nl*" || mm.work == "nl*uuword*4dots*nl*") {
        mm.work = ""          // clear
        // Check that sub heading text is at least 4 chars ?
        // yes but need to transfer 4dots and nl
        // ++; get; --; clip; clip; clip; 
        // "" { add "nl*text*nl*"; push; push; push; .reparse }
        mm.work = ""          // clear
        // make subheadings capital case
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        mm.work = strings.Title(strings.ToLower(mm.work)) // capital
        mm.tape[mm.cell] = mm.work  /* put */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        // newline
        mm.work += "\\subsection{"
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work += "}"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // transfer nl value
        mm.cell++                     /* ++ */
        mm.cell++                     /* ++ */
        mm.cell++                     /* ++ */
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work += "text*nl*"
        mm.push();
        mm.push();
        continue
      }
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      if (mm.eof) {
        mm.pop();
        mm.pop();
        mm.pop();
        if (mm.work == "text*nl*" || mm.work == "text*") {
          mm.work = ""          // clear
          // make a valid LaTeX document
          mm.work += ""
          mm.work += "\n  %% -------------------------------------------"
          mm.work += "\n  %%  latex generated by: mark.latex.pss "
          mm.work += "\n  %%   from source file : "
          mm.work += "\n  %%                  on: "
          mm.work += "\n  %% -------------------------------------------"
          mm.work += "\n"
          mm.work += "\n  \\documentclass[a4paper,12pt]{article}"
          mm.work += "\n  \\usepackage[margin=4pt,noheadfoot]{geometry}"
          mm.work += "\n  \\usepackage{color}                   %% to use colours, use 'xcolor' for more"
          mm.work += "\n  \\usepackage{multicol}                %% for multiple columns"
          mm.work += "\n  \\usepackage{keystroke}               %% for keyboard key images"
          mm.work += "\n  \\usepackage[toc]{multitoc}           %% for multi column table of contents"
          mm.work += "\n  \\usepackage{tocloft}                 %% to customize the table of contents"
          mm.work += "\n  \\setcounter{tocdepth}{2}             %% only display 2 levels in the contents"
          mm.work += "\n  \\setlength{\\cftbeforesecskip}{0cm}   %% make the toc more compact"
          mm.work += "\n  \\usepackage{listings}                %% for nice code listings"
          mm.work += "\n  \\usepackage{caption}                 %% "
          mm.work += "\n  \\lstset{"
          mm.work += "\n    captionpos=t,"
          mm.work += "\n    language=bash,"
          mm.work += "\n    basicstyle=\\ttfamily,           %% fixed pitch font"
          mm.work += "\n    xleftmargin=0pt,                %% margin on the left outside the frames"
          mm.work += "\n    framexleftmargin=10pt,"
          mm.work += "\n    framexrightmargin=10pt,"
          mm.work += "\n    framexbottommargin=5pt,"
          mm.work += "\n    framextopmargin=5pt,"
          mm.work += "\n    breaklines=true,                %% break long code lines"
          mm.work += "\n    breakatwhitespace=false,        %% break long code lines anywhere"
          mm.work += "\n    breakindent=10pt,               %% reduce the indent from 20pt to 10"
          mm.work += "\n    postbreak=\\mbox{{\\color{blue}\\small$\\Rightarrow$\\space}},  %% mark with arrow"
          mm.work += "\n    showstringspaces=false,            %% dont show spaces within strings"
          mm.work += "\n    framerule=2pt,                     %% thickness of the frames"
          mm.work += "\n    frame=top,frame=bottom,"
          mm.work += "\n    rulecolor=\\color{lightgrey}, "
          mm.work += "\n    % frame=l"
          mm.work += "\n    % define special comment delimiters '##(' and ')'"
          mm.work += "\n    % moredelim=[s][\\color{grey}\\itshape\\footnotesize\\ttfamily]{~(}{)},"
          mm.work += "\n  }   %% source code settings"
          mm.work += "\n  \\usepackage{graphicx}                %% to include images"
          mm.work += "\n  \\usepackage{fancybox}                %% boxes with rounded corners"
          mm.work += "\n  \\usepackage{wrapfig}                 %% flow text around tables, images"
          mm.work += "\n  \\usepackage{tabularx}                %% change width of tables"
          mm.work += "\n  \\usepackage[table]{xcolor}           %% alternate row colour tables"
          mm.work += "\n  \\usepackage{booktabs}                %% for heavier rules in tables"
          mm.work += "\n  \\usepackage[small,compact]{titlesec} %% sections more compact, less space"
          mm.work += "\n  \\usepackage{enumitem}                %% more compact and better lists"
          mm.work += "\n  \\setlist{noitemsep}                  %% reduce list item spacing"
          mm.work += "\n  \\usepackage{hyperref}     %% make urls into hyperlinks"
          mm.work += "\n  \\hypersetup{              %% add pdftex if only pdf output is required"
          mm.work += "\n     colorlinks=true,       %% set up the colours for the hyperlinks"
          mm.work += "\n     linkcolor=black,       %% internal document links black"
          mm.work += "\n     urlcolor=black,        %% url links black"
          mm.work += "\n     filecolor=red,"
          mm.work += "\n     citecolor=red,"
          mm.work += "\n     bookmarks=true, pdfpagemode=UseOutlines}"
          mm.work += "\n"
          mm.work += "\n  \\geometry{ left=1.0in,right=1.0in,top=1.0in,bottom=1.0in }"
          mm.work += "\n  %% define some colours to use"
          mm.work += "\n  \\definecolor{lightgrey}{gray}{0.70}"
          mm.work += "\n  \\definecolor{grey}{gray}{0.30}"
          mm.work += "\n"
          mm.work += "\n  \\titleformat{\\section}[frame]    %% titlesec: create framed section headings"
          mm.work += "\n     {\\normalfont}"
          mm.work += "\n     {\\filleft \\footnotesize \\enspace Section \\thesection\\enspace\\enspace}"
          mm.work += "\n     {3pt} {\\bfseries\\itshape\\filright}"
          mm.work += "\n"
          mm.work += "\n  \\title{The Pep parsing language and machine}"
          mm.work += "\n  \\author{mjbishop}"
          mm.work += "\n  \\date{June 2021}"
          mm.work += "\n  \\setlength{\\parindent}{4pt}"
          mm.work += "\n  %% \\setlength{\\parskip}{1ex}"
          mm.work += "\n"
          mm.work += "\n  %% label lists with stars"
          mm.work += "\n  \\renewcommand{\\labelitemi}{$\\star$}"
          mm.work += "\n"
          mm.work += "\n  \\parindent=10pt"
          mm.work += "\n  \\parskip=12pt"
          mm.work += "\n  \\begin{document}"
          mm.work += "\n"
          mm.work += "\n  "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n\\end{document} \n"
          fmt.Printf("%s", mm.work)    // print
          mm.work = ""          // clear
          mm.work += "\n\n %% Document parsed as text*!\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        mm.push();
        mm.push();
        mm.work += "Document parsed unusually!\n"
        mm.work += "Stack at line "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += " char "
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.work += ": "
        fmt.Printf("%s", mm.work)    // print
        mm.work = ""          // clear
        for mm.pop() {}   /* unstack */ 
        fmt.Printf("%s", mm.work)    // print
        for mm.push() {}  /* stack */
        mm.work += "\n"
        fmt.Printf("%s", mm.work)    // print
        mm.work = ""          // clear
        os.Exit(0)
      }
      break 
    } // parse
    
  }
}


// end of generated golang code
