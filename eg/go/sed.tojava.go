
// code generated by "translate.go.pss" a pep script
// http://bumble.sf.net/books/pars/tr/


// s.HasPrefix can be used instead of strings.HasPrefix
package main
import (
  "fmt"
  "bufio"  
  "strings"
  "strconv"
  "unicode"
  "io"  
  "os"
  "unicode/utf8"
)

// an alias for Println for brevity
var pr = fmt.Println

  /* a machine for parsing */
  type machine struct {
    SIZE int  // how many elements in stack/tape/marks
    eof bool
    charsRead int
    linesRead int
    escape rune 
    delimiter rune
    counter int
    work string
    stack []string
    cell int
    tape []string
    marks []string
    peep rune
    reader *bufio.Reader
  }

  // there is no special init for structures
  func newMachine(size int) *machine { 
    mm := machine{SIZE: size}
    mm.eof = false     // end of stream reached?
    mm.charsRead = 0   // how many chars already read
    mm.linesRead = 1   // how many lines already read
    mm.escape = '\\'
    mm.delimiter = '*'    // push/pop delimiter (default "*")
    mm.counter = 0        // a counter for anything
    mm.work = ""          // the workspace
    mm.stack = make([]string, 0, mm.SIZE)   // stack for parse tokens 
    mm.cell = 0                             // current tape cell
    // slices not arrays
    mm.tape = make([]string, mm.SIZE, mm.SIZE)  // a list of attribute for tokens 
    mm.marks = make([]string, mm.SIZE, mm.SIZE) // marked tape cells
    // or dont initialse peep until "parse()" calls "setInput()"
    // check! this is not so simple
    mm.reader = bufio.NewReader(os.Stdin)
    var err error
    mm.peep, _, err = mm.reader.ReadRune()
    if err == io.EOF { 
      mm.eof = true 
    } else if err != nil {
      fmt.Fprintln(os.Stderr, "error:", err)
      os.Exit(1)
    }
    return &mm
  }

  // method syntax.
  // func (v * vertex) abs() float64 { ... }
  // multiline strings are ok ?

  func (mm *machine) setInput(newInput string) {
    print("to be implemented")
  }

  // read one utf8 character from the input stream and 
  // update the machine.
  func (mm *machine) read() { 
    var err error
    if mm.eof { os.Exit(0) }
    mm.charsRead += 1
    // increment lines
    if mm.peep == '\n' { mm.linesRead += 1 }
    mm.work += string(mm.peep)
    // check!
    mm.peep, _, err = mm.reader.ReadRune()
    if err == io.EOF { 
      mm.eof = true 
    } else if err != nil {
      fmt.Fprintln(os.Stderr, "error:", err)
      os.Exit(1)
    }
  }

  // remove escape character: trivial method ?
  // check the python code for this, and the c code in machine.interp.c
  func (mm *machine) unescapeChar(c string) {
    // if mm.work = "" { return }
    mm.work = strings.Replace(mm.work, "\\"+c, c, -1)
  }

  // add escape character : trivial
  func (mm *machine) escapeChar(c string) {
    mm.work = strings.Replace(mm.work, c, "\\"+c, -1)
  }

  /** a helper function to count trailing escapes */
  func (mm *machine) countEscapes(suffix string) int {
    count := 0
    ss := ""
    if strings.HasSuffix(mm.work, suffix) {
      ss = strings.TrimSuffix(mm.work, suffix)
    }
    for (strings.HasSuffix(ss, string(mm.escape))) { 
      ss = strings.TrimSuffix(ss, string(mm.escape))
      count++
    }
    return count
  }

  // reads the input stream until the workspace ends with the
  // given character or text, ignoring escaped characters
  func (mm *machine) until(suffix string) {
    if mm.eof { return; }
    // read at least one character
    mm.read()
    for true { 
      if mm.eof { return; }
      // we need to count the mm.Escape chars preceding suffix
      // if odd, keep reading, if even, stop
      if strings.HasSuffix(mm.work, suffix) {
        if (mm.countEscapes(suffix) % 2 == 0) { return }
      }
      mm.read()
    }
  }  

  /* increment the tape pointer (command ++) and grow the 
     tape and marks arrays if necessary */
  func (mm *machine) increment() { 
    mm.cell++
    if mm.cell >= len(mm.tape) {
      mm.tape = append(mm.tape, "")
      mm.marks = append(mm.marks, "")
      mm.SIZE++
    }
  }

  /* pop the last token from the stack into the workspace */
  func (mm *machine) pop() bool { 
    if len(mm.stack) == 0 { return false }
    // no, get last element of stack
    // a[len(a)-1]
    mm.work = mm.stack[len(mm.stack)-1] + mm.work
    // a = a[:len(a)-1]
    mm.stack = mm.stack[:len(mm.stack)-1]
    if mm.cell > 0 { mm.cell -= 1 }
    return true
  }

  // push the first token from the workspace to the stack 
  func (mm *machine) push() bool { 
    // dont increment the tape pointer on an empty push
    if mm.work == "" { return false }
    // push first token, or else whole string if no delimiter
    aa := strings.SplitN(mm.work, string(mm.delimiter), 2)
    if len(aa) == 1 {
      mm.stack = append(mm.stack, mm.work)
      mm.work = ""
    } else {
      mm.stack = append(mm.stack, aa[0]+string(mm.delimiter))
      mm.work = aa[1]
    }
    mm.increment()
    return true
  }

  // 
  func (mm *machine) printState() { 
    fmt.Printf("Stack %v Work[%s] Peep[%c] \n", mm.stack, mm.work, mm.peep)
    fmt.Printf("Acc:%v Esc:%c Delim:%c Chars:%v", 
      mm.counter, mm.escape, mm.delimiter, mm.charsRead)
    fmt.Printf(" Lines:%v Cell:%v EOF:%v \n", mm.linesRead, mm.cell, mm.eof)
    for ii, vv := range mm.tape {
      fmt.Printf("%v [%s] \n", ii, vv)
      if ii > 4 { return; }
    }
  } 

  func (mm *machine) goToMark(mark string) {
    markFound := false
    for ii := range mm.marks {
      if mm.marks[ii] == mark {
        mm.cell = ii; markFound = true; break
      }
    } 
    if markFound == false {
      fmt.Printf("badmark '%s'", mark)
      os.Exit(1)
    }
  }

  // this is where the actual parsing/compiling code should go
  // so that it can be used by other go classes/objects. Also
  // should have a stream argument.
  func (mm *machine) parse(s string) {
  } 

  /* adapt for clop and clip */
  func trimLastChar(s string) string {
    r, size := utf8.DecodeLastRuneInString(s)
    if r == utf8.RuneError && (size == 0 || size == 1) {
        size = 0
    }
    return s[:len(s)-size]
  }

  func (mm *machine) clip() {
    cc, _ := utf8.DecodeLastRuneInString(mm.work)
    mm.work = strings.TrimSuffix(mm.work, string(cc))  
  }

  func (mm *machine) clop() {
    _, size := utf8.DecodeRuneInString(mm.work) 
    mm.work = mm.work[size:]  
  }

  type fn func(rune) bool
  // eg unicode.IsLetter('x')
  /* check whether the string s only contains runes of type
     determined by the typeFn function */

  func isInClass(typeFn fn, s string) bool {
    if s == "" { return false; }
    for _, rr := range s {
      //if !unicode.IsLetter(rr) {
      if !typeFn(rr) { return false }
    }
    return true
  }

  /* range in format 'a,z' */
  func isInRange(start rune, end rune, s string) bool {
    if s == "" { return false; }
    for _, rr := range s {
      if (rr < start) || (rr > end) { return false }
    }
    return true
  }

  /* list of runes (unicode chars ) */
  func isInList(list string, s string) bool {
    return strings.ContainsAny(s, list)
  }

func main() {
  // This size needs to be big for some applications. Eg 
  // calculating big palindromes. Really 
  // it should be dynamically allocated.
  var size = 30000
  var mm = newMachine(size);
  var restart = false; 
  // the go compiler complains when modules are imported but
  // not used, also if vars are not used.
  if restart {}; unicode.IsDigit('0'); strconv.Itoa(0);
  for !mm.eof { 
    
    /* lex block */
    for true { 
      mm.read()             /* read */
      // make char number relative to line, for error messages
      if (isInList("\n", mm.work)) {
        mm.charsRead = 0 /* nochars */
      }
      // newlines can separate commands in (gnu) sed so we will
      // just add a dummy ';' here. Also, no trailing ; is required
      if (isInList("\n", mm.work)) {
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += ";*"
        mm.push();
        break
      }
      // ignore extraneous white-space?
      if (isInClass(unicode.IsSpace, mm.work)) {
        mm.work = ""          // clear
        if (mm.eof) {
          break
        }
        restart = true; break // restart
      }
      // comments, convert to java comments
      if (mm.work == "#") {
        mm.work = ""          // clear
        mm.work += "/* "
        mm.until("\n");
        if (strings.HasSuffix(mm.work, "\n")) {
          mm.clip()
        }
        mm.work += " */\n"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // uncomment line below to include comments in output
        // add "comment*"; push; .reparse
      }
      // literal tokens '{' and '}' are used to group commands in
      // sed, ';' is used to separate commands and ',' to separate line
      // ranges. ! is the postfix negation operator for ranges
      if (mm.work == "," || mm.work == "{" || mm.work == "}" || mm.work == ";" || mm.work == "!") {
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work += "*"
        mm.push();
        break
      }
      // various actions: print, delete, swap
      if (mm.work == "=" || mm.work == "p" || mm.work == "P" || mm.work == "l" || mm.work == "d" || mm.work == "D" || mm.work == "F" || mm.work == "g" || mm.work == "G" || mm.work == "h" || mm.work == "H" || mm.work == "n" || mm.work == "N" || mm.work == "x" || mm.work == "z") {
        if (mm.work == "=") {
          mm.work = ""          // clear
          // print line-number + newline
          mm.work += "System.out.println(mm.linesRead);  /* '=' */"
        }
        if (mm.work == "d") {
          mm.work = ""          // clear
          // 'd' delete pattern-space, restart 
          // the if true trick is necessary to avoid 'unreachable statement'
          // java compile errors (when multiple 'd' commands are given)
          mm.work += "if (true) { mm.patternSpace.setLength(0); continue; } /* 'd' */"
        }
        if (mm.work == "D") {
          mm.work = ""          // clear
          // add "/* 'D' delete pattern-space to 1st \\n, restart */";
          mm.work += "if (mm.patternSpace.indexOf(\"\\n\") > -1) {\n"
          mm.work += "  mm.patternSpace.delete(0, mm.patternSpace.indexOf(\"\\n\"));\n"
          mm.work += "  mm.readNext = false; if (true) continue; \n"
          mm.work += "} else { mm.patternSpace.setLength(0); continue; } /* 'd' */"
        }
        if (mm.work == "F") {
          // F: print input filename + newline
          // maybe unsupported in java
          mm.work = ""          // clear
          mm.work += "System.out.println(\"<unknown-file>\");  /* F */"
        }
        if (mm.work == "g") {
          // g: replace patt-space with hold-space
          mm.work = ""          // clear
          mm.work += "mm.patternSpace.setLength(0); \n"
          mm.work += "mm.patternSpace.append(mm.holdSpace);  /* 'g' */"
        }
        if (mm.work == "G") {
          // G; append hold-space to patt-space + \\n"
          mm.work = ""          // clear
          mm.work += "mm.patternSpace.append(\"\\n\" + mm.holdSpace);  /* 'G' */"
        }
        if (mm.work == "h") {
          // h:  replace hold-space with patt-space
          mm.work = ""          // clear
          mm.work += "mm.holdSpace.setLength(0); \n"
          mm.work += "mm.holdSpace.append(mm.patternSpace);  /* 'h' */"
        }
        if (mm.work == "H") {
          // H:  append patt-space to hold-space + newline
          mm.work = ""          // clear
          mm.work += "mm.holdSpace.append(\"\\n\" + mm.patternSpace);  /* 'H' */"
        }
        if (mm.work == "l") {
          // print pattern-space unambiguously, synonym for p ?
          mm.work = ""          // clear
          mm.work += "System.out.println(mm.patternSpace); /* 'l' */"
        }
        if (mm.work == "n") {
          // n: print patt-space, get next line into patt-space
          mm.work = ""          // clear
          mm.work += "if (mm.autoPrint) { System.out.println(mm.patternSpace); }\n"
          mm.work += "mm.patternSpace.setLength(0);\n"
          mm.work += "mm.readLine();   /* 'n' */"
        }
        if (mm.work == "N") {
          // N: append next line to patt-space + newline
          mm.work = ""          // clear
          mm.work += "mm.patternSpace.append('\\n'); "
          mm.work += "mm.readLine();  /* 'N' */"
        }
        if (mm.work == "p") {
          mm.work = ""          // clear
          mm.work += "System.out.println(mm.patternSpace); /* 'p' */"
        }
        if (mm.work == "P") {
          // P: print pattern-space up to 1st newline"
          mm.work = ""          // clear
          mm.work += "if (mm.patternSpace.indexOf(\"\\n\") > -1) {\n"
          mm.work += "  System.out.println(\n"
          mm.work += "    mm.patternSpace.substring(0, mm.patternSpace.indexOf(\"\\n\")));\n"
          mm.work += "} else { System.out.println(mm.patternSpace); }"
        }
        if (mm.work == "x") {
          // x:  # swap pattern-space with hold-space
          mm.work = ""          // clear
          mm.work += "mm.swap();  /* x */"
        }
        if (mm.work == "z") {
          // z:  delete pattern-space, NO restart
          mm.work = ""          // clear
          mm.work += "mm.patternSpace.setLenth(0); /* z */"
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "action*"
        mm.push();
        break
      }
      // line numbers are also selectors
      if (isInRange('0','9', mm.work)) {
        /* while */
        for isInRange('0','9', string(mm.peep)) {
          if mm.eof { break }
          mm.read()
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "number*"
        mm.push();
        break
      }
      // $ is the last line of the file
      if (mm.work == "$") {
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "number*"
        mm.push();
        break
      }
      // patterns - only execute commands if lines match 
      if (mm.work == "/") {
        // save line/char number for error message 
        mm.work = ""          // clear
        mm.work += "near line/char "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ":"
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.until("/");
        if (!strings.HasSuffix(mm.work,"/")) {
          mm.work = ""          // clear
          mm.work += "Missing '/' to terminate "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "?\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        mm.clip()
        // java .matches method matches whole string not substring
        // so we need to add .* at beginning and end, but not if regex
        // begins with ^ or ends with $. complicated hey
        if (!strings.HasSuffix(mm.work,"$")) {
          mm.work += ".*$"
        }
        if (!strings.HasPrefix(mm.work,"^")) {
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
          mm.work += "^.*"
          mm.work += mm.tape[mm.cell] /* get */
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // add any delimiter for pattern here, or none
        mm.work += "\""
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "\""
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "pattern*"
        mm.push();
        break
      }
      // read transliteration commands
      if (mm.work == "y") {
        // save line/char number for error message 
        mm.work = ""          // clear
        mm.work += "near line "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ", char "
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // allow spaces between 'y' and '/' although gnu set doesn't
        mm.until("/");
        if (!strings.HasSuffix(mm.work,"/") || !isInList(" /", mm.work)) {
          mm.work = ""          // clear
          mm.work += "Missing '/' after 'y' transliterate command\n"
          mm.work += "Or trailing characters "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        // save line/char number for error message 
        mm.work = ""          // clear
        mm.work += "near line "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ", char "
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.until("/");
        if (!strings.HasSuffix(mm.work,"/")) {
          mm.work = ""          // clear
          mm.work += "Missing 2nd '/' after 'y' transliterate command "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        if (mm.work == "/") {
          mm.work = ""          // clear
          mm.work += "Sed syntax error? \n"
          mm.work += "  Empty regex after 'y' transliterate command "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        // replace pattern found
        mm.clip()
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "y/"
        mm.work += mm.tape[mm.cell] /* get */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // save line/char number for error message 
        mm.work += "near line "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ", char "
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.increment()     /* ++ */ 
        
        mm.tape[mm.cell] = mm.work  /* put */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work = ""          // clear
        mm.until("/");
        if (!strings.HasSuffix(mm.work,"/")) {
          mm.work = ""          // clear
          mm.work += "Missing 3rd '/' after 'y' transliterate command "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        mm.clip()
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        mm.work += "/"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "/"
        // y/// does not have modifiers (unlike s///)
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "action*"
        mm.push();
        break
      }
      // various commands that have an option word parameter 
      // e has two variants
      //  "e" { replace "e" "e;  # exec patt-space command and replace"; }
      if (mm.work == "b" || mm.work == "e" || mm.work == "q" || mm.work == "Q" || mm.work == "t" || mm.work == "T") {
        // ignore intervening space if any
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        /* while */
        for isInList(" ", string(mm.peep)) {
          if mm.eof { break }
          mm.read()
        }
        mm.work = ""          // clear
        // A bit more permissive that gnu-sed which doesn't allow
        // read to end in ';'.
        /* whilenot */
        for !isInList(" ;}", string(mm.peep)) {
          if mm.eof { break; }
          mm.read()
        }
        // word parameters are optional to these commands
        // just add a space to separate command from parameter
        if (mm.work != "") {
          mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
          mm.work += " "
          mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        }
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        mm.work += mm.tape[mm.cell] /* get */
        // hard to implement because java has no goto ?
        if (strings.HasPrefix(mm.work, "b")) {
          mm.work += ";  # branch to <label> or start"
        }
        if (strings.HasPrefix(mm.work, "e ")) {
          mm.work += ";  # exec <cmd> and insert into output"
        }
        if (mm.work == "e") {
          mm.work += ";  # exec patt-space command into patt-space"
        }
        if (mm.work == "q") {
          // q; print + quit
          mm.work = ""          // clear
          mm.work += "System.out.println(mm.patternSpace);\n"
          mm.work += "System.exit(0);"
        }
        if (strings.HasPrefix(mm.work, "q ")) {
          // q; print + quit with exit code
          mm.clop()
          mm.clop()
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
          mm.work += "System.out.println(mm.patternSpace);\n"
          mm.work += "System.exit("
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ");"
        }
        if (mm.work == "Q") {
          // Q; quit, dont print
          mm.work = ""          // clear
          mm.work += "System.exit(0);"
        }
        if (strings.HasPrefix(mm.work, "Q ")) {
          // Q; quit with exit code, dont print
          mm.clop()
          mm.clop()
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
          mm.work += "System.exit("
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ");"
        }
        if (strings.HasPrefix(mm.work, "t")) {
          mm.work += ";  # branch to <label> if substitution made or start"
        }
        if (strings.HasPrefix(mm.work, "T")) {
          mm.work += ";  # branch to <label> if NO substituion or start"
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "action*"
        mm.push();
        break
      }
      // read 'read <filename>' and write commands
      if (mm.work == ":" || mm.work == "r" || mm.work == "R" || mm.work == "w" || mm.work == "W") {
        // ignore intervening space if any
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        /* while */
        for isInList(" ", string(mm.peep)) {
          if mm.eof { break }
          mm.read()
        }
        mm.work = ""          // clear
        // A bit more permissive that gnu-sed which doesn't allow
        // read to end in ';'.
        /* whilenot */
        for !isInList(" ;}", string(mm.peep)) {
          if mm.eof { break; }
          mm.read()
        }
        if (mm.work == "") {
          mm.work = ""          // clear
          mm.work += "Sed syntax error? (at line:char "
          mm.work += strconv.Itoa(mm.linesRead) /* lines */
          mm.work += ":"
          mm.work += strconv.Itoa(mm.charsRead) /* chars */
          mm.work += ")\n"
          mm.work += "  no filename for read 'r' command. \n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        mm.work += " "
        mm.work += mm.tape[mm.cell] /* get */
        if (strings.HasPrefix(mm.work, ": ")) {
          mm.work += ";  # branch to <label>"
        }
        if (strings.HasPrefix(mm.work, "r ")) {
          mm.work += ";  # read file into patt-space"
        }
        if (strings.HasPrefix(mm.work, "R ")) {
          mm.work += ";  # insert file into output before next line"
        }
        if (strings.HasPrefix(mm.work, "w ")) {
          mm.work += ";  # write patt-space to file"
        }
        // mm.writeToFile(name)
        if (strings.HasPrefix(mm.work, "W ")) {
          mm.work += ";  # write 1st line of patt-space to file"
        }
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "action*"
        mm.push();
        break
      }
      // read substitution commands
      if (mm.work == "s") {
        // save line/char number for error message 
        mm.work = ""          // clear
        mm.work += "near line/char "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ":"
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // allow spaces between 's' and '/' ??? 
        mm.until("/");
        if (!strings.HasSuffix(mm.work,"/") || !isInList(" /", mm.work)) {
          mm.work = ""          // clear
          mm.work += "Missing '/' after 's' substitute command\n"
          mm.work += "Or trailing characters "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        // save line/char number for error message 
        mm.work = ""          // clear
        mm.work += "near line "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ", char "
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.until("/");
        if (!strings.HasSuffix(mm.work,"/")) {
          mm.work = ""          // clear
          mm.work += "Sed syntax error? \n"
          mm.work += "  Missing 2nd '/' after 's' substitute command "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        if (mm.work == "/") {
          mm.work = ""          // clear
          mm.work += "Sed syntax error? \n"
          mm.work += "  Empty regex after 's' substitute command "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        // replace pattern found
        mm.clip()
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "mm.substitute(\""
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "\", \""
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        // save line/char number for error message 
        mm.work += "near line/char "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ":"
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.increment()     /* ++ */ 
        
        mm.tape[mm.cell] = mm.work  /* put */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work = ""          // clear
        mm.until("/");
        if (!strings.HasSuffix(mm.work,"/")) {
          mm.work = ""          // clear
          mm.work += "Missing 3rd '/' after 's' substitute command "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        mm.clip()
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "\", \""
        // also need to read modifiers, eg g/i/p/[0-9] etc
        // need better logic to process these modifiers.
        /* while */
        for isInList("gip", string(mm.peep)) {
          if mm.eof { break }
          mm.read()
        }
        mm.work += "\");   /* s */ "
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "action*"
        mm.push();
        break
      }
      if (mm.work == "a" || mm.work == "c" || mm.work == "i") {
        // label, append, branch, change, insert, quit, write, test, write, read
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "Unimplemented command (near line:char "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ":"
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.work += ")\n"
        mm.work += "  The script does not recognise '"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "' yet.\n"
        fmt.Printf("%s", mm.work)    // print
        os.Exit(0)
      }
      if (mm.work != "") {
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "Sed syntax error? (near line:char "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ":"
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.work += ")\n"
        mm.work += "  unrecognised command '"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "'\n"
        fmt.Printf("%s", mm.work)    // print
        os.Exit(0)
      }
      // where token reduction begins
      break 
    }
    if restart { restart = false; continue; }
    // parse block 
    for true {
      // To visualise token reduction uncomment this below:
      mm.work += "// "
      mm.work += strconv.Itoa(mm.linesRead) /* lines */
      mm.work += ":"
      mm.work += strconv.Itoa(mm.charsRead) /* chars */
      mm.work += " "
      fmt.Printf("%s", mm.work)    // print
      mm.work = ""          // clear
      mm.work += "\n"
      for mm.pop() {}   /* unstack */ 
      fmt.Printf("%s", mm.work)    // print
      mm.clip()
      for mm.push() {}  /* stack */
      // commands do not have to be terminated with ';' at the end of a sed script.
      if (mm.eof) {
        mm.pop();
        if (mm.work == "action*") {
          mm.work += ";*"
          mm.push();
          mm.push();
          continue
        }
        mm.push();
      }
      mm.pop();
      mm.pop();
      mm.pop();
      mm.pop();
      mm.pop();
      mm.pop();
      // ----------------
      // 6 token reductions
      // these must be done first, to take precedence over 
      // eg pattern/{/commandset/}
      if (mm.work == "pattern*,*pattern*{*commandset*}*" || mm.work == "pattern*,*number*{*commandset*}*" || mm.work == "number*,*number*{*commandset*}*" || mm.work == "number*,*pattern*{*commandset*}*") {
        // also, need to indent the command set.
        mm.increment()     /* ++ */ 
        
        mm.increment()     /* ++ */ 
        
        mm.increment()     /* ++ */ 
        
        mm.increment()     /* ++ */ 
        
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        /* replace */
        mm.work = strings.Replace(mm.work, "\n", "\n  ", -1)
        
        // use a brace token as temporary storage, so that we can
        // indent the 1st line of the commandset
        // should add 2 spaces but 1st line is getting an extra one.
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += " "
        mm.work += mm.tape[mm.cell] /* get */
        mm.increment()     /* ++ */ 
        
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        // using an array of boolean states to remember if a 
        // pattern has been 'seen'
        if (strings.HasPrefix(mm.work, "pattern*,*pattern*")) {
          mm.work = ""          // clear
          mm.work += "if (mm.line.toString().matches("
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ") && (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == false))\n  {"
          mm.work += " mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] = true; }\n"
          mm.work += "if (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == true) {\n"
          // get commandset at tape+4
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += "\n}\n"
          // comes after so last line is matched 
          mm.work += "if (mm.line.toString().matches("
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += ") && (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == true))\n  {"
          mm.work += " mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] = false; }\n"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.counter++    /* a+ */
        }
        if (strings.HasPrefix(mm.work, "pattern*,*number*")) {
          mm.work = ""          // clear
          mm.work += "if (mm.line.toString()..matches("
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ") && (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == false))\n"
          mm.work += "  { mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] = true; }\n"
          mm.work += "if (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == true) {\n "
          // get commandset at tape+4
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += "\n}\n"
          // put here to match last line in range 
          mm.work += "if ((mm.linesRead > "
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += ") && (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == true))\n"
          mm.work += "  { mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] = false; }\n"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.counter++    /* a+ */
        }
        if (strings.HasPrefix(mm.work, "number*,*pattern*")) {
          mm.work = ""          // clear
          // but this logic doesn't include last line
          mm.work += "if ((mm.linesRead == "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ") && (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == false))\n"
          mm.work += "  { mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] = true; }\n"
          mm.work += "if (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == true) {\n "
          // get commandset at tape+4
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += "\n}\n"
          // after to match last line in range
          mm.work += "if (mm.line.toString().matches("
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += ") && (mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] == true))\n"
          mm.work += "  { mm.states["
          mm.work += strconv.Itoa(mm.counter) /* count */ 
          mm.work += "] = false; }\n"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.counter++    /* a+ */
        }
        if (strings.HasPrefix(mm.work, "number*,*number*")) {
          mm.work = ""          // clear
          mm.work += "if ((mm.linesRead >= "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ") && (mm.linesRead <= "
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += ")) {\n"
          // get commandset at tape+4
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += "\n}"
          mm.tape[mm.cell] = mm.work  /* put */
          mm.counter++    /* a+ */
        }
        mm.work = ""          // clear
        mm.work += "command*"
        mm.push();
        continue
      }
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      mm.pop();
      mm.pop();
      mm.pop();
      //---------------
      // 3 tokens: 
      //   we have to do this first before the action*;* rule 
      //   is reduced.
      // change to the equivalent eg: range*{*command*}*
      // This avoids have to rewrite all the java code construction
      if (mm.work == "range*action*;*" || mm.work == "number*action*;*" || mm.work == "pattern*action*;*") {
        // preserve range/number/pattern parse token
        mm.push();
        mm.work = ""          // clear
        // transfer action/command code to the correct tapecell
        mm.work += mm.tape[mm.cell] /* get */
        mm.increment()     /* ++ */ 
        
        mm.tape[mm.cell] = mm.work  /* put */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.work = ""          // clear
        mm.work += "{*commandset*}*"
        mm.push();
        mm.push();
        mm.push();
        continue
        // now we have on the stack, for example
        // range*{*commandset*}* which is already handled, and the 
        // code attributes should be in the right tape cells.
        // we could do: add "{*command*}*" but it doesnt matter....
      }
      // gnu sed allows empty braces, so we will too.
      // Another trick: push an empty commandset onto the stack
      // after a brace - that gets rid of this rule and also
      // the : command/command/ -> commandset/ rule
      if (mm.work == "range*{*}*" || mm.work == "number*{*}*" || mm.work == "pattern*{*}*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += " {}  # warning: empty braces- does nothing!"
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "command*"
        mm.push();
        continue
      }
      mm.push();
      mm.push();
      mm.push();
      mm.pop();
      mm.pop();
      //---------------
      // 2 token errors
      if (mm.work == "pattern*number*" || mm.work == "pattern*pattern*" || mm.work == "number*number*" || mm.work == "number*pattern*" || mm.work == "range*number*" || mm.work == "range*pattern*" || mm.work == "pattern*;*" || mm.work == "number*;*" || mm.work == "range*;*") {
        mm.work = ""          // clear
        mm.work += "Sed syntax error? (near line:char "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ":"
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.work += ")\n"
        mm.work += "  line selector/number/range with no action \n"
        mm.work += "  (missing ',' or misplaced ';' ?) \n"
        fmt.Printf("%s", mm.work)    // print
        os.Exit(0)
      }
      if (mm.work == "action*action*" || mm.work == "action*command*" || mm.work == "action*number*" || mm.work == "action*pattern*" || mm.work == "action*range*" || mm.work == "action*{*") {
        mm.work = ""          // clear
        mm.work += "Sed error (line "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ", chars "
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.work += "):\n"
        mm.work += "  Missing ';' after command?\n"
        fmt.Printf("%s", mm.work)    // print
        os.Exit(0)
      }
      if (mm.work == ",*}*" || mm.work == ",*{*" || mm.work == ",*;*" || mm.work == ",*,*" || mm.work == ";*,*" || mm.work == ";*{*" || mm.work == "range*,*") {
        mm.clip()
        mm.clop()
        mm.clop()
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "Sed error (line "
        mm.work += strconv.Itoa(mm.linesRead) /* lines */
        mm.work += ", chars "
        mm.work += strconv.Itoa(mm.charsRead) /* chars */
        mm.work += "):\n"
        mm.work += "  Unexpected character '"
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "' \n"
        fmt.Printf("%s", mm.work)    // print
        os.Exit(0)
      }
      //---------------
      // 2 token reductions
      // ignore empty commands (and multiple \n)
      if (mm.work == "command*;*" || mm.work == "commandset*;*" || mm.work == ";*;*") {
        mm.clip()
        mm.clip()
        mm.push();
        continue
      }
      if (mm.work == "action*;*") {
        mm.work = ""          // clear
        mm.work += "command*"
        mm.push();
        continue
      }
      // maybe need a new token type for clarity here 
      // eg: negated selector
      if (mm.work == "number*!*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.increment()     /* ++ */ 
        
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "number*"
        mm.push();
        continue
      }
      if (mm.work == "pattern*!*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.increment()     /* ++ */ 
        
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "pattern*"
        mm.push();
        continue
      }
      if (mm.work == "command*command*" || mm.work == "commandset*command*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.increment()     /* ++ */ 
        
        mm.work += "\n"
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "commandset*"
        mm.push();
        continue
      }
      mm.pop();
      //---------------
      // 3 token errors
      // eg: '/a/,/bb/p;' or '/[0-3]/,20p;' etc
      //---------------
      // 3 token reductions
      // commands dont need a ';' before a closing brace in gnu sed
      // so transmogrify
      if (mm.work == "command*command*}*" || mm.work == "command*action*}*" || mm.work == "commandset*action*}*" || mm.work == "commandset*command*}*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.increment()     /* ++ */ 
        
        mm.work += "\n"
        mm.work += mm.tape[mm.cell] /* get */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "commandset*}*"
        mm.push();
        mm.push();
        continue
      }
      if (mm.work == "range*action*}*" || mm.work == "number*action*}*" || mm.work == "pattern*action*}*") {
        mm.work = ""          // clear
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "{\n  "
        mm.increment()     /* ++ */ 
        
        mm.work += mm.tape[mm.cell] /* get */
        mm.work += "\n}"
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "command*}*"
        mm.push();
        mm.push();
        continue
      }
      if (mm.work == "{*action*}*") {
        // make commandset not command for grammar simplicity
        mm.work = ""          // clear
        mm.work += "{*commandset*}*"
        mm.push();
        mm.push();
        mm.push();
        continue
      }
      // a single command in braces can be just treated like a 
      // set of commands in braces, so lets change to make other
      // grammar rules simpler
      if (mm.work == "{*command*}*") {
        // make commandset not command for grammar simplicity
        mm.work = ""          // clear
        mm.work += "{*commandset*}*"
        mm.push();
        mm.push();
        mm.push();
        continue
      }
      mm.pop();
      //---------------
      // 4 token errors
      //---------------
      // 4 token reductions
      if (mm.work == "pattern*{*commandset*}*" || mm.work == "number*{*commandset*}*") {
        // indent brace commands in tapecell+2
        mm.increment()     /* ++ */ 
        
        mm.increment()     /* ++ */ 
        
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        /* replace */
        mm.work = strings.Replace(mm.work, "\n", "\n  ", -1)
        
        // indent 1st line using { token as temporary storage
        if mm.cell > 0 { mm.cell-- }  /* -- */
        mm.tape[mm.cell] = mm.work  /* put */
        mm.work = ""          // clear
        mm.work += "  "
        mm.work += mm.tape[mm.cell] /* get */
        mm.increment()     /* ++ */ 
        
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work  /* swap */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        if mm.cell > 0 { mm.cell-- }  /* -- */
        if (mm.work == "pattern*{*commandset*}*") {
          mm.work = ""          // clear
          mm.work += "if (mm.line.toString().matches("
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ")) {\n"
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += "\n}"
          mm.tape[mm.cell] = mm.work  /* put */
        }
        if (mm.work == "number*{*commandset*}*") {
          mm.work = ""          // clear
          mm.work += "if (mm.linesRead == "
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += ") {\n"
          mm.increment()     /* ++ */ 
          
          mm.increment()     /* ++ */ 
          
          mm.work += mm.tape[mm.cell] /* get */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          if mm.cell > 0 { mm.cell-- }  /* -- */
          mm.work += "\n}"
          mm.tape[mm.cell] = mm.work  /* put */
        }
        mm.work = ""          // clear
        mm.work += "command*"
        mm.push();
        continue
      }
      mm.pop();
      mm.pop();
      // ----------------
      // 6 token reductions
      // none because we have to do them first.
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      mm.push();
      if (mm.eof) {
        // check for valid sed script
        mm.work += "/* The token parse-stack was: "
        fmt.Printf("%s", mm.work)    // print
        mm.work = ""          // clear
        for mm.pop() {}   /* unstack */ 
        mm.work += " */\n"
        fmt.Printf("%s", mm.work)    // print
        mm.clip()
        mm.clip()
        mm.clip()
        mm.clip()
        if (mm.work != "commandset*" && mm.work != "command*") {
          mm.work = ""          // clear
          mm.work += "# [error] Sed syntax error? \n"
          mm.work += "# ----------------- \n"
          mm.work += "# Also, uncomment lines after parse> label in script\n"
          mm.work += "# to see how the sed script is being parsed. \n"
          fmt.Printf("%s", mm.work)    // print
          os.Exit(0)
        }
        if (mm.work == "commandset*" || mm.work == "command*") {
          mm.work = ""          // clear
          // indent the generated code
          mm.work += "\n"
          mm.work += mm.tape[mm.cell] /* get */
          /* replace */
          mm.work = strings.Replace(mm.work, "\n", "\n       ", -1)
          
          mm.tape[mm.cell] = mm.work  /* put */
          mm.work = ""          // clear
          // create the java preamble, with a 'sedmachine' having a 
          // holdspace and patternspace
          mm.work += ""
          mm.work += "\n"
          mm.work += "\n /* [ok] Sed syntax appears ok */"
          mm.work += "\n /* ---------------------      */"
          mm.work += "\n /* Java code generated by \"sed.tojava.pss\" */"
          mm.work += "\n import java.io.*;"
          mm.work += "\n import java.util.regex.*;"
          mm.work += "\n import java.util.*;   // contains stack"
          mm.work += "\n"
          mm.work += "\n public class javased {"
          mm.work += "\n   public StringBuffer patternSpace;"
          mm.work += "\n   public StringBuffer holdSpace;"
          mm.work += "\n   public StringBuffer line;         /* current line unmodified */"
          mm.work += "\n   public int linesRead;"
          mm.work += "\n   private boolean[] states;         /* pattern-seen state */"
          mm.work += "\n   private Scanner input; "
          mm.work += "\n   private boolean eof;              /* end of file reached? */"
          mm.work += "\n   private boolean hasSubstituted;   /* a sub on this cycle? */"
          mm.work += "\n   private boolean lastLine;         /* last line of input (for $) */"
          mm.work += "\n   private boolean readNext;         /* read next line or not */"
          mm.work += "\n   private boolean autoPrint;        /* autoprint pattern space? */"
          mm.work += "\n"
          mm.work += "\n   /** make a new machine with a character stream reader */"
          mm.work += "\n   public javased(Scanner scanner) {"
          mm.work += "\n     this.patternSpace = new StringBuffer(\"\"); "
          mm.work += "\n     this.holdSpace = new StringBuffer(\"\"); "
          mm.work += "\n     this.line = new StringBuffer(\"\"); "
          mm.work += "\n     this.linesRead = 0;"
          mm.work += "\n     this.input = scanner;"
          mm.work += "\n     this.eof = false;"
          mm.work += "\n     this.hasSubstituted = false;"
          mm.work += "\n     this.readNext = true;"
          mm.work += "\n     this.autoPrint = true;"
          mm.work += "\n     // assume that a sed script has no more than 1K range tests! */"
          mm.work += "\n     this.states = new boolean[1000];"
          mm.work += "\n     for (int ii = 0; ii < 1000; ii++) { this.states[ii] = false; }"
          mm.work += "\n   }"
          mm.work += "\n"
          mm.work += "\n   /** read one line from the input stream and update the machine. */"
          mm.work += "\n   public void readLine() {"
          mm.work += "\n     int iChar;"
          mm.work += "\n     if (this.eof) { System.exit(0); }"
          mm.work += "\n     // increment lines"
          mm.work += "\n     this.linesRead++;"
          mm.work += "\n     if (this.input.hasNext()) {"
          mm.work += "\n       this.line.setLength(0);"
          mm.work += "\n       this.line.append(this.input.nextLine());"
          mm.work += "\n       this.patternSpace.append(this.line);"
          mm.work += "\n     } else { this.eof = true; }"
          mm.work += "\n   }"
          mm.work += "\n"
          mm.work += "\n   /** command \"x\": swap the pattern-space with the hold-space */"
          mm.work += "\n   public void swap() {"
          mm.work += "\n     String s = new String(this.patternSpace);"
          mm.work += "\n     this.patternSpace.setLength(0);"
          mm.work += "\n     this.patternSpace.append(this.holdSpace.toString());"
          mm.work += "\n     this.holdSpace.setLength(0);"
          mm.work += "\n     this.holdSpace.append(s);"
          mm.work += "\n   }"
          mm.work += "\n"
          mm.work += "\n   /** command \"s///x\": make substitutions on the pattern-space */"
          mm.work += "\n   public void substitute(String first, String second, String flags) {"
          mm.work += "\n     // flags can be gip etc"
          mm.work += "\n     // gnu sed modifiers M,<num>,e,w filename may be tricky here."
          mm.work += "\n"
          mm.work += "\n     String temp = new String(\"\");"
          mm.work += "\n     String old = new String(this.patternSpace);"
          mm.work += "\n"
          mm.work += "\n     // case insensitive: add \"(?i)\" at beginning"
          mm.work += "\n     if ((flags.indexOf('i') > -1) ||"
          mm.work += "\n         (flags.indexOf('I') > -1)) { first = \"(?i)\" + first; }"
          mm.work += "\n"
          mm.work += "\n     // multiline matching, check!!"
          mm.work += "\n     if ((flags.indexOf('m') > -1) ||"
          mm.work += "\n         (flags.indexOf('M') > -1)) { first = \"(?m)\" + first; }"
          mm.work += "\n"
          mm.work += "\n     // <num>- replace only nth match"
          mm.work += "\n     // todo"
          mm.work += "\n"
          mm.work += "\n     // g- global, replace all."
          mm.work += "\n     if (flags.indexOf('g') == -1) {"
          mm.work += "\n       temp = this.patternSpace.toString().replaceFirst(first, second);"
          mm.work += "\n     } else {"
          mm.work += "\n       temp = this.patternSpace.toString().replaceAll(first, second);"
          mm.work += "\n     }"
          mm.work += "\n     this.patternSpace.setLength(0);"
          mm.work += "\n     this.patternSpace.append(temp);"
          mm.work += "\n     if  (!old.equals(this.patternSpace.toString())) {"
          mm.work += "\n       this.hasSubstituted = true;"
          mm.work += "\n       // only print if substitution made, patternspace different ?"
          mm.work += "\n       if (flags.indexOf('p') != -1) {"
          mm.work += "\n         System.out.println(this.patternSpace);"
          mm.work += "\n       }"
          mm.work += "\n       // execute pattern space, gnu ext"
          mm.work += "\n       if (flags.indexOf('e') != -1) {"
          mm.work += "\n       }"
          mm.work += "\n       // write pattern space to file, gnu ext"
          mm.work += "\n       // need to scan filename"
          mm.work += "\n       if (flags.indexOf('w') != -1) {"
          mm.work += "\n       }"
          mm.work += "\n     }"
          mm.work += "\n   }"
          mm.work += "\n"
          mm.work += "\n   /** command \"W\": save 1st line of patternspace to filename */"
          mm.work += "\n   public void writeFirstToFile(String fileName) {"
          mm.work += "\n     try {"
          mm.work += "\n       File file = new File(fileName);"
          mm.work += "\n       Writer out = new BufferedWriter(new OutputStreamWriter("
          mm.work += "\n          new FileOutputStream(file), \"UTF8\"));"
          mm.work += "\n       // get first line of ps"
          mm.work += "\n       out.append(this.patternSpace.toString());"
          mm.work += "\n       out.flush(); out.close();"
          mm.work += "\n     } catch (Exception e) {"
          mm.work += "\n       System.out.println(e.getMessage());"
          mm.work += "\n     }"
          mm.work += "\n   }"
          mm.work += "\n"
          mm.work += "\n   /** command \"w\": save the patternspace to filename */"
          mm.work += "\n   public void writeToFile(String fileName) {"
          mm.work += "\n     try {"
          mm.work += "\n       File file = new File(fileName);"
          mm.work += "\n       Writer out = new BufferedWriter(new OutputStreamWriter("
          mm.work += "\n          new FileOutputStream(file), \"UTF8\"));"
          mm.work += "\n       out.append(this.patternSpace.toString());"
          mm.work += "\n       out.flush(); out.close();"
          mm.work += "\n     } catch (Exception e) {"
          mm.work += "\n       System.out.println(e.getMessage());"
          mm.work += "\n     }"
          mm.work += "\n   }"
          mm.work += "\n"
          mm.work += "\n   public static void main(String[] args) throws Exception { "
          mm.work += "\n     String temp = \"\";    "
          mm.work += "\n     javased mm = new javased(new Scanner(System.in)); "
          mm.work += "\n     while (!mm.eof) {"
          mm.work += "\n       mm.hasSubstituted = false;"
          mm.work += "\n       mm.patternSpace.setLength(0);"
          mm.work += "\n       // some sed commands restart without reading a line..."
          mm.work += "\n       // hence the use of a flag."
          mm.work += "\n       if (mm.readNext) { mm.readLine(); }"
          mm.work += "\n       mm.readNext = true;"
          mm.work += "\n"
          mm.work += mm.tape[mm.cell] /* get */
          mm.work += "\n       if (mm.autoPrint) { System.out.println(mm.patternSpace); }"
          mm.work += "\n     }\n   }\n }\n"
          fmt.Printf("%s", mm.work)    // print
        }
        os.Exit(0)
      }
      break 
    } // parse
    
  }
}


// end of generated 'go' code
