
<!-- Html generated by bumble.sf.net/books/parse/eg/mark.html.pss --> 
<!-- Token stack was: text* -->


 <!DOCTYPE html>
 <html>
 <head>

    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta name="generator" content="bumble.sf.net/books/pars/eg/mark.html.pss">
    <meta name="author" content="mjb ~ http://bumble.sf.net">
    <meta name="revision" content="">
    <title>...</title>

    <style>
    /* 
     *  a style sheet for an html book */
    body 
      { margin-left: 5%; margin-right: 5%; }
    h1.doc-title 
      { color: lightslategray; text-align: center; font-size: large; } 
    h3.section-heading { 
      border: 1px solid grey; margin-left: -1em; 
      border-radius: 1em;
      box-shadow: black 0.5em 0.5em 0.3em;
    }
    h4.sub-section-heading { 
      border: 1px dotted grey; 
      border-radius: 1em;
      font-style: italic; font-variant: small-caps;
    }

    ul.top-menu
     { padding: 1px .2em; margin-left: 0; border-bottom: 4px solid gray; }
    ul.top-menu li
     { list-style: none; margin: 0; display: inline; }
    ul.top-menu li a {
      padding: 1px 0.2em; margin-left: 0.1em; border: 1px solid gray;
      border-radius: 6px;
      border-bottom: none; text-decoration: none;
    }
    ul.top-menu li a:hover { 
      background-color: silver; 
    }

    PRE.code-line 
      { margin-right: 7em; margin-left: 2em; font-size: normal; }

    EM.comment 
      { font-size: medium; }

    EM.code-description
      { font-weight: normal; border-bottom: 1px solid lightgrey; width: 90% }

    EM.code-description:before
    /*  { content:"&gt;" } */

    SPAN.big-quote
      { font-size: xlarge; }

    TABLE.definition-table
      { width: 40%; float: right; border: 1px solid silver; border-collapse: collapse; }

    .definition-table td
      { border: 1px solid silver; padding: 0 .5em 0 .5em; }
    .definition-table th 
      { border: 1px solid silver; }
    .definition-table caption
      { font-style: oblique; font-weight: bold; }

    DIV#toc
      { float: right; border: 2px dashed gray; margin-left: 1em }
    #toc ul 
      { list-style-type: none;
        margin: 0 0 0 0; padding-left: 1em; border: 2px dashed white; }
    #toc li
      { } 
    #toc li a 
      { color: darkslategray; text-decoration: none; } 
    #toc li a:hover 
      { color: black; text-decoration: underline; } 
    #toc h4
      { font-variant: small-caps; padding-left: 0.5em }

    /* the link on each heading which leads back to the table of contents */
    A.toc-link
     { text-decoration: none; color: lightblue; text-align: right; }
    A:hover.toc-link
     { background-color: lightgray; }  

    dl.document-info-list
     { width: 40%; font-size: small }
    dl.document-info-list dt 
     { float: left; padding-right: 1em; text-align: right;
       background: whitesmoke; margin-bottom: 3px; }
    dl.document-info-list dd
     { background: whitesmoke; margin-bottom: 3px; font-family: courier, monospace; }


    dl.weblist
     { margin-left: 1em; padding-left: 1em; border-left: 4px solid lightgrey; }
    dl.weblist dd
     { margin-left: 0; padding-left: 1em; font-style: oblique }
    dl.weblist a
     { color: gray; text-decoration: none; }

    /* an element which floats to the right */
    .float-right { 
       float: right; width: 30%; 
       margin: 0 0 .5em .5em; padding: .5em;
       background-color: white; border: 1px solid #666;
    }

    /* an element which floats to the left */
    .float-left { 
       float: left; width: 30%; 
       margin: 0 0 .5em .5em; padding: .5em;
       background-color: white; border: 1px solid #666;
    }

    div.figure-left {
      float: left;
      width: 30%;
      text-align: center;
      font-style: italic;
      font-size: smaller;
      text-indent: 0;
      border: thin silver solid;
      margin: 0.5em;
      padding: 0.5em;
    }

    div.figure-right {
      float: right;
      width: 30%;
      text-align: center;
      font-style: italic;
      font-size: smaller;
      text-indent: 0;
      border: thin silver solid;
      margin: 0.5em;
      padding: 0.5em;
    }

   </style>
   </head>
   <body>
     <a name="toc"></a>
     <ul class="top-menu">
     <li><a href="/books/pars/" title="Pep">Pep home</a></li>
     <li><a href="/books/pars/eg/" title="Pep examples">Pep example scripts</a></li>
     <li><a href="/books/pars/pars-book.txt">Text Doc</a> </li>
     </ul>

   

<p>
 ==: The Parsing Virtual Machine and Script Language 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='AN OVERVIEW'></a>
<h3 class="section-heading">AN OVERVIEW <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 This booklet is about the pattern-parsing virtual machine and script 
 language "pep" . The executable file is /books/pars/pep and is compiled 
 from the c source code <a href='/books/pars/object/pep.c'>pep.c</a> 

<p>
 The virtual machine and language allows simple "LR" bottom-up shift 
 reduce parsers to be implemented in a limited script language with 
 a syntax which is very similar to the "sed" unix stream editor. 

<p>
 <div class='figure-right'><p><img src='img/pp.interactive.screenshot.png' alt=''><p>"Pep in interactive mode"</div>
 

<p>
 As far as I am aware, this is a new approach to parsing context-free 
 languages and according to the scripts and tests so far written has 
 great potential. The script language is deliberately limited in 
 a number of ways (it does not have regular expressions, for example), but 
 it seems to be an interesting tool for learning about compiler techniques. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DOCUMENTATION'></a>
<h3 class="section-heading">DOCUMENTATION <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 This file "pars-book.txt" is the principle documention about the 
 pattern-parser machine and language. This should also be available 
 as html at <a href='http://bumble.sf.net/books/pars/pars-book.html'>http://bumble.sf.net/books/pars/pars-book.html</a> 

<p>
 There is also a lot of documentation in the "pep.c" file (which implements 
 the virtual machine) as well as in the "compile.pss" file, which converts 
 scripts into machine assembler programs which can then be loaded by the 
 pep tool. 

<p>
 Also, most example scripts in the <a href='/books/pars/eg/'><em><tt>/books/pars/eg/</tt></em></a> folder also have 
 notes at the beginning of the script. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMMAND LINE USAGE'></a>
<h3 class="section-heading">COMMAND LINE USAGE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>specify script and input on the command line </em></td></tr>
<tr><td><pre class="code-line">
   pep -e "read; print; print; clear;" -i "abcXYZ"  
   # prints "aabbccXXYYZZ"
  </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>load a script from file and start an interactive session to view/debug </em></td></tr>
<tr><td><pre class="code-line">pep -If scriptfile somefile.txt</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>load an "assembly" file into the machines program and view/debug. </em></td></tr>
<tr><td><pre class="code-line">pep -Ia asmfile somefile.pss</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>convert a script to compilable java code</em></td></tr>
<tr><td><pre class="code-line">pep -f translate.java.pss script </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ONE LINE EXAMPLES'></a>
<h3 class="section-heading">ONE LINE EXAMPLES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The pep tool may have useful applications in unix "one-liners" but 
 its main power is in the implementation of simple context free 
 languages and compilers. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>remove multiple consecutive instances of any character</em></td></tr>
<tr><td><pre class="code-line">read; !(==) { put; print; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>double space a text file</em></td></tr>
<tr><td><pre class="code-line">pep -e "r;'\n'{a'\n';}t;d;" /usr/share/dict/words </pre></td></tr>
</table>
 
<table><td><pre class="code-line">pep -e "r;'\n'{t;}t;d;" /usr/share/dict/words # better</pre></td></table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>the same as above with long command names. </em></td></tr>
<tr><td><pre class="code-line">pep -e "read; '\n' { add '\n'; } print; clear;" someFile</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print a string in reverse order</em></td></tr>
<tr><td><pre class="code-line">read; get; put; clear; &lt;eof&gt; { get; print; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>convert tabs to 2 spaces </em></td></tr>
<tr><td><pre class="code-line">read; [\t]{d;a '  ';} t;d;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print all dictionary words which end with "ess".</em></td></tr>
<tr><td><pre class="code-line">pep -e 'r; ![:space:] { whilenot [:space:]; [a-z].E"ess"{add "\n";t; }} d;' /usr/share/dict/words </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>convert all whitespace (eg [ \r\n\t\f]) to dots</em></td></tr>
<tr><td><pre class="code-line">read; [:space:] {d;a'.';} t;d;</pre></td></tr>
</table>
 
<table><td><pre class="code-line">read; [:space:] {clear; add '.';} print; clear; </pre></td></table>
 
<table><td><pre class="code-line">read; [ \r\b\t\f] {clear; add '.';} print; clear; </pre></td></table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>double every instance of vowels   </em></td></tr>
<tr><td><pre class="code-line">pep -e "read; [aeiou] { put; get; } print;clear;" -i "a tree"</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Only print text within single quotes:</em></td></tr>
<tr><td><pre class="code-line">read; "'" { until "'"; print; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>remove multiple consecutive instances of the character "a":</em></td></tr>
<tr><td><pre class="code-line">read; print; "a" { while [a]; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Number each line of the input:</em></td></tr>
<tr><td><pre class="code-line">read; "\n" { lines; add " "; } print; clear;</pre></td></tr>
</table>
 
<table><td><pre class="code-line">read; "\n" { lines; a " "; } t; d;  # the same, with short commands</pre></td></table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Count the number of lines in the input stream</em></td></tr>
<tr><td><pre class="code-line">read; "\n" { a+; } clear; (eof) { add "lines: "; count; print; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Delete leading whitespace (spaces, tabs) from the start of each line: </em></td></tr>
<tr><td><pre class="code-line">read; print; "\n" { while [:space:]; } clear; </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Delete whitespace from the input stream</em></td></tr>
<tr><td><pre class="code-line">r; ![:space:] {print;} d;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>insert 5 blank spaces at beginning of each line (make page offset):</em></td></tr>
<tr><td><pre class="code-line">r; "\n" { add '     '; } print; clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print only the first ten lines of the input stream</em></td></tr>
<tr><td><pre class="code-line">read; print; clear; lines; "10" {quit;} clear; </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Delete trailing whitespace (spaces, tabs) from end of each line: </em></td></tr>
<tr><td><pre class="code-line">
   read;
   [ \t] { while [ \t\r]; read; E"\n" { clear; add "\n"; } }
   print; clear;
 </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DOWNLOAD'></a>
<h3 class="section-heading">DOWNLOAD <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 A ".tar.gz" archive file of the c source code can be downloaded from 
 the <a href='https://sourceforge.net/projects/bumble/'>https://sourceforge.net/projects/bumble/</a> folder. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMPILING SOURCE CODE'></a>
<h3 class="section-heading">COMPILING SOURCE CODE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 Hopefully, in the future, I will package this using "autotools" and 
 "automake" to allow the creation of packages for apt, brew etc. The main 
 folder, source file and booklet are called pars/ pars/object/pep.c and pars-book.txt 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>obtain, extract and compile the "pep" source code </em></td></tr>
<tr><td><pre class="code-line">
   # extract the tar ball
   tar xvzf pep.tar.gz
   cd pars/object
   # compile the pep tool using the object files in the "object" folder.
   make pep
   cd ..
   # create a symlink if you like into the bin folder.
   ln -s pep /usr/local/bin/pep
  </pre></td></tr>
</table>
 

<p>
 At the moment (June 2021) the pep executable looks for the file 
 <a href='asm.pp'><em><tt>asm.pp</tt></em></a> in the same folder where it is run or in the folder contained 
 in the environment variable $ASMPP. I have not yet written "make install" 
 in the Makefile in the pars/object/ folder to copy ./pep and asm.pp to 
 /usr/local/bin and usr/local/etc 

<p>
 A very basic "Makefile" is available in the <a href='/books/pars/object/'><em><tt>/books/pars/object/</tt></em></a> 
 folder. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>build the pep tool</em></td></tr>
<tr><td><pre class="code-line">cd pars/object/; make pep</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>manually rebuild the libmachine.a library file </em></td></tr>
<tr><td><pre class="code-line">
    cd pars/object
    # rebuild all object files
    gcc -c *.c
    # not all of these files are really necessary. 
    ar rcs libmachine.a buffer.o charclass.o colours.o command.o \
      exitcode.o instruction.o labeltable.o machine.o machine.interp.o \
      machine.methods.o parameter.o program.o tape.o tapecell.o
  </pre></td></tr>
</table>
 

<p>
 The libmachine.a file can be used when compiling executables from 
 c source code generated by the script "translate.c.pss" 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TRANSFORMATIONS AND COMPILATIONS'></a>
<h3 class="section-heading">TRANSFORMATIONS AND COMPILATIONS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The "pep" virtual machine and language is designed to 
 transform one textual (data) format into another, or compile/"transpile" 
 one context-free language into another. 

<p>
 Examples might be: <em class='code-description'>transform a csv (comma-separated-values) file into a </em> 
 json data format. <em class='code-description'>check the syntax of a JSON text data file or convert to another format.</em> <em class='code-description'>convert markdown text into html or LaTeX</em> <em class='code-description'>convert from "infix" arithmetic notation to "postfix" notation.</em> <em class='code-description'>compile a simple computer language into an assembly language.</em> <em class='code-description'>properly indent a computer language source code file.</em> 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DEBUGGING'></a>
<h3 class="section-heading">DEBUGGING <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The pep virtual machine is more complicated than the "sed" (the unix stream 
 editor) virtual machine (sed only has 2 string registers, the 
 "work-space" and the "hold-space" ). So you may find yourself needing to 
 debug a script. There are a number of ways to do this. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>see how a particular script is compiled to "assembler" format</em></td></tr>
<tr><td><pre class="code-line">pep -f compile.pss script</pre></td></tr>
</table>
 

<p>
 The compiled script will be printed to stdout and saved in sav.pp 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>load a script and view/execute/step through it interactively </em></td></tr>
<tr><td><pre class="code-line">pep -If someScript input.txt</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>interactively view how some script is being compiled by "asm.pp" </em></td></tr>
<tr><td><pre class="code-line">pep -Ia asm.pp someScript </pre></td></tr>
</table>
 
<table><td><pre class="code-line">pep -a asm.pp someScript </pre></td></table>
 

<p>
 (Now you can step through the compiled program "asm.pp" and watch as 
 it parses and compiles "someScript" . Generally, use "rr" to run the 
 whole script, and "rrw text" to run the script until the workspace 
 is some particular text. This helps to narrow down where the asm.pp 
 compiler is not parsing the input script correctly. 

<p>
 Once in an interactive "pep" session, there are many commands to 
 run and debug a script. For example: 

<p>
 -- 
 n - execute the next instruction in the program 
 m - view the state of the machine (stack/workspace/registers/tape/program) 
 rrw - run the script until the workspace is exactly some text. 
 rre - run script until the workspace ends with something 
 rr - run the whole script from the current instruction 
 M.r - reset the virtual machine and input stream 
 (but not the compiled program) 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TECHNIQUES FOR DEBUGGING'></a>
<h4 class="sub-section-heading">TECHNIQUES FOR DEBUGGING <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The technique used in eg/mark.latex.pss is a very powerful method 
 to see how rules are being resolved. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>see the stack when a reduction occurs</em></td></tr>
<tr><td><pre class="code-line">
    parse&gt;
      unstack; add "\n"; print; clip; stack; 
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMMON BUGS'></a>
<h4 class="sub-section-heading">COMMON BUGS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>make sure that you are pushing as many times as there are tokens.</em></td></tr>
<tr><td><pre class="code-line">add "noun*verb*noun*"; push; push; # &lt;&lt; error, 3 tokens, 2 pushes</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>make sure there is at least one read command in the script </em></td></tr>
<tr><td><pre class="code-line">"."{ clear; } print; clear; # &lt;&lt; error: no read in script</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SCRIPT EXAMPLES'></a>
<h3 class="section-heading">SCRIPT EXAMPLES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>remove whitespace only at the beginning of the input stream</em></td></tr>
<tr><td><pre class="code-line">begin { while [:space:]; clear; } read; print; clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print alphanumeric words in input stream one per line</em></td></tr>
<tr><td><pre class="code-line">
   read; [:alpha:] { while [:alpha:]; add "\n"; print; clear; }
   clear;
 </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print assignments in the form abc:333 or val = 66</em></td></tr>
<tr><td><pre class="code-line">
   r; 
   ":","=" { add "*"; push; }
   [:alpha:] { 
     while [:alpha:]; put; clear; add "id*"; push; .reparse 
   }
   [0-9] {
     while [0-9]; put; clear; add "num*"; push; .reparse
   }
   !"" {d;}
 parse&gt;
   pop; pop; pop;
   "id*:*num*", "id*=*num*" {
     clear;
     ++; ++; get; add " assigned to '"; --; --; get;
     add "'\n"; print; clear;
   }
   push; push; push;
 </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print the number of alphabetical words in the input stream</em></td></tr>
<tr><td><pre class="code-line">
   read; [:alpha:] { while [:alpha:]; a+; } clear;
   (eof) { add "Words in file: "; count; add "\n"; print; clear; }
 </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print words beginning with "www." as html links </em></td></tr>
<tr><td><pre class="code-line">
   read; 
   ![:space:] { 
     whilenot [:space:]; 
     B"www." { 
       put; clear; add "&lt;a href='"; get; add "'&gt;"; get; add "&lt;/a&gt;";
       add "\n"; print; a+; 
     }
   } clear;
   (eof) { add "Http urls in file: "; count; add "\n"; print; clear; }
 </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='MACHINE DESCRIPTION'></a>
<h3 class="section-heading">MACHINE DESCRIPTION <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The parsing virtual machine consists of a number of parts or registers 
 which I will describe in the following subsections. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='MACHINE ELEMENTS'></a>
<h3 class="section-heading">MACHINE ELEMENTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 D- a stack: 
 which can contain "parse tokens" if the language 
 is used for parsing or any other text data. 
 - a workspace buffer: 
 This is where all "text change" operations within the machine are 
 carried out. It is similar in concept to a register within 
 a "cpu" or to the "Sed" stream editor 
 pattern space. The workspace is affected by various commands, 
 such as @clear, @add, @indent, @get, @push, @pop etc 
 - a tape: 
 which is an array of text data which is synchronized with the 
 machine stack using a tape pointer. The tape is manipulated 
 with the @get and @put commands 
 - a tape-pointer or the current tape cell: 
 This variable determines the current tape element which will 
 be used by @get and @put commands. The tape pointer is incremented 
 with the ++ command and decremented with the -- command. 
 - a peep character: 
 this character is not directly manipulable, but it constitutes 
 a very simple "look ahead" mechanism and is used by the 
 "while" and "whilenot" commands 
 - a counter : 
 This counter or "accumulator" is an integer variable which can 
 be incremented with the command @plus ,decremented with the 
 command @minus ,and set to zero with the command @zero . 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='WORKSPACE BUFFER'></a>
<h4 class="sub-section-heading">WORKSPACE BUFFER <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The workspace buffer is the heart of the virtual machine and is 
 analogous to an "accumulator" register in a cpu chip. All incoming 
 and outgoing text data is processed through the workspace. All machine 
 instructions either affect or are affected by the state of the 
 workspace. 

<p>
 The workspace buffer is a buffer within the virtual machine of 
 the stream parsing language. In this buffer all of the text 
 transformation processed take place. For example, the commands 
 clear, add, indent, newline all affect the text in the 
 workspace buffer. 

<p>
 The workspace buffer is analogeous to a processor register 
 in a non-virtual cpu. In order to manipulate a value, it is 
 generally necessary to first load that value into a 
 cpu register. In the same way, in order to manipulate some 
 text in the pep machine, it is necessary to first 
 load that text into the workspace buffer. This can be 
 achieve with the @get, @pop, @read commands. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='STACK'></a>
<h4 class="sub-section-heading">STACK <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>machine instructions relating to the stack</em></td></tr>
<tr><td><pre class="code-line">push, pop</pre></td></tr>
</table>
 

<p>
 The stack is used to store and access the parse tokens that are constructed 
 by the virtual machine while parsing input. 

<p>
 ** parse tokens 

<p>
 Within the virtual machine of the parse script language the "stack" 
 structure is designed to hold and contain the "parse tokens" 

<p>
 parse tokens can be any string ended by the delimiter eg: 
<table><td><pre class="code-line">add "set*";</pre></td></table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DELIMITER REGISTER'></a>
<h4 class="sub-section-heading">DELIMITER REGISTER <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The delimiter register determines what character will be used for 
 delimiting parse tokens on the stack when using the "push" and "pop" 
 commands. This can be set with the "delim" command. The default 
 parse-token delimiter is the '*' asterix character. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>set the parse token delimiter to '/'</em></td></tr>
<tr><td><pre class="code-line">
      begin { delim '/'; }
      read; "(",")" { put; d; add "bracket/"; push; }  
    </pre></td></tr>
</table>
 

<p>
 The delimiter should be set in a 'begin' block. I normally use the "*" 
 character, but "/" or ";" might be good options. Apart from the parse-token 
 delimiter character, any character (including spaces) may be used in parse 
 tokens 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>parse tokens with spaces </em></td></tr>
<tr><td><pre class="code-line">r; [A-Z] { while [A-Z]; put; add "\n"; print; d; add "cap word*"; push; }</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='FLAG REGISTER'></a>
<h4 class="sub-section-heading">FLAG REGISTER <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The flag register affects the operation of the conditional jump instructions 
 "jumpfalse" and "jumptrue" and it is affected by the test instructions such 
 as "testis" , "testtape" , "testeof" etc. It is analogous to a "flags" 
 register in a cpu, but (currently) it only contains one boolean (true/false) 
 value. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>machine assembler instructions relating to the flag register</em></td></tr>
<tr><td><pre class="code-line">testis, testbegins, testends, testtape, testeof </pre></td></tr>
</table>
 
<table><td><pre class="code-line">jumptrue, jumpfalse</pre></td></table>
 

<p>
 The script writer does not read or write the machine flag register 
 directly. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ACCUMULATOR REGISTER'></a>
<h4 class="sub-section-heading">ACCUMULATOR REGISTER <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The machine contains 1 integer accumulator register that can 
 be incremented (with "a+" ), decremented (with "a-" ) and set to 
 zero (with "zero" ). This register is useful for counting occurances 
 of miscelaneous elements that occur during parsing and translating. 

<p>
 An example of the use of the accumulator register is given during the 
 parsing of "quotesets" in old versions of the "compile.pss" script. The 
 accumulator in this case, keeps track of the target for true-jumps. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>count how many "x" characters occur in the input stream</em></td></tr>
<tr><td><pre class="code-line">r; 'x' {a+;} d; &lt;eof&gt; { add ' # of Xs == '; count; print; }</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PEEP REGISTER'></a>
<h4 class="sub-section-heading">PEEP REGISTER <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The peep buffer is a single character buffer which stores 
 the next character in the input stream. When a 'read' command 
 is performed the current value of the peep buffer is appended to 
 the 'workspace' buffer and the next character from the input 
 stream is placed into the peep buffer. 

<p>
 The "end-of-stream" tests <eof> <EOF> (eof) (EOF) check to see if the peep 
 buffer contains the end of input stream marker. 

<p>
 The 'while' command reads from the input stream while the 
 peep buffer is, or is not, some set of characters 
 For example 
<table><td><pre class="code-line">while [abc];</pre></td></table>
 
 reads the input stream while the peep buffer is any one of the 
 characters 'abc'. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TAPE'></a>
<h4 class="sub-section-heading">TAPE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>machine instructions with an effect on the tape</em></td></tr>
<tr><td><pre class="code-line">get, put, ++, --, pop, push, mark, go</pre></td></tr>
</table>
 

<p>
 The tape is an array of string cells (with memory allocated dynamically), 
 each of which can be read or written, using the workspace buffer. 
 The tape cell array also includes a tape cell pointer, which is usually 
 called the "current cell" . 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CURRENT CELL OF TAPE ARRAY'></a>
<h4 class="sub-section-heading">CURRENT CELL OF TAPE ARRAY <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>instructions affecting the current cell of the tape</em></td></tr>
<tr><td><pre class="code-line">++, --, push, pop, mark, go</pre></td></tr>
</table>
 

<p>
 The current cell of the tape is a very important mechanism for storing 
 attributes of parse tokens, and then manipulating those attributes. The 
 pep virtual machine has the ability to "compile" or translate one text 
 format into another. (I call this compilation because because the target 
 text format may be an assembly language - for either a real or virtual 
 machine) 

<p>
 In the parsing phase of a script, the attributes of different parse tokens 
 are accessed from the tape and combined and manipulated in the workspace 
 buffer, and then stored again in the current cell of the tape. This means 
 that a script which is transforming some input stream may finish with the 
 entire transformed input in the 1st cell of the tape structure. The script 
 can then print out the cell to stdout (with "get; print;" , which allows 
 further processing by other tools in the pipe chain) or else write the 
 contents of the cell to the file <a href='sav.pp'><em><tt>sav.pp</tt></em></a> (with "get; write;" ). 

<p>
 The current cell is also affected by the stack machine commands 
 "pop" and "push" . The push command increments the tape pointer 
 (current cell) by 1 and the pop command decrements the tape pointer 
 by one. 

<p>
 This is a simple but powerful mechanism that allows the tape pointer 
 to stay in sync with the stack. After a "push" or "pop" command 
 the tape pointer will be pointing at the correct tape cell for 
 that item on the stack. In some cases, it may be easiest to see how 
 these mechanisms work by running the machine engine in interactive mode 
 (pep -If script input) and stepping through a script or executing 
 commands at the prompt. 

<p>
 The tape pointer is also incremented and decremented by the 
 ++ and -- commands, and these commands are mainly used during the 
 compilation phase to access and combine attributes to transform 
 the input into the desired output. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SYNTAX OF THE SCRIPT LANGUAGE'></a>
<h3 class="section-heading">SYNTAX OF THE SCRIPT LANGUAGE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The script language, which is implemented in the file 
 books/pars/compile.pss, has a syntax very similar to the "sed" stream 
 editor. Unlike sed, it also allows long names for commands (eg "clear" 
 instead of "d" , "add" instead of "a" ). Each command has a long and a short 
 form. 

<p>
 All commands must be terminated with a semicolon except for the following: 
<table><td><pre class="code-line">.reparse .restart parse&gt;</pre></td></table>
 

<p>
 White-space is not significant in the syntax of the parse-script 
 language, except within ' and " quote characters and square brackets []
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>random whitespace</em></td></tr>
<tr><td><pre class="code-line">
    read; !
    [a-e]{t;}

    d;
  </pre></td></tr>
</table>
 

<p>
 Braces "{" and "}" are used to define blocks of commands (as in 
 sed, awk and c). 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LANGUAGE FEATURES'></a>
<h4 class="sub-section-heading">LANGUAGE FEATURES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The script language (and its syntax) is implemented in the file 
 compile.pss . Some commands, such as ".reparse" and ".restart" 
 affect the flow of the program, but not the virtual machine. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>tests on the workspace buffer, followed by a block of commands</em></td></tr>
<tr><td><pre class="code-line">[a-z] { print; clear; }</pre></td></tr>
</table>
 

<p>
 Most scripts start with "read;" or "r;" (which is the abbreviated 
 equivalent). This reads one character from the input stream. Whereas sed 
 and awk are line oriented (they process the input stream one line at a 
 time), pep is character orientated (the input stream is processed one 
 character at a time). 

<p>
 As with sed and awk, pep scripts have an implicit loop. When the interpreter 
 reaches the end of the script, it jumps back to the first command (usually 
 "read" ) and continues looping until the input stream is finished. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CHARACTER CLASSES'></a>
<h4 class="sub-section-heading">CHARACTER CLASSES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Character classes are written [:space:] [:alnum:] etc Currently (November 
 2019), the c language implementation of the parse machine and language uses 
 plain ctype.h character classes as a way of grouping characters. 

<p>
 These classes are important in a unicode setting because they allow 
 specifying types of characters in a locale-neutral way. The "while" and 
 "whilenot" commands can use character classes as their argument. 

<p>
 In the future, scripts may be able to define new character classes 
 in the following way. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>define new named character classes</em></td></tr>
<tr><td><pre class="code-line">
    begin { 
      class "brackets" [{}()]; 
      class "idchar" [a-z],[.$]; 
    } 
    # now use the new character class
    [:brackets:] {
      while [:brackets:]; clear;
    } print;
  </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>check if the workspace is only alphanumeric characters </em></td></tr>
<tr><td><pre class="code-line">r; ![:alnum:] { add " not alpha-numeric! \n"; print; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>read the input stream while the peep register is whitespace</em></td></tr>
<tr><td><pre class="code-line">while [:space:];</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='QUOTES'></a>
<h4 class="sub-section-heading">QUOTES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Both single and double quotes may be used in scripts. 
<table><td><pre class="code-line">r; '"' { add "&lt;&lt; single quote!\n"; print; } d;</pre></td></table>
 

<p>
 If using the negation operator ! in an "in-line" script, then 
 enclose the whole thing in single quotes. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>use single quotes in one-liners to avoid special char problems</em></td></tr>
<tr><td><pre class="code-line">pep -f compile.pss -i '![a-z],"a","b"{nop;}'</pre></td></tr>
</table>
 

<p>
 The until command already understands escaped characters, so it 
 will read past an escaped delimiter (eg \"). 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>single quotes</em></td></tr>
<tr><td><pre class="code-line">r; 'a' { add 'A'; print; } d;</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMMENTS'></a>
<h4 class="sub-section-heading">COMMENTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Both single line comments (line starting with "#" ), or multiline 
 comments (hash+asterix .... asterix+hash) are available. 

<p>
 Multiline comments are useful for disabling blocks of code 
 during script development, as well as for long comments at the 
 beginning of a script. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='BEGIN BLOCKS'></a>
<h4 class="sub-section-heading">BEGIN BLOCKS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Like awk, the parse script language allows 'begin' blocks. These 
 blocks are only executed once, whereas the rest of the script 
 is executed in a loop for every character in the input stream. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>an example begin block and script</em></td></tr>
<tr><td><pre class="code-line">
    begin {
      add "Starting script ...\n"; print; clear;
      # set the token delimiter to / 
      delim "/";  
    }
    read; print; clear;
  </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create a basic html document </em></td></tr>
<tr><td><pre class="code-line">
    begin { add "&lt;html&gt;&lt;body&gt;&lt;pre&gt;\n"; print; clear; } 
    read; replace "&gt;" "&gt;"; replace "&lt;" "&lt;"; 
    print; clear;
    (eof) { add "\n&lt;/pre&gt;&lt;/body&gt;&lt;/pre&gt;\n"; print; clear;}
  </pre></td></tr>
</table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CONDITIONS AND TESTS'></a>
<h4 class="sub-section-heading">CONDITIONS AND TESTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CLASS TESTS'></a>
<h4 class="sub-section-heading">CLASS TESTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The class test checks whether the workspace buffer matches any one of the 
 characters or character classes listing between the square braces. A class 
 test is written. 
<table><td><pre class="code-line">[character-class] { &lt;commands&gt;  }</pre></td></table>
 

<p>
 There are 3 forms of the character class test: 
 o- a list of characters eg: [abcxyz.,;] 
 - a range of characters eg: [A-M] 
 - a named character class eg: [:space:] 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>delete all vowels from the input stream using a list class test</em></td></tr>
<tr><td><pre class="code-line">read; ![aeiou] { print; } clear;</pre></td></tr>
</table>
 

<p>
 All characters in the workspace must match given class, so 
 that a class test is equivalent to the regular expression "^[abcd]+$" 

<p>
 As in the previous example, class tests, like all other type of tests, can 
 be negated with a prefixed "!" character. Double and multiple negation, 
 such as "!!" or "!!!" is a syntax error (since it doesn't have 
 any purpose). 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>only print certain sequences </em></td></tr>
<tr><td><pre class="code-line">r; [abc-,] { while [abc-,]; print; } clear;</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='EOF END OF STREAM TEST'></a>
<h4 class="sub-section-heading">EOF END OF STREAM TEST <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This test returns true if the 'peep' look-ahead register currently contains 
 the <EOF> end of stream marker for the input stream. This test is equivalent 
 to the "END { ... }" block syntax in the AWK script language. The eof test is 
 written as follows 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>possible formats for the "end-of-stream" test</em></td></tr>
<tr><td><pre class="code-line">&lt;eof&gt; &lt;EOF&gt; (eof) (EOF)</pre></td></tr>
</table>
 
<table><td><pre class="code-line">r; print; (eof) { add " &lt;&lt; end of stream!"; } clear;</pre></td></table>
 

<p>
 This test can be combined with other tests either with AND 
 logic or with OR logic 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>test if the input ends with "horse" when the end-of-stream is reached</em></td></tr>
<tr><td><pre class="code-line">r; (eof).E"horse" { add ' and cart'; print; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>test if workspace ends with "horse" OR end-of-file has been reached </em></td></tr>
<tr><td><pre class="code-line">r; (eof),E"horse" { add " &lt;horse OR end-of-file&gt; "; print; } </pre></td></tr>
</table>
 

<p>
 The <eof> test is important for checking if the script has 
 successfully parsed the input stream when the end of stream is 
 reached. Usually this means checking for the "start token" or tokens of the 
 given grammar. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>check for a start token</em></td></tr>
<tr><td><pre class="code-line">
    read;
    # ... more code
    (eof) {
      pop; 
      "statement*" {
         # successful parse
         quit;
      }
      # unsuccessful pase
    }
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TAPE TEST'></a>
<h4 class="sub-section-heading">TAPE TEST <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
<table><td><pre class="code-line">(==) { ...}</pre></td></table>
 

<p>
 This test determines if the current tape cell is equal to the 
 contents of the workspace buffer. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>check if previous char the same as current</em></td></tr>
<tr><td><pre class="code-line">
    read;  
    (==) {
      put; add ".same."; 
    }
    print; clear;
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='BEGINS WITH TEST'></a>
<h4 class="sub-section-heading">BEGINS WITH TEST <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Determines if the workspace buffer begins with the given 
 text. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>only print words beginning with "wh"</em></td></tr>
<tr><td><pre class="code-line">read; E" ",E"\n",(eof) { B"wh" { print; } clear; } </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ENDS WITH TEST'></a>
<h3 class="section-heading">ENDS WITH TEST <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 Tests if the workspace ends with the given text. The 'E' 
 (ends-with modifier) can only be used with quoted text but 
 not with class tests 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a syntax error, using E with a class</em></td></tr>
<tr><td><pre class="code-line">r; E[abcd] { print; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>correct using the E modifier with quoted text</em></td></tr>
<tr><td><pre class="code-line">r; E"less" { print; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>only print words ending with "ess"</em></td></tr>
<tr><td><pre class="code-line">read; E" ",E"\n" { clip; E"ess" { add " "; print; } clear; } </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CONCATENATING TESTS'></a>
<h3 class="section-heading">CONCATENATING TESTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 Conditional tests can be chained together with OR (,) or AND (.) 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>test if workspace starts with "http:" OR "ftp:"</em></td></tr>
<tr><td><pre class="code-line">B"http:" , B"ftp:" { print; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print names of animals using OR logic concatenation</em></td></tr>
<tr><td><pre class="code-line">
   read; [:space:] {d;} whilenot [:space:];
   "lion","puma","bear","emu" { add "\n"; print; }
   clear;
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='AND LOGIC CONCATENATION'></a>
<h4 class="sub-section-heading">AND LOGIC CONCATENATION <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 It is also possible to do AND logic concatenation with the "." operator 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>test if the workspace starts with 'a' AND ends with 'z'</em></td></tr>
<tr><td><pre class="code-line">r; B"a".E"z" { print; clear; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>check if workspace is a url but not a ".txt" text file </em></td></tr>
<tr><td><pre class="code-line">B"http://" . !E".txt" { add "&lt;&lt; non-text url"; print; clear; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>workspace begins with # and only contains digits and # </em></td></tr>
<tr><td><pre class="code-line">B"#".[#0123456789] { }</pre></td></tr>
</table>
 

<p>
 "AND" logic can also be achieved by nesting brace blocks. This 
 may have advantages. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>and logic with nested braces</em></td></tr>
<tr><td><pre class="code-line">
    B"/" { E".txt" { ... } }
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='NEGATED TESTS'></a>
<h4 class="sub-section-heading">NEGATED TESTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "!" not operator is used for negating tests. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>examples of negated tests</em></td></tr>
<tr><td><pre class="code-line">!B"abc", !E"xyz", ![a-z], !"abc" ...</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='STRUCTURE OF A SCRIPT'></a>
<h3 class="section-heading">STRUCTURE OF A SCRIPT <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LEXICAL PHASE'></a>
<h4 class="sub-section-heading">LEXICAL PHASE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Like most systems which are designed to parse and compile context-free 
 languages, parse scripts normally have 2 distinct phases: A "lexing" phase 
 and a parse/compile/translate phase. This is shown by the separation of the 
 unix tools "lex" and "yacc" where lex performs the lexical analysis (which 
 consists of the recognition and creation of lexical tokens), and yacc 
 performs parsing and compilation of tokens. 

<p>
 In the compile.pss program, as with many scripts that can be written 
 in the parse language, the lexical and compilation phases are 
 combined into the same script. 

<p>
 In the first phase, the program performs lexical analysis of the input 
 (which is an uncompiled script in the parse script language), and converts 
 certain patterns into "tokens" . In this system, a "token" is just a string 
 (text) terminated in an asterix (*) character. Asm.pp constructs these 
 tokens by using the "add" machine instruction, which appends text to the 
 workspace buffer. 

<p>
 Next the parse token is "pushed" onto the "stack" . I have quoted these 
 words because the stack buffer is implemented as a string (char *) 
 buffer and "pushing" and "popping" the stack really just involves 
 moving the workspace pointer back and forth between asterix characters. 

<p>
 I used this implementation because I thought that it would be 
 fast and simple to implement in c. It also means that we dont have to 
 worry about how much memory is allocated for the stack buffer or 
 each of its items. As long as there is enough memory allocated for 
 the workspace buffer (which is actually just the end of the stack buffer) 
 there will be enough room for the stack. 

<p>
 The lexical phase of asm.pp also involves preserving the "attribute" 
 of the parse token. For example if we have some text such as 
 "hannah" then our parse token may be "quoted.text*" 
 and the attribute is the actual text between the quotes 'hannah'. 
 The attribute is preserved on the machine tape data structure, which 
 is array of string cells (with no fixed size), in which data can 
 be inserted at any point by using the tape pointer. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PARSING PHASE'></a>
<h4 class="sub-section-heading">PARSING PHASE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The parsing phase of the asm.pp compiler involves recognising and 
 shift-reducing the token sequences that are on the machine "stack" . 
 These tokens are just strings post-delimited with the '*' character. 
 Because the tokens are text, they popped onto the workspace buffer 
 and then manipulated using the workspace text commands. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMMANDS'></a>
<h3 class="section-heading">COMMANDS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 <em class='code-description'>all commands have a single letter variants for the commands. </em> 
 eg: p, pop, P, push, etc 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMMAND SUMMARY'></a>
<h4 class="sub-section-heading">COMMAND SUMMARY <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 All commands have an abbreviated (one letter) form as well. <em class='code-description'>++ </em> 
 increments the tape pointer by one (see 'increment' ) <em class='code-description'>--:</em> 
 decrements the tape pointer by one. (see "decrement;" ) <em class='code-description'>mark "text"</em> 
 adds a marker to the current tape cell (used with 'go') <em class='code-description'>go "text"</em> 
 sets the current tape cell to the marked cell <em class='code-description'>add "text" (or add 'text')</em> 
 adds text to the end of the workspace <em class='code-description'>.reparse </em> 
 jumps back or forward to the parse> label. This is used to ensure that 
 all shift reductions take place. <em class='code-description'>clip</em> 
 removes the last character from the workspace <em class='code-description'>clop</em> 
 removes the first character from the workspace <em class='code-description'>quit </em> 
 exits the script without reading anything more from 
 standard input. (like the sed command 'q') <em class='code-description'>clear</em> 
 sets the workspace to a zero length string. Equivalent 
 to the sed command 
<table><td><pre class="code-line">s/^.*$//;</pre></td></table>
 <em class='code-description'>put</em> 
 puts the contents of the workspace into the current 
 item of the tape (as indicated by the tape-pointer ) <em class='code-description'>get</em> 
 gets the current item of the tape and adds it to 
 the *end* of the workspace with *no* separator character <em class='code-description'>swap</em> 
 swaps the contents of the current tape cell and the 
 workspace buffer. <em class='code-description'>count </em> 
 appends the integer counter to the *end* of the workspace <em class='code-description'>a+ </em> 
 increments the accumulatorr variable/register in the virtual 
 machine by 1. <em class='code-description'>a- </em> 
 this command decrements a counter variable by one <em class='code-description'>zero;</em> 
 sets the counter to zero <em class='code-description'>lines (or 'll')</em> 
 appends the line number register to the workspace buffer. <em class='code-description'>nolines </em> 
 sets the automatic line counter to zero. <em class='code-description'>chars (or 'cc')</em> 
 appends the character number register to the workspace buffer <em class='code-description'>nochars</em> 
 sets the automatic character counter to zero. <em class='code-description'>print</em> 
 prints the contents of the workspace buffer to the standard 
 output stream (stdout). Equivalent to the sed command 'p' <em class='code-description'>pop</em> 
 pops one token from the stack and adds it to the 
 -beginning- of the stack <em class='code-description'>push :</em> 
 pushes one token from the workspace onto the stack, or 
 reads upto the first star "*" character in the @workspace buffer 
 and pushes that section of the buffer onto the stack. <em class='code-description'>unstack</em> 
 pops the entire stack as a prefix onto the workspace buffer <em class='code-description'>stack</em> 
 pushes the entire workspace (regardless of any token delimiters 
 in the workspace) onto the stack. <em class='code-description'>replace</em> 
 replaces a string in the workspace with another string. <em class='code-description'>read</em> 
 reads one more character from the stdin. <em class='code-description'>state</em> 
 prints the current state of the virtual machine 
 to the standard output stream. maybe useful for debugging 
 I may remove this command. <em class='code-description'>until 'text'</em> 
 reads characters from stdin until the workspace 
 ends in the given text and does not end in the 
 second given text. This maybe used for capturing 
 quoted strings etc. <em class='code-description'>cap</em> 
 converts the workspace to 'capital case' (first upper, then all lower) <em class='code-description'>lower</em> 
 converts all characters in the workspace to lowercase <em class='code-description'>upper</em> 
 converts all characters in the workspace to upper case. <em class='code-description'>while class/text;</em> 
 reads characters from the input stream while the 
 peep character is the given class <em class='code-description'>whilenot class/text;</em> 
 reads characters from the input stream while the 
 peep register is *not* the given character or class 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ADD'></a>
<h4 class="sub-section-heading">ADD <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "add" command appends some text to the end of the 'workspace' 
 buffer. No other register or buffer within the virtual machine is 
 affected. The command is written: 
<table><td><pre class="code-line">add 'text'; #* or *#</pre></td></table>
 
<table><td><pre class="code-line">add "text";</pre></td></table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>add a quote after the ':' character</em></td></tr>
<tr><td><pre class="code-line">r; [\:] { add "\""; } print; clear;  # non java fix!!</pre></td></tr>
</table>
 
<table><td><pre class="code-line">r; [:] { add "\""; } print; clear; # java version</pre></td></table>
 

<p>
 But it shouldn't be necessary to escape ':' 

<p>
 The quoted argument may span more than one line. For example 
<table><td><pre class="code-line">
  begin { add '
      A multiline 
      argument for "add".
    '; } read; print; clear;
  </pre></td></table>
 

<p>
 It is possible to use escaped characters such as \n \r \t \f or \" in 
 the quoted argument. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>add a newline to the workspace after a full stop</em></td></tr>
<tr><td><pre class="code-line">r; E"." { add "\n"; } print; clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Add a space after every character of the input </em></td></tr>
<tr><td><pre class="code-line">
    read; add ' '; print; clear;
    # or the same using abbreviated commands
    # r; a ' ';p;d;  
  </pre></td></tr>
</table>
 

<p>
 Add is used to create new tokens and to modify the token attributes. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create and push (shift) a token using the "add" command</em></td></tr>
<tr><td><pre class="code-line">
   "style*type*" {
     clear;
     add "command*";
     push;
   }
  </pre></td></tr>
</table>
 

<p>
 The script above does a shift-reduce operation while parsing some 
 hypothetical language. The "add" command is used to add a new token name to 
 the 'workspace' buffer which is then pushed onto the stack (using the 'push' 
 operation, naturally). In the above script the text added can be seen to be 
 a token name (as opposed to some other arbitrary piece of text) because it 
 ends in the "*" character. Actually any character could be used to delimit 
 the token names, put "*" is the default implementation. 

<p>
 The add command takes -one- and only one parameter, or argument. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='REPARSE COMMAND'></a>
<h4 class="sub-section-heading">REPARSE COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This command makes the interpreter jump to the parse> label. The .reparse 
 command takes no arguments, and is *not* terminated with a semi-colon. It 
 is written ".reparse" . The .reparse command is important for insuring that 
 all shift-reductions occur at a particular phase of a script. 

<p>
 If there is no 'parse>' label in the script, then it is an error to 
 use the ".reparse" command. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CLIP COMMAND'></a>
<h4 class="sub-section-heading">CLIP COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This command removes one character from the end of the 'workspace' buffer and 
 sends it into the void. It deletes it. The character is removed from the 
 -end- of the workspace, and so, it represents the last character which would 
 have been added to the workspace from a previous 'read' operation. 

<p>
 The command is useful for example, when parsing quoted text, used in 
 conjunction with the 'until' command. As in The following script only prints 
 text which is contained within double quote characters, from the input. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>parse and print quoted text</em></td></tr>
<tr><td><pre class="code-line">read; '"' { clear; until '"'; clip; print; }</pre></td></tr>
</table>
 
<table><td><pre class="code-line">"\"" { clear; until "\""; clip; print; }</pre></td></table>
 

<p>
 If the above script receives the text 'this "big" and "small" things' 
 as its input, then the output will be 'big small' .That is, only 
 that which is within double quotes will be printed. 

<p>
 The script above can be translated into plain english as follows 

<p>
 a- If the workspace is a " character then
 - clear the workspace 
 - read the input stream until the workspace -ends- in "
 - remove the last character from the workspace (the ")
 - print the workspace to the console 
 - end if 
 - 

<p>
 The script should print the contents of the quoted text 
 without the quote characters because the 'clear' and 
 the clip commands got rid of them. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CLOP COMMAND'></a>
<h4 class="sub-section-heading">CLOP COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "clop" command removes one character from the front 
 of the workspace buffer. The clop command is the counterpart of 
 the 'clip' command. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print only quoted words without the quotes</em></td></tr>
<tr><td><pre class="code-line">r; '"' { until '"'; clip; clop; print; } clear;</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COUNT COMMAND'></a>
<h4 class="sub-section-heading">COUNT COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The count command adds the value of the counter variable 
 to the end of the workspace buffer . For example, if the counter variable 
 is 12 and the workspace contains the text 'line:', then after the 
 count command the workspace will contain the text 
<table><td><pre class="code-line">line:12</pre></td></table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>count the number of dots in the input </em></td></tr>
<tr><td><pre class="code-line">read; "." { a+; } clear; &lt;eof&gt; { count; print; }</pre></td></tr>
</table>
 

<p>
 The count command only affects the 'workspace' buffer in the virtual 
 machine. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='QUIT COMMAND'></a>
<h4 class="sub-section-heading">QUIT COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This command immediately exits out of the script without 
 processing any more script commands or input stream characters. 

<p>
 This command is similar to the "sed" command 'q' 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DECREMENT COMMAND'></a>
<h4 class="sub-section-heading">DECREMENT COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The decrement command reduces the tape pointer by 
 one and thereby moves the current 'tape' element one 
 to the 'left' 

<p>
 The decrement command is written "--" or "<" 

<p>
 If the current tape element is the first element of 
 the tape then the tape pointer is not changed and the 
 command has no effect. 

<p>
 ** See also 

<p>
 'increment' , 'put' , 'get' 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='INCREMENT COMMAND'></a>
<h4 class="sub-section-heading">INCREMENT COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This command is simple but important. The command 
 adds -one- to the 'tape'-pointer. The command is written 
<table><td><pre class="code-line">++ or &gt;</pre></td></table>
 

<p>
 Notice that the only part of the machine state which has 
 changed is that the 'tape-pointer' (the arrow in the 'tape' 
 structure) has been incremented by one cell. 

<p>
 This command allows the tape to be accessed as a 'tape' . This is 
 tortological but true. Being able to increment and 'decrement' the tape 
 pointer allows the script writer and the virtual machine to access any value 
 on the tape using the 'get' and 'put' commands. 

<p>
 It should be remembered that the 'pop' command also automatically 
 increments the tape pointer, in order to keep the tape pointer 
 and the stack in synchronization. 

<p>
 Since the get command is the only way to retrieve values from 
 the tape the ++; and --; commands are necessary. the tape 
 cannot be accessed using some kind of array index because 
 the get and 'put' commands to not have any arguments. 

<p>
 An example, the following script will print the string associated 
 with the "value" token. 
<table><td><pre class="code-line">pop;pop; "field*value*" { ++; get; --; print; }</pre></td></table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='MARK COMMAND'></a>
<h4 class="sub-section-heading">MARK COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The mark command adds a text "tag" to the current tapecell. 
 This allows the tapecell to be accessed later in the script with 
 the "go" command. The mark and go commands should allow "offside" 
 or indent parsing (such as for the python language) 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>use mark and go to use the 1st tape cell as a buffer.</em></td></tr>
<tr><td><pre class="code-line">
   begin { mark "topcell"; ++; }
   read; [:space:] { d; }
   whilenot [:space:]; put; 
   # create a list of urls in the 1st tapecell
   B"http:" {
     mark "here"; go "topcell"; add " "; get; put; go "here";
   }
   clear; add "word*"; push; 
   &lt;eof&gt; { go "topcell"; get; print; quit; }
 </pre></td></tr>
</table>
 

<p>
 See the script pars/eg/markdown.toc.pss for an example of using 
 the "mark" and "go" commands to create a table of contents for 
 a document from markdown-style underline headings. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='GO COMMAND'></a>
<h4 class="sub-section-heading">GO COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "go" command set the current tape cell pointer to a cell 
 which has previously been marked with a "mark" command (using 
 a text tag. The go/mark commands may be useful for offside 
 parsing as well as for assembling, for example, a table of contents 
 for a document, while parsing the document structure. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>basic usage</em></td></tr>
<tr><td><pre class="code-line">read; mark "a"; ++; go "a"; put; clear;</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='MINUS COUNTER COMMAND'></a>
<h4 class="sub-section-heading">MINUS COUNTER COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The minus command decreases the counter variable by one. 
 This command takes no arguments and is written 
<table><td><pre class="code-line">a-;</pre></td></table>
 

<p>
 The 'testeof' (eof) checks to see if the peep buffer contains the 
 end of input stream marker. 

<p>
 The 'while' command reads from the input stream while the 
 peep buffer is or is not some set of characters 
 For example 
<table><td><pre class="code-line">while 'abc';</pre></td></table>
 
 reads the input stream while the peep buffer is any one of the 
 characters 'abc'. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PLUS COUNTER COMMAND'></a>
<h4 class="sub-section-heading">PLUS COUNTER COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This command increments the machine counter variable by 
 one. It is written 
<table><td><pre class="code-line">a+ </pre></td></table>
 

<p>
 The plus command takes no arguments. Its counter part is the 
 'minus' command. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ZERO COMMAND'></a>
<h4 class="sub-section-heading">ZERO COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "zero" command sets the internal counter to zero. This counter may be 
 used to keep track of nesting during parsing processes, or used by other 
 mundane purposes such as numbering lines or instances of a particular string 
 or pattern. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'></em></td></tr>
<tr><td><pre class="code-line">read; "x" { zero; } </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CHARS OR CC COMMAND'></a>
<h4 class="sub-section-heading">CHARS OR CC COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "chars" or "cc" command appends the value of the current 
 character counter to the workspace register 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>show an error message with a character number</em></td></tr>
<tr><td><pre class="code-line">
    read; 
    [@#$%^&] {
      put; clear; 
      add "illegal character ("; get; ") ";
      add "at character number "; chars; add ".\n";
      print; clear;
    }
  </pre></td></tr>
</table>
 

<p>
 I originally named this command "cc" but prefer the longer 
 form "chars" (which is currently implemented as an alias in 
 the script compiler pars/compile.pss) 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LINES OR LL COMMAND'></a>
<h4 class="sub-section-heading">LINES OR LL COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "lines" or "ll" command appends to the workspace the 
 current value of the line counter register. This is very useful 
 when writing compilers in order to produce an error message 
 with a line number when there is a syntax error in the input stream. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='UNSTACK COMMAND'></a>
<h4 class="sub-section-heading">UNSTACK COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Pop the entire stack as a prefix onto the workspace. This may be 
 useful for displaying the state of the stack at the end of 
 parsing or when an error has occurred. Currently (Aug 2019) the 
 tape pointer is not affected by this command. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='STACK COMMAND'></a>
<h4 class="sub-section-heading">STACK COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Push the entire workspace onto the stack regardless of token 
 delimiters. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PUSH COMMAND'></a>
<h4 class="sub-section-heading">PUSH COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "push" command pushes one token from (the beginning of) the 
 workspace onto the stack. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='POP COMMAND'></a>
<h4 class="sub-section-heading">POP COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The pop command pops the last item from the virtual machine stack 
 and places its contents, without modification, at the -beginning- 
 of the workspace buffer, and decrements the tape pointer. If the 
 stack is empty, then the pop; command does nothing (and the tape 
 pointer is unchanged). 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>pop the stack into the workspace.</em></td></tr>
<tr><td><pre class="code-line">pop;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>apply a 2 token grammar rule (a shift-reduction).</em></td></tr>
<tr><td><pre class="code-line">pop;pop; "word*colon*" { clear; add 'command*'; push; }</pre></td></tr>
</table>
 

<p>
 The pop command is usually employed in the parsing phase 
 of the script (not the lexing phase); that is, after the "parse>" 
 label. The "pop;" command is almost the inverse machine operation 
 of the "push;" command, but it is important to realise that 
 a command sequence of "pop;push;" does not always equivalent to 
 "nop;" (no-operation). 

<p>
 If the stream parser language is being used to parse and translate a 
 language then the script writer needs to ensure that each token ends with a 
 delimiter character (by default "*" ) in order for the push and pop commands 
 to work correctly. 

<p>
 The pop command also affects the "tape" of the virtual machine in 
 that the tape-pointer is automatically decremented by one once for 
 each pop command. This is convenient because it means that the 
 tape pointer will be pointing to the corresponding element for the 
 token. In other words in the context of parsing and compiling a 
 "formal language" the tape will be pointing to the 
 "value" or "attribute" for the the token which is currently in the 
 workspace. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PRINT COMMAND'></a>
<h4 class="sub-section-heading">PRINT COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The print command prints the contents of the workspace to 
 the standard output stream (the console, normally). This is 
 analogous to the the sed 'p' command (but its abbreviated form 
 is 't' not 'p' because 'p' means "pop" . 

<p>
 ** Examples 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Print each character in the input stream twice:</em></td></tr>
<tr><td><pre class="code-line">print; print; clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Replace all 'a' chars with 'A's;</em></td></tr>
<tr><td><pre class="code-line">"a" { clear; add "A"; } print; clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>Only print text within double quotes:</em></td></tr>
<tr><td><pre class="code-line">'"' { until '"'; print; } clear;</pre></td></tr>
</table>
 

<p>
 ** Details 

<p>
 The print command does not take any arguments or parameters. 
 The print command is basically the way in which the parse-language 
 communicates with the outside world and the way in which it 
 generates an output stream. The print command does not change 
 the state of the pep virtual machine in any way. 

<p>
 Unlike sed, the parse-language does not do any "default" printing. 
 That is, if the print command is not explicitly specified the 
 script will not print anything and will silently exit as if it 
 had no purpose. This should be compared with the default 
 behavior of sed which will print each line of the input stream if 
 the script writer does not specify otherwise (using the -n switch). 

<p>
 Actually the print command is not to be so extensively used as 
 in sed. This is because if an input stream is successfully parsed 
 by a given script then only -one- print statement will be necessary, 
 at the end of the input stream. However the print command could be 
 used to output progress or error messages or other things. 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='GET COMMAND'></a>
<h4 class="sub-section-heading">GET COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This command obtains the value in the current 'tape' cell 
 and adds it (appends it) to the end of the 'workspace' buffer. 
 The "get" command only affects the 'workspace' buffer of the virtual 
 machine. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>if the workspace has the "noun" token, get its value and print it.</em></td></tr>
<tr><td><pre class="code-line">"noun*" { clear; get; print; clear; }</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PUT COMMAND'></a>
<h4 class="sub-section-heading">PUT COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The put command places the entire contents of the workspace 
 into the current tape cell, overwriting any previous value 
 which that cell might have had. The command is written 
<table><td><pre class="code-line">put;</pre></td></table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>put the text "one" into the current tape cell and the next one.</em></td></tr>
<tr><td><pre class="code-line">clear; add "one"; put; ++; put;</pre></td></tr>
</table>
 

<p>
 The put command only affects the current tape cell of the virtual 
 machine. 

<p>
 After a put command the workspace buffer is -unchanged- . This contrasts 
 with the machine stack 'push' command which pushes a certain amount of text 
 (one token) from the workspace onto the stack and deletes the same amount of 
 text from the workspace buffer. 

<p>
 The put command is the counterpart of the 'get' command which retrieves or 
 gets the contents of the current item of the tape data structure. Since the 
 tape is generally designed for storing the values or the attributes of parse 
 tokens, the put command is essentiallly designed to store values of 
 attributes. However, the put command overwrites the contents of the 
 current tape cell, whereas the "get" command appends the contents of 
 the current tape cell to the work space. 

<p>
 The put command can be used in conjunction with the 'increment' ++ and 
 'decrement' -- commands to store values in the tape which are not the current 
 tape item. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SWAP COMMAND'></a>
<h4 class="sub-section-heading">SWAP COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Syntax: swap; 
 Abbreviation: 'x' 

<p>
 Swaps the contents of the current tape cell with the workspace buffer. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>prepend the current tape cell to the workspace buffer</em></td></tr>
<tr><td><pre class="code-line">swap; get;</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='READ COMMAND'></a>
<h4 class="sub-section-heading">READ COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The read command reads one character from the input stream and places that 
 character in the 'peep' buffer. The character which -was- in the peep 
 buffer is added to the -end- of the 'workspace' buffer. 

<p>
 The read command is the fundamental mechanism by which the input stream is 
 "tokenized" also known as "lexical analysis" . The commands which also 
 perform tokenization are "until" , "while" and "whilenot" . These commands 
 perform implicit read operations. 

<p>
 There is no implicit read command at the beginning of a script 
 (unlike "sed" ), so all scripts will probably need at least one 
 read command. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='REPLACE COMMAND'></a>
<h4 class="sub-section-heading">REPLACE COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This command replaces one piece of text with another in the workspace 
 The replace command is useful indenting blocks of text during formatting 
 operations. The replace command only replaces plain text, not 
 regular expressions 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>replace the letter 'a' with 'A' in the workspace buffer</em></td></tr>
<tr><td><pre class="code-line">replace "a" "A";</pre></td></tr>
</table>
 

<p>
 The replace command is often used for indenting generated code. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>indent a block of text</em></td></tr>
<tr><td><pre class="code-line">clear; get; replace "\n" "\n  "; put; clear;</pre></td></tr>
</table>
 

<p>
 Replace can also be used to test if the workspace contains a particular 
 character, in conjuntion with the "(==)" tape test. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>check if the workspace contains an 'x' </em></td></tr>
<tr><td><pre class="code-line">
    # fragment 
    put; replace 'x' ''; 
    (==) {
      clear; add "no 'x'"; print; clear;
    } 
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='UNTIL COMMAND'></a>
<h4 class="sub-section-heading">UNTIL COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>example</em></td></tr>
<tr><td><pre class="code-line">until 'text';</pre></td></tr>
</table>
 

<p>
 Reads the input stream until the workspace ends with the given 
 text. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print any text that occurs between '<' and '>' characters</em></td></tr>
<tr><td><pre class="code-line">/&lt;/ { until "&gt;"; print; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print only text between quote characters (excluding the quotes)</em></td></tr>
<tr><td><pre class="code-line">r; /"/ { until '"'; clip; clop; print; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create a parse token 'quoted' from quoted text</em></td></tr>
<tr><td><pre class="code-line">r; "/" { until '"'; clip; clop; put; add 'quoted*'; push; } clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print quoted text, reading past escaped quotes (\")</em></td></tr>
<tr><td><pre class="code-line">/"/ { until '"'; print; } clear;</pre></td></tr>
</table>
 

<p>
 The 'while' and 'whilenot' commands are similar to the until 
 command but they depend on the value of the 'peep' virtual 
 machine buffer (which is a single-character buffer) rather than 
 on the contents of the 'workspace' buffer like the until command. 

<p>
 ** notes 

<p>
 The 'until' command usually will form part of the 'lexing' phase 
 of a script. That is, the until command permits the script to 
 turn text patterns into 'tokens'. While in traditional parsing tools 
 (such as Lex and Yacc) the lexing and parsing phases are carried out 
 by seperate tools, with the 'pep' tool the two functions are combined. 

<p>
 The until command essentially performs 
 multiple read operations or commands and after each read checks to see 
 whether the workspace meets the criteria specified in the argument. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='WHILENOT COMMAND'></a>
<h4 class="sub-section-heading">WHILENOT COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 It reads into the workspace characters from the input stream -while- the 
 'peep' buffer is -not- a certain character. This is a "tokenizing" command 
 and allows the input stream to be parsed up to a certain character without 
 reading that character. 

<p>
 The whilenot command does not exit if it reaches the end of the 
 input-stream (unlike 'read'). 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print one word per line</em></td></tr>
<tr><td><pre class="code-line">r; [:space:] { d; } whilenot [:space:]; add "\n"; print; clear;</pre></td></tr>
</table>
 

<p>
 (there seems to be a bug in pep with whilenot "x" syntax) 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>whilenot can also take a single character quote argument</em></td></tr>
<tr><td><pre class="code-line">r; whilenot [z]; add "\n"; print; clear;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>another way to print one word per line</em></td></tr>
<tr><td><pre class="code-line">r; [ ] { while [ ]; clear; add "\n"; } print; clear;</pre></td></tr>
</table>
 

<p>
 The advantage of the first example is that it allows the 
 script to tokenise the input stream into words 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='WHILE COMMAND'></a>
<h4 class="sub-section-heading">WHILE COMMAND <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The 'while' command in the pattern-parse language reads the 
 input stream while the 'peep' buffer is any one of the 
 characters or character sets mentioned in the argument. 
 The command is written 
<table><td><pre class="code-line">while [cdef];</pre></td></table>
 

<p>
 The command takes one argument. This argument may also 
 include character classes as well as literal characters. 
 From example, 
<table><td><pre class="code-line">while [:space:];</pre></td></table>
 

<p>
 reads the input stream while the peep buffer is a digit. 
 The read characters are appended to the 'workspace' buffer. 
 The while command cannot take a quoted argument ("xxx"). 

<p>
 Negation for the while command is currently supported 
 using the "whilenot" command. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ENDSWITH TEST'></a>
<h4 class="sub-section-heading">ENDSWITH TEST <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The 'ends with' test checks whether the workspace ends 
 with a given string. This test is written 
<table><td><pre class="code-line">E"xyz" { ... }</pre></td></table>
 

<p>
 The script language contains a structure to perform a 
 test based on the content of the workspace and to 
 execute commands depending on the result of that test. 
 An example of the syntax is 
<table><td><pre class="code-line">"ocean" { add " blue"; print; }</pre></td></table>
 

<p>
 In the script above, if the workspace buffer is the text "ocean" then the 
 commands within the braces are executed and if not, then not. The test 
 structure is a simple string equivalence test, there are -no- regular 
 expressions and the workspace buffer must be -exactly- the text which is 
 written between the <a href='//'><em><tt>//</tt></em></a> characters or else the test will fail, or return 
 false, and the commands within the braces will not be executed. 

<p>
 This command is clearly influenced by the <a href='http://sed.sf.net'>sed</a> 
 stream editor command which has a virtually identical syntax 
 except for some key elements. In sed regular expressions are 
 supported and in sed the first opening brace must be on the 
 same line as the test structure. 

<p>
 There is also another test structure in the script language 
 which checks to see if the workspace buffer -begins- with the 
 given text and the syntax looks like this 
<table><td><pre class="code-line">B"ocean" { add ' blue'; print; }</pre></td></table>
 <em class='code-description'>the List test (not implemented as of july 2020, and I</em> 
 dont think I will implement it) 

<p>
 A possible future "list" test could be written as 
<table><td><pre class="code-line">:nouns.txt: { ... } </pre></td></table>
 

<p>
 The list test determines if the workspace matches any one 
 of a list of strings which are contained within a text 
 file. In the example given above the name of the text file 
 is "nouns.txt" . If the "workspace;" was "dog" at the time 
 that the test was executed and the string "dog" was 
 contained in the text file "nouns.txt" , then the test would 
 return -true- and the instructions within the braces would 
 be executed. However if the word "dog" was not contained 
 in the text file then the test would return false, and 
 the instructions within the braces would -not- be 
 executed. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='USING TESTS IN THE PEP TOOL'></a>
<h3 class="section-heading">USING TESTS IN THE PEP TOOL <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TEST EXAMPLES'></a>
<h4 class="sub-section-heading">TEST EXAMPLES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>if the workspace is not empty, add a dot to the end of the workspace</em></td></tr>
<tr><td><pre class="code-line">!"" { add '.'; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>if the end of the input stream is reached print the message "end of file"</em></td></tr>
<tr><td><pre class="code-line">&lt;eof&gt; { add "end of file"; print; }</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>if the workspace begins with 't' trim a character from the end</em></td></tr>
<tr><td><pre class="code-line">B"t" { clip; }</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TAPE TEST'></a>
<h4 class="sub-section-heading">TAPE TEST <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The tape test determines if the current element of the tape structure is the 
 same as the workspace buffer. 

<p>
 The tape test is written 
<table><td><pre class="code-line">&lt;==&gt;</pre></td></table>
 

<p>
 This test was included originally in order to parse the sed structure 
<table><td><pre class="code-line">s@old@new@g  or s/old/new/g or s%old%new%g</pre></td></table>
 
 In other words, in sed, any character can be used to delimite the 
 text in a substitue command. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ACCUMULATOR'></a>
<h3 class="section-heading">ACCUMULATOR <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='STACK STRUCTURE IN THE VIRTUAL MACHINE'></a>
<h3 class="section-heading">STACK STRUCTURE IN THE VIRTUAL MACHINE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The 'virtual'-machine of the pep language contains 
 a stack structure which is primarily intended to hold 
 the parse tokens during the parsing and transformation 
 of a text pattern or language. However, the stack 
 could hold any other string data. Each element of the 
 stack structure is a string buffer of unlimited size. 

<p>
 The stack is manipulated using the pop and push commands. 
 When a value is popped off the stack, that value is appended 
 to the -front- of the workspace buffer. If the stack is 
 empty, then the pop command has no effect. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TAPE IN THE PEP MACHINE'></a>
<h3 class="section-heading">TAPE IN THE PEP MACHINE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The tape structure in the virtual machine is an infinite 
 array of elements. Each of these elements is a string buffer 
 of infinite size. The elements of the tape structure may be 
 accessed using the @increment , @decrement , @get and @put 
 commands. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TAPE AND THE STACK'></a>
<h4 class="sub-section-heading">TAPE AND THE STACK <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The tape structure in the virtual machine and the @stack 
 structure and designed to be used in tandem, and several 
 mechanisms have been provided to enable this. For example, 
 when a "pop" operation is performed, the @tape-pointer is 
 automatically decremented, and when a @push operation is 
 performed then the tape pointer is automatically incremented. 

<p>
 Since the parsing language and machine have been designed 
 to carry out parsing and transformation operations on 
 text streams, the tape and stack are intended to hold 
 the values and tokens of the parsing process. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='BACKUSNAUR FORM AND THE PATTERN PARSER'></a>
<h3 class="section-heading">BACKUSNAUR FORM AND THE PATTERN PARSER <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 Backus-naur form is a way of expressing grammar rules for formal languages. 
 A variation of BNF is "EBNF" which modifies slightly the syntax of bnf. 
 Sometimes on this site I use (yet another) syntax for bnf or ebnf rules but 
 the idea is the same. 

<p>
 There is close relationship between the syntax of the 'pep' language 
 and a bnf grammar. For example 
<table><td><pre class="code-line">"word*colon*" { clear; add 'command*'; push }</pre></td></table>
 

<p>
 corresponds to the grammar rule 
<table><td><pre class="code-line">command := word colon</pre></td></table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SELF REFERENTIALITY'></a>
<h3 class="section-heading">SELF REFERENTIALITY <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The parse script language is a language which is designed to 
 parse/compile/translate languages. This means that it can 
 recognise/parse/compile, and translate itself. The script 
 books/pars/translate.c.pss is an example of this. 

<p>
 Another interesting application of this self-referentiality 
 is creating a new compiling system in a different target language. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='REFLECTION SELF HOSTING AND SELF PARSING'></a>
<h3 class="section-heading">REFLECTION SELF HOSTING AND SELF PARSING <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The script "compile.pss" is a parse-script which implements the 
 parse-script language. This was achieved by first writing a hand-coded 
 "assembler" program for the machine (contained in the file "asm.pp" ). 
 Once a working asm.pp program implemented a basic syntax for the language, 
 the compile.pss script was written. This makes it possible to maintain and 
 add new syntax to the language using the language itself. 

<p>
 A new "asm.pp" file is generated by running 
<table><td><pre class="code-line">pep -f compile.pss compile.pss &gt;&gt; asm.new.pp; cp asm.new.pp asm.pp</pre></td></table>
 

<p>
 Finally it is necessary to comment out the 2 "print" commands near 
 the end of the "asm.pp" file which are labelled ":remove:" 

<p>
 The command above runs the script compile.pss and also uses compile.pss as 
 its text input stream. In this sense the system is "self-hosting" and 
 "self-parsing" . It is also a good idea to preserve the old copy of asm.pp 
 in case there are errors in the new compiler. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SED THE STREAM EDITOR'></a>
<h3 class="section-heading">SED THE STREAM EDITOR <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The concept of "cycles" is drawn directly from the sed 
 language or tool (sed is a unix utility). In the sed language 
 each statement in a sed script is executed once for each -line- 
 in a given input stream. In other words there is a kind of 
 implicit "loop" which goes around the sed script. This loop in some 
 fictional programming language might look like: 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>pseudo</em></td></tr>
<tr><td><pre class="code-line">
  while more input lines
  do
    sed script
  loop
 </pre></td></tr>
</table>
 

<p>
 In the current parse-language the cycles are executed for each 
 -character- in the input stream (as opposed to line). 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SHIFTING AND REDUCING'></a>
<h3 class="section-heading">SHIFTING AND REDUCING <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 There is one complicating factor which is the concept of multiple 
 shift-reduces during the "shift-reduce parsing  one cycle or the
 interpreter. This concept has already been treated within the @flag command 
 documentation. Another tricky concept is grammar rule precedence, in other 
 words, which grammar rule shift-reduction should be applied first or with 
 greater predence. In terms of any concrete application the order of the 
 script statements determines precedence. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SHIFT REDUCTIONS ON THE STACK'></a>
<h4 class="sub-section-heading">SHIFT REDUCTIONS ON THE STACK <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Imagine we have a 'pep' script as follows: 
<table><td><pre class="code-line">
    pop;pop;
    "command*command*",
    "commandset*command*" { 
      clear; add 'commandset*'; push;
    }
    "word*colon*" {
      clear; add 'command*'; push; 
    }      
    push; push;
  </pre></td></table>
 

<p>
 This script corresponds directly to the (e)bnf grammar rules 
<table><td><pre class="code-line">
    commandset := command , command;
    commandset := commandset , command;
    command := word , colon;
  </pre></td></table>
 

<p>
 But in the script above there is a problem; that the first rule 
 needs to be applied after the second rule. 

<p>
 But it seems now that another reduction should occur namely 
<table><td><pre class="code-line">if-block --&gt; if-statement block</pre></td></table>
 

<p>
 which can be simply implemented in the language using the 
 statements: 
<table><td><pre class="code-line">
    pop; pop;
    "if-statements*block*" { clear; add "if-block*"; push; }
  </pre></td></table>
 

<p>
 But the crucial question is, what happens if the statements just written 
 come before the statements which were presented earlier on? The problem is 
 that the second reduction will not occur because the script has already 
 passed the relevant statements. This problem is solved by the 
 .reparse command and the parse> label 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PARSE TOKENS'></a>
<h3 class="section-heading">PARSE TOKENS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LITERAL TOKENS'></a>
<h4 class="sub-section-heading">LITERAL TOKENS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 One trick in the parse script language is to use a "terminal" 
 character as its own parse-token. This simplifies the lexing phase 
 of the script. The procedure is just to read the terminal symbol 
 (one or more characters) and then add the token delimiter character 
 on the end. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>using literal tokens with the default token delimiter '*'</em></td></tr>
<tr><td><pre class="code-line">
     read; 
     "{","}","(",")","=" {
       put; add "*"; push; .reparse
     }
   </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PURPOSE OF THE LANGUAGE AND VIRTUAL MACHINE'></a>
<h3 class="section-heading">PURPOSE OF THE LANGUAGE AND VIRTUAL MACHINE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The language is designed to allow the simple creation of parsers and 
 translators, without the necessity to become involved in the complexities of 
 something like Lex or Yacc. Since the interpreter for the language is based 
 on a virtual machine, the language is platform independant and has a level 
 of abstraction. 

<p>
 The language combines the features of a tokenizer and parser and 
 translator. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='AVAILABLE IMPLEMENTATIONS'></a>
<h3 class="section-heading">AVAILABLE IMPLEMENTATIONS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 <a href='http://bumble.sourceforge.net/books/pars/object/'>http://bumble.sourceforge.net/books/pars/object/</a> 
 This folder contains a working implementation in the c language. 
 The code can be compiled with the bash functions in the file 
 "helpers.pars.sh" 

<p>
 <a href='http://bumble.sourceforge.net/books/pars/object.js'>http://bumble.sourceforge.net/books/pars/object.js</a> 
 An javascript object that can be used with the pep tool and 
 the script "translate.javascript.pss" to translate scripts into 
 javascript. 

<p>
 <a href='http://bumble.sourceforge.net/books/pars/translate.java.pss'>http://bumble.sourceforge.net/books/pars/translate.java.pss</a> 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMPARISON BETWEEN PEP AND SED'></a>
<h3 class="section-heading">COMPARISON BETWEEN PEP AND SED <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The pep tool was largely inspired by the "sed" stream editor. Sed is a program 
 designed to find and replace patterns in text files. The patterns which Sed 
 replaces are "regular expressions" 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SIMILARITIES'></a>
<h4 class="sub-section-heading">SIMILARITIES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 <em class='code-description'>The workspace:</em> 
 Both sed and the pep machine have a 'workspace' buffer (which in sed is 
 called the "pattern space" ). This workspace is the area where 
 manipulations of the text input stream are carried out. <em class='code-description'>The script cycle:</em> 
 The languages are based on an implicit cycle. That is to say 
 that each command in a sed or a pep script is executed once 
 for each line (sed) or once for each character (pp) <em class='code-description'>Syntax:</em> 
 The syntax of sed and pep are similar. Statement blocks are 
 surrounded by curly braces {} and statements are terminated with 
 a semi-colon ; .Also the sed idea of "tests" based on the contents 
 of the "pattern space" (or @workspace ) is used in the pep 
 language. <em class='code-description'>Text streams:</em> 
 Both sed and pep are text stream based utilities, like many 
 other unix tools. This means that both sed and pep consume an 
 input text stream and produce as output an output text stream. 
 These streams are directed to the programs using "pipes" | in a 
 console window on both unix and windows systems. For example, for 
 sed we could write in a console window 
<table><td><pre class="code-line">echo abcabcabc | sed "s/b/B/g"</pre></td></table>
 
 and the output would be 
<table><td><pre class="code-line">aBcaBcaBc</pre></td></table>
 
 In the case of "pep" , the command line could be written 
<table><td><pre class="code-line">echo abcabcabc | pep -e "'b'{d;add'B'} print;d;"</pre></td></table>
 

<p>
 and the output, once again will be 
<table><td><pre class="code-line">aBcaBcaBc</pre></td></table>
 
 - 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DIFFERENCES'></a>
<h4 class="sub-section-heading">DIFFERENCES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 <em class='code-description'>Lines vs characters:</em> 
 Sed (like AWK) is a "line" based system whereas pep is a character 
 based script language. This means that the sed script is 
 executed once for each line of the input text stream, but in the 
 case of pep, the script is executed once for each character 
 of the input text stream. <em class='code-description'>Strict syntax:</em> 

<p>
 In some respects, the syntax of the pep language is stricter than 
 that of sed. For example, in a pep script all commands must end with a 
 semi-colon (except .reparse, parse> and .restart - which affect program 
 flow) and all statements after a test must be enclosed in curly braces. 
 In sed, it is not always necessary to terminate commands with a 
 semi-colon. For example, both of the following are valid sed statements. 
<table><td><pre class="code-line">s/b/B/g s/b/B/g;</pre></td></table>
 <em class='code-description'>White space:</em> 
 Pep is more flexible with the placement of whitespace in 
 scripts. For example, in pep one can write 
<table><td><pre class="code-line">
        "text" 
        { print; }
      </pre></td></table>
 

<p>
 That is, the opening brace is on a different line to the 
 test. This would not be a legal syntax in most versions of sed. <em class='code-description'>Command names:</em> 

<p>
 Sed uses single character "memnonics" for its commands. For example, 
 "p" is print, "s" is substitute, "d" is delete. In the pep 
 language, in contrast, commands also have a long name, such as 
 "print" for print the workspace, "clear" for clear the workspace, or 
 "pop" to pop the last element of the stack onto the workspace. 
 While the sed approach is useful for writing very short, terse 
 scripts, the readability of the scripts is not good. Pep allows 
 for improved readability, as well as terseness if required. <em class='code-description'>The virtual machines:</em> 
 While both sed and pep are in a sense baed on 
 "virtual machines" , the machine for pep is more 
 extensive. The sed machine essential has 2 buffers, the pattern space, 
 and the hold space. The pep @virtual-machine ,however has a 
 workspace, a stack, a tape, an counter variable amongst other things. <em class='code-description'>Regular expressions:</em> 
 The tests or "ranges" in sed, as well as the substitutions are based 
 on regular expressions. In pep, however, no regular expressions are 
 used. The reason for this difference is that pep is designed to 
 parse and transform a different set of patterns than sed. The patterns 
 that pep is designed to deal with are referred to formally as 
 "context free languages" <em class='code-description'>Negation of tests:</em> 

<p>
 The negation operator ! in the "pep" language is placed 
 before the test to which is applies, where as in sed the 
 negation operator comes after the test or range. So, 
 in pep it is correct to write 
<table><td><pre class="code-line">!"tree" { ... }</pre></td></table>
 
 But in sed the correct syntax is 
<table><td><pre class="code-line">/tree/! { ... }</pre></td></table>
 <em class='code-description'>implicit read and print</em> 
 Sed implicitly reads one line of the input stream for 
 each cycle of the script. Pep does not do this, so 
 most scripts need an explicit "read" command at the 
 beginning of the script. For example 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a sed script with an implicit line read</em></td></tr>
<tr><td><pre class="code-line">s/a/A/g;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>pep has no implicit character read or print</em></td></tr>
<tr><td><pre class="code-line">r; replace "a" "A"; print; clear;</pre></td></tr>
</table>
 

<p>
 BACKUS-NAUR FORM AND THE PATTERN PARSER 

<p>
 Backus-naur form is a way of expressing grammar rules for formal languages. 
 A variation of BNF is "EBNF" which modifies slightly the syntax of bnf. 
 There are many versions of bnf and ebnf 

<p>
 There is close relationship between the syntax of the 'pep' language 
 and a bnf grammar. For example: 
<table><td><pre class="code-line">"word*colon*" { clear; add "command*"; push }</pre></td></table>
 

<p>
 corresponds to the backus-naur form grammar rule 
<table><td><pre class="code-line">command := word colon</pre></td></table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PEP LANGUAGE PARSING ITSELF'></a>
<h3 class="section-heading">PEP LANGUAGE PARSING ITSELF <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 One interesting challenge for the pep language is to "generate itself" 
 from a set of bnf rules. In other words given rules such as 
<table><td><pre class="code-line">
    command := word semicolon;
    command := word quotedtext semicolon;
  </pre></td></table>
 

<p>
 then it should be possible to write a script in the language 
 which generates the output as follows 
<table><td><pre class="code-line">
   pop;pop;
   "word*semicolon*" {
     clear; add "command*"; push; .reparse
   }
   pop;
   "word*quotedtext*semicolon*" {
     clear;  add "command*"; push; .reparse
   }
   push;push;push;
  </pre></td></table>
 

<p>
 When I first thought of a virtual machine for parsing languages, 
 I thought that it would be interesting and important to build 
 a more expressive language "on top of" the pep commands. However, 
 that now seems less important. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TOKEN ATTRIBUTE TRANSFORMATIONS'></a>
<h3 class="section-heading">TOKEN ATTRIBUTE TRANSFORMATIONS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 We can write complete translators/compilers with the script language. 
 However it may be nice to have a more expressive format like the one shown 
 below. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a more expressive compiling language built on top of the parse language</em></td></tr>
<tr><td><pre class="code-line">
   command := word semicolon {
     $0 = "&lt;em&gt;" $1 "&lt;/em"&gt; $2;
   };
 ...
   
 The $n structure will fetch the tape-cell for the corresponding 
 identifier in the bnf rule at the start of the brace block.
 This would be "compiled" to pep syntax as 

  ----
   pop;pop;
   "word*semicolon*" {
     clear; 
     # assembling: $0 = "&lt;em&gt;" $1 "&lt;/em"&gt; $2;
     add "&lt;em&gt;"; get; add "&lt;/em&gt;"; ++; get; --; put; clear;
     # resolve new token 
     add "command*"; push; .reparse
   }

   push;push;
  </pre></td></tr>
</table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='SHIFT REDUCTIONS ON THE STACK'></a>
<h3 class="section-heading">SHIFT REDUCTIONS ON THE STACK <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 Imagine we have a "recogniser" pep script as follows: 
<table><td><pre class="code-line">
    read; 
    ";" { clear; add "semicolon*"; push; }
    [a-z] { 
      while [a-z]; clear; add "word*"; push; 
    } 
  parse&gt;
    pop;pop;
    "command*command*" 
      { clear; add 'commandset*'; push; .reparse }
    "word*semicolon*" 
      { clear; add 'command*'; push; .reparse }      
    push; push;
    (eof) { 
       pop; pop; push; 
       !"" { 
         clear; add "incorrect syntax! \n"; print; quit;
       }
       pop;
       "command*", "commandset*" {
         clear; add "Correct syntax! \n"; print; quit;
       }
    }
  </pre></td></table>
 

<p>
 This script recognises a language which consists of a series 
 of "commands" (which are lower case words) terminated in semicolons. 
 At the end of the script, there should only be one token on the 
 stack (either command* or commandset*). 

<p>
 This script corresponds reasonable directly to the ebnf rules 
<table><td><pre class="code-line">
    word := [a-z]+;
    semicolon := ';';
    commandset := command command;
    command := word semicolon;
  </pre></td></table>
 

<p>
 But in the script above there is a problem; that the first rule 
 needs to be applied after the second rule. 

<p>
 The above statements in the pep language execute a reduction according to 
 the grammar rule written above. Examining the state of the machine 
 before and after the script statements above .... 

<p>
 ==:: virtual machine 
 .. stack, if-statement, open-brace*, statements*, close-brace* 
 .. tape, if(a==b), {, a=1; b=2*a; ..., } 
 .. workspace, 
 .., 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='NEGATION OF TESTS'></a>
<h3 class="section-heading">NEGATION OF TESTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 a test such as 
<table><td><pre class="code-line">"some-text" { #* commands *# }</pre></td></table>
 

<p>
 can be modified with the logic operator "!" (not) as in 
<table><td><pre class="code-line">!"some-text" { #* commands *# }</pre></td></table>
 

<p>
 Note that the negation operator '!' must come before the test which it 
 modifies, instead of afterwards as in sed. 

<p>
 Multiple negations are not allowed 
<table><td><pre class="code-line">!!"some-text" {...} # incorrect</pre></td></table>
 

<p>
 ** Examples 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print only numbers in the input </em></td></tr>
<tr><td><pre class="code-line">r; ![0-9] { clip; add " "; print; clear; }</pre></td></tr>
</table>
 

<p>
 If the workspace does not begin with the text 'apple' then 
 print the workspace 
<table><td><pre class="code-line">r; E" " { !B"apple" { print; } clear; }</pre></td></table>
 

<p>
 If the workspace does not match any of the lines of 
 the file <a href='verbs.txt'><em><tt>verbs.txt</tt></em></a> then add the text 'noun' to 
 the workspace 
<table><td><pre class="code-line">!=verbs.txt= { add 'noun'; }</pre></td></table>
 

<p>
 If the end of the input stream has not been reached 
 then push the contents of the workspace onto the 
 stack 
<table><td><pre class="code-line">!(eof) { push; } </pre></td></table>
 

<p>
 If the value of the workspace is exactly equal to the 
 value of the current element of the tape, then exit 
 the script immediately 
<table><td><pre class="code-line">!(==) { quit; } </pre></td></table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMMENTS IN THE PARSER LANGUAGE'></a>
<h3 class="section-heading">COMMENTS IN THE PARSER LANGUAGE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 Both single line, and multiline comments are available in the 
 parser script language as implemented in books/pars/asm.pp and 
 compile.pss 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>single and muliline examples</em></td></tr>
<tr><td><pre class="code-line"> 
  #* check if the workspace 
    is the text "drib" *#
  "drib" {
    clear; # clear the workspace buffer 
  }
 </pre></td></tr>
</table>
 

<p>
 The script books/pars/compile.pss attempts to preserve comments 
 in the output "assembler" code to make that code more readable. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='GRAMMAR AND SCRIPT CONSTRUCTION'></a>
<h3 class="section-heading">GRAMMAR AND SCRIPT CONSTRUCTION <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 My knowledge of formal grammar theory is quite limited. I am more 
 interested in practical techniques. But there is a reasonably close 
 correlation between bnf-type grammar rules and script construction. 

<p>
 The right-hand-side of a (E)BNF grammar rule is represented by the 
 quoted text before a brace block, and the left-hand-side 
 correlates to the new token pushed onto the stack. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>the rule "<nounphrase> ::= <article> <noun> ;" in a parse script</em></td></tr>
<tr><td><pre class="code-line">"article*noun*" { clear; add "nounphrase*"; push; }</pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TRICKS'></a>
<h3 class="section-heading">TRICKS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 This section contains tips about how to perform specific tasks 
 within the limitations of the parse machine (which does not have 
 regular expressions, nor any kind of arithmetic). 

<p>
 See the example eg/plzero.pss for an example of reducing high 
 token rules before low token rules, in order to resolve 
 precedence issues. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>check if accumulator is equal to 4</em></td></tr>
<tr><td><pre class="code-line">
    read; a+; put; clear; count; 
    "4" {  
      clear; add "4th char is '"; get; "'\n"; print; clear;
    }
    
  </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>check if the workspace matches the regex /[0-9]{3,}/</em></td></tr>
<tr><td><pre class="code-line">
    [0-9] { clip; clip; clip; !"" { #* &lt;commands&gt; *# } }
  </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>see how long a word is </em></td></tr>
<tr><td><pre class="code-line">
    read; 
    ![:space:] { 
      nochars; whilenot [:space:]; put; clear; 
      add "word length = "; chars; print; clear; 
    }
    # if the workspace is not empty, it must be white-space
    # just ignore it.
    !"" { clear; }
  </pre></td></tr>
</table>
 

<p>
 The script below uses a trick of using the replace command 
 with the "tape equals workspace" test (==) to check if the 
 workspace contains a particular string. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print only lines that contain the text 'puma' </em></td></tr>
<tr><td><pre class="code-line">
    whilenot [\n]; 
    put; replace "puma" ""; !(==) { clear; get; print; } 
    (eof) { quit; } 
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='MULTIPLEXING TOKEN SEQUENCES'></a>
<h4 class="sub-section-heading">MULTIPLEXING TOKEN SEQUENCES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Sometimes it is useful to have a long list of token sequences 
 before a brace block. One way to reduce this list is as follows 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>using nested tests to reduce token sequence lists</em></td></tr>
<tr><td><pre class="code-line">
     pop; pop;
     B"aa*","bb*","cc*" {
       E"xx*","yy*","zz*" {
         # process tokens here.
         nop;
       }
     }
     # equivalent long token sequence list
     "aa*xx*","aa*yy*","aa*zz*","bb*xx*","bb*yy*","bb*zz*"
     "cc*xx*","cc*yy*","cc*zz*" {
       nop;
     }
   </pre></td></tr>
</table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='NOTES FOR A REGEX PARSER'></a>
<h4 class="sub-section-heading">NOTES FOR A REGEX PARSER <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>parse a regex between / and / </em></td></tr>
<tr><td><pre class="code-line">
    #*
    tokens for the regex parser
      class: [^-a\][bc1-5+*()]
      spec: the list and ranges in [] classes
      char: one character 
    *#

    begin { while [:space:]; clear; }
    read;
    !"/" { 
      clear; add "error"; print; quit;
    }
    # special characters for regex can be literal tokens
    [-/\]()+*$^.?] {
      "*" { put; clear; add "star*"; push; .reparse }
      add '*'; push; .reparse
    }

    # the start of class tests [^ ... ]
    "[" {
      read; 
      # empty class [] is an error
      "]" { 
        clear; add "Empty class test [] at char "; chars;
        print; quit;
      }
      # negated class test
      "^" { clear; add "[neg*"; push; .reparse }
      # not negated
      clear; add "[*char*"; push; push; .reparse
    }

    # just get the next char after the escape char 
    "\\ " { 
      (eof) { clear; add "error!"; print; quit; } 
      clear; read; 
      [ntfr] { 
        "n" { clear; add "\n"; }
        "t" { clear; add "\t"; }
        "f" { clear; add "\f"; }
        "r" { clear; add "\r"; }
        put; clear; add "char*"; push; 
      }
    }
    !"" { put; add "char*"; push; .reparse }
   parse&gt;
    pop; pop;
    "char*star*" { clear; add "pattern*"; .reparse }
    "char*char*" { clear; add "pattern*char*"; push; push; .reparse }
    "[*]*" { clear; add "error!"; print; quit; } 

    # 3 tokens
    pop;
    
    # parsing class tests eg: [ab0-9A-C^&*] or [^-abc]
    # so the only special characters in classes are []^(negation)
    # - indicates a range, except when it is the 1st char in the brackets
    #
    # sequences like: [*char*char* [*-*char*

    B"[*",B"[neg*" {
      # in brackets, a-b is a range
      !E"]*".!E"-*" {
        # manip attributes
        clear; add "[*spec*char*"; push; push; push; .reparse
      }
    }
    
    # token sequences, eg: spec/char/? spec/+/+ spec/./char
    B"spec*" {
      !E"]*".!E"-*" {
        # manip attributes
        get; ++; get; --; put;
        clear; add "spec*char*"; push; push; .reparse
      }
    }
    
    "[*spec*]*","[*char*]*" {
      ++; get; --; put;
      clear; add "class*"; push; .reparse
    }

    "[neg*spec*]*","[neg*char*]*" {
      ++; get; --; put;
      clear; add "negclass*"; push; .reparse
    }
    # end of class parsing

    # a pattern can be simple, like 'a*' or complex like 
    #  '[1-9abc\n]+' also a pattern can be a sequence of 
    # patterns
    "pattern*pattern*" {
      # this is a recogniser or checker. so just copy the patterns
      # across.
      get; ++; get; --; put;
      clear; add "pattern*"; push; .reparse
    }
    
    push; push;
    (eof) {
      add "Parse stack is: "; print; clear; unstack; print; quit;
    }
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMPILATION TECHNIQUES'></a>
<h3 class="section-heading">COMPILATION TECHNIQUES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 One of the enjoyable aspects of this parsing/compiling machine is 
 discovering interesting practical "heuristic" techniques for 
 compiling syntactical structures, within the limitations of the 
 machine capabilities. 

<p>
 This section details some of these techniques as I discover them. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LOOKAHEAD'></a>
<h4 class="sub-section-heading">LOOKAHEAD <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 the script eg/mark.latex.pss contains a clumsy token lookahead. 
 But I may try to convert it to a new technique 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a technique for lookahead parsing (json)</em></td></tr>
<tr><td><pre class="code-line">
    pop; pop; pop; pop;
    # the test below ensures that there is 4 tokens in the workspace
    # the final token will normally be ]* or ,* (this is a json array)
    # but we dont have to worry about it
    B"items*,item*.!"items*item*" {
      replace "items*,item*" "items*";
      push; push; .reparse
    }
RULE ORDER ....

  In a script, after the parse&gt; label we can parse rules in the
  order of the number of tokens. Or we can group the rules by
  token. There are some traps, for example: "pop; pop;" doesnt
  guarantee that there are 2 tokens in the workspace.

RECOGNISERS AND CHECKERS ....

  A recogniser is a parser that only determines if a given string is a valid
  "word" in the given language. We can extend a recogniser to be an error
  checker for a given string, so that it determines at what point (character
  or line number) in the string, the error occurs. The error-checker can also
  give a probably reason for the error (such as the missing or excessive
  syntactic element) This is much more practically useful than a recogniser

  * examples with error messages
  ...

EMPTY START TOKEN ....

  When the start symbol is an array of another token, it may often
  simplify parsing to create an empty start token in a "begin" block
  ebnf: text = word*

  * using an empty start token
  -----
    begin { add "text*"; push; }
    read;
    # ignore whitespace
    [:space:] { while [:space:]; clear; }
    !"" { whilenot [:space:]; put; clear; add "word*"; push; }
  parse&gt;
    pop; pop;
    "text*word*" { clear; add "text*"; push; .reparse }  
    (eof) { 
      # check for start symbol 'text* here
    }
    push; push; 
  </pre></td></tr>
</table>
 

<p>
 Without the empty "text*" token we would have to write 
<table><td><pre class="code-line">"text*word*","word*word*" { &lt;commands&gt; }</pre></td></table>
 

<p>
 This is not such a great disadvantage, but it does lead to 
 inefficient compiled code, because the "word*word*" token 
 sequence only occurs once when running the script (at the 
 beginning of the input stream) 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>compiled code for "text*word*","word*word*" { ... }</em></td></tr>
<tr><td><pre class="code-line">
  </pre></td></tr>
</table>
 

<p>
 Secondly, in other circumstances, there are other advantages 
 of the empty start symbol. See the pars/eg/history.pss script 
 for an example. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='END OF STREAM TOKEN'></a>
<h4 class="sub-section-heading">END OF STREAM TOKEN <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This is an analogous technique to the "empty start symbol" . In 
 many cases it may simplify parsing to create a "dummy" end token 
 when the end-of-stream is reached. This token should be created 
 immediately after the parse> label 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>example of use of "end" token to parse dates in text</em></td></tr>
<tr><td><pre class="code-line">
    # tokens: day month year word
    # rules: 
    #    date = day month year
    #    date = day month word 
    #    date = day month end
    read;
    ![:space:] { 
      whilenot [:space:]; put; clear; 
      [0-9] {
        # matches regex: /[0-9][0-9]*/
        clip; clip; !"" {
        }
      add "word*"; push;
    }
   parse&gt;
    (eof) {
    }
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PALINDROMES'></a>
<h4 class="sub-section-heading">PALINDROMES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Palindromes are an interesting exercise for the machine because 
 they may be the simplest context-free language. 

<p>
 The script below is working but also prints single letters 
 as palindromes. See the note below for a solution. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>print only words that are palindromes</em></td></tr>
<tr><td><pre class="code-line">
    read; 
    # the code in this block builds 2 buffers. One with 
    # the original word, and the other with the word in reverse
    # Later, the code checks whether the 2 buffers contain the 
    # same text (a palindrome).
    ![:space:] {
      # save the current character
      ++; ++; put; --; --;
      get; put; clear;
      # restore the current character
      ++; ++; get; --; --;
      ++; swap; get; put; clear; --;
    } 

    # check for palindromes when a space or eof found
    [:space:],&lt;eof&gt; { 
      # clear white space
      [:space:] { while [:space:]; clear; }
      # check if the previous word was a palindrome
      get; ++; 
      # if the word is the same as its reverse and not empty
      # then its a palindrome. 
      (==) { 
        # make sure that palindrome has &gt; 2 characters
        clip; clip; 
        !"" { clear; get; add "\n"; print; }
      } 
      # clear the workspace and 1st two cells
      clear; put; --; put;
    }

  </pre></td></tr>
</table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LINE BY LINE TOKENISATION'></a>
<h4 class="sub-section-heading">LINE BY LINE TOKENISATION <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 See the example below and adapt 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a simple line tokenisation example</em></td></tr>
<tr><td><pre class="code-line">
    read; 
    [\n] { clear; }
    whilenot [\n]; put; clear;
    add "line*"; push;
  parse&gt;
    pop; pop; 
    "line*line*", "lines*line*" {
      clear; get; add "\n"; ++; get; --; put; clear;
      add "words*"; push; .reparse
    }
    push; push;
    (eof) {
       pop; "lines*" { clear; get; print; }
    }
  </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>remove all lines that contain in a particular text </em></td></tr>
<tr><td><pre class="code-line">
    until "

  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='WORD BY WORD TOKENISATION'></a>
<h4 class="sub-section-heading">WORD BY WORD TOKENISATION <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 A common task is to treat the input stream as a series of space 
 delimited words. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a simple word tokenisation example, print one word per line</em></td></tr>
<tr><td><pre class="code-line">
    read; [:space:] { clear; }
    whilenot [:space:]; put; clear;
    add "word*"; push;
  parse&gt;
    pop; pop; 
    "word*word*", "words*word*" {
      clear; get; add "\n"; ++; get; --; put; clear;
      add "words*"; push; .reparse
    }
    push; push;
    (eof) {
       pop; "words*" { clear; get; print; }
    }
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='REPETITIONS'></a>
<h4 class="sub-section-heading">REPETITIONS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The parse machine cannot directly encode rules which contain the ebnf 
 repetition construct {}. The trick below only creates a new list token if 
 the preceding token is not a list of the same type. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a technique for building a list token from repeated items </em></td></tr>
<tr><td><pre class="code-line">
     # ebnf rules:
     #   alist := a {a}
     #   blist := b {b}

     read;
     # terminal symbols
     "a","b" { add "*"; push; }
     !"" { 
       put; clear; 
       add "incorrect character '"; get; add "'";
       add " at position "; chars; add "\n"; 
       add " only a's and b's allowed. \n"; print; quit;
     }
   parse&gt;
     # 1 token (with extra token)
     pop;
     "a*" { 
       pop; !"a*".!"alist*a*" { push; } 
       clear; add "alist*"; push; .reparse
     }
     "b*" { 
       pop; !"b*".!"blist*b*" { push; } 
       clear; add "blist*"; push; .reparse
     }
     push;
     &lt;eof&gt; {
       unstack; put; clear; add "parse stack is: "; get;
       print; quit; 
     }

  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PLZERO CONSTANT DECLARATIONS'></a>
<h4 class="sub-section-heading">PLZERO CONSTANT DECLARATIONS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 An example of parsing a repeated element occurs in pl/0 constant 
 declarations. The rule in Wirth's ebnf syntax, is: 
<table><td><pre class="code-line">constdec =  "const" ident "=" number {"," ident "=" number} ";"</pre></td></table>
 

<p>
 Examples of valid constant declarations are 
<table><td><pre class="code-line">
    const g = 300, h=2, height = 200;
    const width=3;
  </pre></td></table>
 

<p>
 It is necessary to factor the ebnf rule to remove the repetition 
 element (indicated by the braces {} ). In the script below, the 
 repeated element is factored into the "equality" and "equalityset" 
 parse tokens. The script below may seem very verbose compared to the 
 ebnf rule but it lexes and parses the input stream, recognises 
 keywords and punctuation and provides error messages. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>recognise pl/0 constant declarations</em></td></tr>
<tr><td><pre class="code-line">
    begin {
      add '
      recognising pl/0 constant decs in the form:
       "const g = 300, h=2, height = 200;"
       "const width=3;"
      \n'; print; clear;
    }
    read;
    [:alpha:] { 
      while [:alpha:]; 
      # keywords in pl/0
      "const","var","if","then","while","do","begin","end" { 
        put; add "*"; push; .reparse
      }
      put; clear; add "ident*"; 
      push; .reparse 
    }
    [0-9] { 
      while [0-9]; put; clear; add "number*"; 
      push; .reparse 
    }
    # literal tokens
    ",", "=", ";" { add "*"; push; }
    # ignore whitespace
    [:space:] { clear; }
    !"" {
      add " &lt;&lt; invalid character at position "; chars; 
      add ".\n"; print; quit;
    }
  parse&gt;

    pop; pop; pop;
    "ident*=*number*" {
      clear; add "equality*"; push; .reparse
    }
    "equality*,*equality*","equalityset*,*equality*" {
      clear; add "equalityset*"; push; .reparse
    }
    "const*equality*;*", "const*equalityset*;*" {
      clear; add "constdec*"; push;
    }
    push; push; push;

    &lt;eof&gt; {
      pop; pop;
      "constdec*" {
        clear; add " Valid PL/0 constant declaration!\n"; 
        print; quit;
      }
      push; push;
      add " Invalid PL/0 constant declaration!\n"; 
      add " Parse stack: "; 
      print; clear; unstack; print;
      quit;
    }
   
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='OFFSIDE OR INDENT PARSING'></a>
<h4 class="sub-section-heading">OFFSIDE OR INDENT PARSING <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Some languages use indentation to indicate blocks of code, or 
 compound statements. Python is an important example. These languages 
 are parsed using "indent" and "outdent" or "dedent" tokens. 

<p>
 The mark/go commands should allow parsing of indented languages. 

<p>
 completely untested and incomplete... 
 the idea is to issue "outdent" or "indent" tokens by 
 comparing the current leading space to a previous 
 space token. But the code below is a mess. 
 The tricky thing is that we can have multiple "outdent*" 
 tokens from one space* token eg 
<table><td><pre class="code-line">
     if g==x:
       while g&lt;100:
         g++
     g:=0;
   </pre></td></table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a basic indent parsing procedure</em></td></tr>
<tr><td><pre class="code-line">
    # incomplete!!
    read;
    begin { mark "b"; add ""; ++; }
    [\n] { 
      clear; while [ ]; put; mark "here"; go "b";
      # indentation is equal so, do nothing
      (==) { clear; go "here"; .reparse }
      add "  ";
      (==) { clear; add "indent*"; push; go "here"; .reparse }
      clip; clip;  
      clip; clip;  
      (==) { clear; add "outdent*"; push; go "here"; .reparse }
      put; clear; add "lspace*"; push;
      mark "b";
    }   
   parse&gt;
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='OPTIONALITY'></a>
<h4 class="sub-section-heading">OPTIONALITY <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The parse machine cannot directly encode the idea of an 
 optional "[...]" element in a bnf grammar. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a rule with an optional element</em></td></tr>
<tr><td><pre class="code-line">r := 'a' ['b'] .</pre></td></tr>
</table>
 

<p>
 In some cases we can just factor out the optional into alternation "|" 
<table><td><pre class="code-line">r := 'a' | 'a' 'b' .</pre></td></table>
 

<p>
 However once we have more than 2 or 3 optional elements in a rule, this 
 becomes impractical, for example 
<table><td><pre class="code-line">r := ['a'] ['b'] ['c'] ['d'] .</pre></td></table>
 

<p>
 In order to factor out the optionality above we would end up with 
 a large number of rules which would make the parse script very verbose. 
 Another approach is to encode some state into a parse token. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a strategy for parsing rules containing optional elements</em></td></tr>
<tr><td><pre class="code-line">
     # parse the ebnf rule
     # rule := ['a'] ['b'] ['c'] ['d'] ';' .
     begin { add "0.rule*"; push; }
     read;
     [:space:] { clear; }
     "a","b","c","d",";" { add "*"; push; .reparse  }
     !"" { add " unrecognised character."; print; quit; }
   parse&gt;
     pop; pop;
     E"rule*a*" { 
       B"0" { clear; add "1.rule*"; push; .reparse }
       clear; add "misplaced 'a' \n"; print; quit; 
     } 
     E"rule*b*" { 
       B"0",B"1" { clear; add "2.rule*"; push; .reparse }
       clear; add "misplaced 'b' \n"; print; quit; 
     } 
     E"rule*c*" { 
       B"0",B"1",B"2" { clear; add "3.rule*"; push; .reparse }
       clear; add "misplaced 'c' \n"; print; quit; 
     }
     E"rule*d*" { 
       B"0",B"1",B"2",B"3" { clear; add "4.rule*"; push; .reparse }
       clear; add "misplaced 'd' \n"; print; quit; 
     }

     E"rule*;*" { clear; add "rule*"; push; }

    push; push;
    (eof) {
      pop; 
      "rule*" { add " its a rule!"; print; quit; }
    } 
   </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='REPETITION PARSING'></a>
<h4 class="sub-section-heading">REPETITION PARSING <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Similar to the notes above about parsing grammar rules containing 
 optional elements, we have a difficulty when parsing elements or 
 tokens which are enclosed in a "repetition" structure. In ebnf 
 syntax this is usually represented with either braces "{...}" or 
 with a kleene star "*" . 

<p>
 We can use a similar technique to the one above to parse repeated 
 elements within a rule. 

<p>
 The rule parsed below is equivalent to the regular expression 
<table><td><pre class="code-line">/a?b*c*d?;/</pre></td></table>
 
 So the script below acts as a recogniser for the above regular 
 expression. I wonder if it would be possible to write a script 
 that turns simple regular expressions into parse-scripts? 

<p>
 In the code below we dont have any separate blist clist tokens 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>parsing repetitions within a grammar rule</em></td></tr>
<tr><td><pre class="code-line">
     # parse the ebnf rule
     # rule := ['a'] {'b'} {'c'} ['d'] ';' .
     # equivalent regular expression: /a?b*c*d?;/

     begin { add "0/rule*"; push; }
     read;
     [:space:] { clear; }
     "a","b","c","d",";" { add "*"; push; .reparse  }
     !"" { add " unrecognised character."; print; quit; }
   parse&gt;
   # ------------
   # 1 token
     pop;

   # ------------
   # 2 tokens 
     pop; 

     E"rule*a*" { 
       B"0" { clear; add "a/rule*"; push; .reparse }
       clear; add "misplaced 'a' \n"; print; quit; 
     } 
     E"rule*b*" { 
       B"0",B"a",B"b" { clear; add "b/rule*"; push; .reparse }
       unstack; add " &lt;&lt; parse stack.\n"; 
       add "misplaced 'b' \n"; print; quit;
     } 
     E"rule*c*" { 
       B"0",B"a",B"b",B"c" { clear; add "c/rule*"; push; .reparse }
       clear; add "misplaced 'c' \n"; 
       unstack; add " &lt;&lt; parse stack.\n"; print; quit;
     }
     E"rule*d*" { 
       B"0",B"a",B"b",B"c" { clear; add "d/rule*"; push; .reparse }
       clear; add "misplaced 'd' \n"; print; quit; 
     }

     E"rule*;*" { clear; add "rule*"; push; }

    push; push;
    (eof) {
      pop; 
      "rule*" { add " its a rule!"; print; quit; }
      unstack; add " &lt;&lt; parse stack.\n"; print; quit;
    } 
   </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PL ZERO'></a>
<h4 class="sub-section-heading">PL ZERO <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Pl/0 is a minimalistic language created by Niklaus Wirth, for 
 teaching compiler construction. 

<p>
 In this section, I will explore converting the pl/0 grammar 
 into a form that can be used by the parsing machine and 
 language. I will do this in stages, first parsing "expressions" 
 and then "conditions" etc. 

<p>
 Wirths grammar is designed to be used in a recursive descent 
 parser/compiler, so it will be interesting to see if it can be adapted for 
 the machine which is essentially a LR shift-reduce parser/compiler. 

<p>
 The grammar below seems to be adequate for LR parsing, except for 
 the expression tokens (expression, term, factor etc). Apart from 
 expression we should be able to factor out the various [] {} and () 
 constructs and create a machine parse script. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>the pl/0 grammar in wsn/ebnf form</em></td></tr>
<tr><td><pre class="code-line">

   program = block "." .
   block = [ "const" ident "=" number {"," ident "=" number} ";"]
        [ "var" ident {"," ident} ";"]
        { "procedure" ident ";" block ";" } statement .

   statement = [ ident ":=" expression | "call" ident 
              | "?" ident | "!" expression 
              | "begin" statement {";" statement } "end" 
              | "if" condition "then" statement 
              | "while" condition "do" statement ].

   condition = "odd" expression |
               expression ("="|"#"|"&lt;"|"&lt;="|"&gt;"|"&gt;=") expression .
   expression = [ "+"|"-"] term { ("+"|"-") term}.
   term = factor {("*"|"/") factor}.
   factor = ident | number | "(" expression ")".

  </pre></td></tr>
</table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PROGRAMS AND BLOCKS IN PLZERO'></a>
<h4 class="sub-section-heading">PROGRAMS AND BLOCKS IN PLZERO <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 I will try to keeps wirths grammatical structure, but factor the 
 2 rules and introduce new parse tokens for readability, such 
 "constdec*" for a constant declaration, and "vardec* for a variable
 declaration. I will also try to keep Wirth's rule names for reference 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>the program and block grammar rules</em></td></tr>
<tr><td><pre class="code-line">
   program = block "." .
   block = [ "const" ident "=" number {"," ident "=" number} ";"]
        [ "var" ident {"," ident} ";"]
        { "procedure" ident ";" block ";" } statement .
  </pre></td></tr>
</table>
 

<p>
 Once this script is written we can check if it is parsing 
 correctly, and then move on to variable declarations, proceedure 
 declarations and so forth (but not the forth language, which doesnt 
 require a grammar). 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PLZERO EXPRESSIONS'></a>
<h4 class="sub-section-heading">PLZERO EXPRESSIONS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>wsn/ebnf grammar for pl/0 expressions</em></td></tr>
<tr><td><pre class="code-line">
    expression = [ "+"|"-"] term { ("+"|"-") term}.
    term = factor {("*"|"/") factor}.
    factor = ident | number | "(" expression ")".
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='TRIGGER RULES'></a>
<h4 class="sub-section-heading">TRIGGER RULES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 
<table><td><pre class="code-line">',' orset '{' ::= ',' test '{' ;</pre></td></table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='NEGATED CLASSES'></a>
<h4 class="sub-section-heading">NEGATED CLASSES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Often when creating a language or data format, we want to 
 be able to negate operators or tests (so that the test has 
 the opposite effect to what it normally would). In the parse 
 script language I use the prefixed "!" character as the 
 negation operator. 

<p>
 We can create a whole series of negated "classes" or tokens in 
 the following way. So the "negation" logic is actually stored 
 on the stack, not on the tape. This is useful because we can 
 compile all these negated tokens in a similar way . 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>example of creating a set of negated classes</em></td></tr>
<tr><td><pre class="code-line">
    "!*quote*","!*class*","!*begintext*", "!*endtext*",
    "!*eof*","!*tapetest*" {
      replace "!*" "not"; push;
      # now transfer the token value
      get; --; put; ++; clear; .reparse
    }
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LOOKAHEAD AND REVERSE REDUCTIONS'></a>
<h4 class="sub-section-heading">LOOKAHEAD AND REVERSE REDUCTIONS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 Quotesets have been replaced in the current (aug 2019) implementation 
 of compile.pss with 'ortestset' and 'andtestset'. But the compilation 
 techniques are similar to those shown below. 

<p>
 The old implementation of the "quotesets" token in old versions of 
 compile.pss seems quite interesting. It waits until the stack contains a 
 brace token "{*" until it starts reducing the quoteset list. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>a quoteset, or a set of tests with OR logic</em></td></tr>
<tr><td><pre class="code-line">'a','b','c','d' { nop; }</pre></td></tr>
</table>
 

<p>
 so the compile.pss script actually parses "'c','d' { " first, and 
 then resolves the other quotes ('a','b'). This is good because 
 the script can work out the jump-target for the forward true jump. 
 (the accumulator is used to keep track of the forward true jump). 

<p>
 It also uses the brace as a lookahead, and then just pushes it 
 back on the stack, to be used later when parsing the whole brace block. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>bnf rules for parsing quotesets</em></td></tr>
<tr><td><pre class="code-line">quoteset '{' := quote ',' quote '{' ;</pre></td></tr>
</table>
 
<table><td><pre class="code-line">quoteset '{' := quote ',' quoteset '{' ;</pre></td></table>
 

<p>
 But this has 2 elements on the left-hand side. This works but is 
 not considered good grammar (?) 

<p>
 Multiple testset sequences may be used as a poor-womans 
 regular expression pattern matcher. <em class='code-description'>test if the workspace begins with 'http://', ends with '.txt' and</em> 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>doesnt contain the letter 'x'</em></td></tr>
<tr><td><pre class="code-line">
   B"http://", E".txt", ![x]  {
     add " (found text file link!) \n"; print; clear;
   }
 </pre></td></tr>
</table>
 

<p>
 It doesnt really make sense to combine a text-equals test with 
 any other test, but the other combinations are useful. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='RABBIT HOPS'></a>
<h4 class="sub-section-heading">RABBIT HOPS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The "set" token syntax parses a string such as 
<table><td><pre class="code-line">'a','b','c','d' { nop; }</pre></td></table>
 

<p>
 The comma is the equivalent of the alternation operator (|) in 
 bnf syntax. 

<p>
 In my first attempt to parse "quoteset" tokens with the "compile.pss" 
 script compiler, I used a rabbit hop technique. From an efficiency 
 and compiled code size point-of-view this is a very bad way to 
 compile the code, but it seems that it may be useful in other 
 situations. It provides a way to generate functional code when 
 the final jump-target is not know at "shift-reduce" time. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create rabbit hops for the true jump</em></td></tr>
<tr><td><pre class="code-line">
  "quote*,*quote*" {
     clear; add "testis "; get;
     # just jump over the next test
     add "\njumptrue 3 \n"; ++; ++;
     add "testis ";
     get;
     add "\n";
     # add the next jumptrue when the next quote is found
     --; --; put;
     clear;
     add "quoteset*";
     push;
     # always reparse/compile
     .reparse
   }
     
   # quoteset ::= quoteset , quote ;
   "quoteset*,*quote*" {
      clear; get;
      ++; ++;
      add "jumptrue 4 \n ";
      add "jumptrue 3 \n ";
      add "testis "; get;
      add "\n";
      # add the next jumptrue when/if the next quote is found
      --; --;
      put; clear;
      add "quoteset*";
      push;
      # always reparse/compile
      .reparse
    }

  </pre></td></tr>
</table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ASSEMBLY FORMAT AND FILES'></a>
<h3 class="section-heading">ASSEMBLY FORMAT AND FILES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The implementation of the language uses an intermediary "assembly" 
 phase when loading scripts. asm.pp is responsible for converting 
 the script into an assembly (text) format. "asm.pp" is itself an 
 assembly file. These files consist of "instructions" on the virtual 
 machine, along with "parameters" , jumps, tests and labels, which make 
 writing assembly files much easier (instead of having to use line 
 numbers). So the asm.pp file actually implements the script language 

<p>
 The proof is in the pudding: this shows that the parse-machine is 
 capable of implementing "languages" (or at least simple ones). 

<p>
 It should not normally be necessary to write any assembler code, 
 since the script language is much more readable. However, it 
 is useful for debugging scripts to view the assembly listing as 
 it is loaded into the machine (the -I switch allows this). 

<p>
 The assembler file syntax is similar to other machine assemblers: 
 1 command per line, leading space is insignificant. Labels are 
 permitted and end in a ":" character. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>an example compilation of a basic script </em></td></tr>
<tr><td><pre class="code-line"> 
  # read; "abc" { nop; }
    start:
    read
    testis "abc"
    jumpfalse block.end.21
      nop
    block.end.21:
    jump start 
  </pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>another compilation example</em></td></tr>
<tr><td><pre class="code-line">
   
  # begin { whilenot [:space:]; clear; } read; [:space:] { d; }
  # compilation:

    whilenot [:space:]
    clear
    start:
    read
    testclass [:space:]
    jumpfalse block.end.60
      clear
    block.end.60:
    jump start 
  </pre></td></tr>
</table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMPARISON WITH OTHER COMPILER COMPILERS'></a>
<h3 class="section-heading">COMPARISON WITH OTHER COMPILER COMPILERS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 As far as I am aware, all other compiler compiler systems take 
 some kind of a grammar as input, and produce source code as 
 output. The produced source code acts as a "recogniser" for 
 strings which conform to the given grammar. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='YACC AND LEX COMPARISON'></a>
<h4 class="sub-section-heading">YACC AND LEX COMPARISON <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The tools "yacc" and "lex" and the very numerous clones, rewrites 
 and implementations of those tools are very popular in the implementation 
 of parsers and compilers. This section discusses some of the 
 important differences between the parse-machine and language and 
 those tools. 

<p>
 The pep language and machine is (deliberately) a much more limited system 
 than a "lex/yacc" combination. A lex/yacc-type system often produces "c" 
 language code or some other language code which is then compiled and run to 
 implement the parser/compiler. 

<p>
 The pep system, on the other hand, is a "text stream filter" ; it simply 
 transforms one text format into another. For this reason, it cannot 
 perform the complex programmatic "actions" that tools such as lex/yacc 
 bison or antlr can achieve. 

<p>
 While clearly more limited than a lex-yacc style system, in my opinion 
 the current machine has some advantages: <em class='code-description'>It may be simpler and there should be much easier to understand</em> <em class='code-description'>It does not make use of shift-reduce tables.</em> <em class='code-description'>It should be possible to implement it on much smaller systems.</em> <em class='code-description'>Because it is a text-filter, it should be more accessible for</em> 
 "playing around" or experimentation. Perhaps it lacks the 
 psychological barrier that a lex-yacc system has for a 
 non-specialist programmer. <em class='code-description'>It may be simpler and faster to port the system to new platforms/</em> 
 languages. All that is required is a parse-machine "object" in the 
 target language and a script similar to "translate.c.pss" 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='STATUS'></a>
<h3 class="section-heading">STATUS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 As of july 2020, the interpreter and debugger written in c (i.e <a href='/books/pars/object/pep.c'><em><tt>/books/pars/object/pep.c</tt></em></a> ) 
 works well. However it is not Unicode "aware" . A number of interesting 
 and/or useful examples have been written using the "pep" script language 
 and are in the folder <a href='/books/pars/eg/'><em><tt>/books/pars/eg/</tt></em></a> 

<p>
 The scripts which are designed to compile pep scripts into other languages 
 (java, javascript, python etc) are at varying stages of incompleteness. 
 The <a href='translate.java.pss'><em><tt>translate.java.pss</tt></em></a> and <a href='translate.javascript.pss'><em><tt>translate.javascript.pss</tt></em></a> are currently the most 
 complete, but have not been thoroughly tested. The most comprehensive way to 
 test them is to run them on themselves, with, for example: 
<table><td><pre class="code-line">pep -f translate.java.pss translate.java.pss &gt; Machine.java</pre></td></table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='NAMING OF SYSTEM'></a>
<h3 class="section-heading">NAMING OF SYSTEM <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The executable is called 'pep' standing for "Parse Engine for Patterns" 
 The folder is called <a href='/books/pars/'><em><tt>/books/pars/</tt></em></a> 
 The source file is called <a href='pep.c'><em><tt>pep.c</tt></em></a> for no particularly good reason. 
 Pep scripts are given a ".pss" file extension, and files in the 
 "assembler format have a " .pp" file extension. 

<p>
 The source files are split into .c files where each one corresponds to a 
 particular "object" (data structure) within the machine (eg tapecell, tape, 
 buffer with stack and workspace). Previously I have called this system 
 "chomski" after the linguist Noam Chomsky, but I don't like that name 
 anymore. 

<p>
 'pep' is is not an "evocative" name (unlike, for example, "lisp" ), 
 but it fits with standard short unix tool naming. 

<p>
 Another possible name for the system could be "nom" which is a 
 slight reference to "noam" and also an indo-european (?) root 
 for "name" 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='LIMITATIONS AND BUGS'></a>
<h3 class="section-heading">LIMITATIONS AND BUGS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 - The main interpreter 'pep' (source /books/pars/object/pep.c) is 
 written using plain c byte characters. This seemed a big limitation, but 
 the scripts translate.xxx.pss may be a simple way to accomodate unicode 
 characters without rewriting the code in pep.c 
 - loadScript() does not look for the "asm.pp" in the PPASM folder, 
 which means that all scripts have to be run from the 'pars' folder. 
 This is a bug. 
 - some segmentation faults may remain in pep.c 
 - the whilenot command may not be well implemented in pep.c 
 - the pep tool cannot receive the input-stream from stdin. This is 
 very un-unix-like but is unavoidable because the "pep" executable 
 allows interactive debugging. The solution is to 
 separate pep into 2 tools, one which contains a debugger and the 
 other which dedicate "stdin" to the input. But I dont think it is 
 worthwhile to do this work until pep can deal directly with 
 wide characters (eg wchar) 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='IDEAS'></a>
<h3 class="section-heading">IDEAS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 . a simple language which can generate xcode swift and android 
 java for writing apps. A json-like layout language to replace 
 android xml layouts. 
 . parsing regular expressions shouldn't be that difficult 
 rules: 
 [0-9abcd]n*a+ 
 . A vim command to compile and run a fragment with translate.java.pss 
 . A script to turn a bash history file with comments into 
 a python or perl array of objects (so that we can easily 
 eliminate duplicated commands). And eliminate simple commands 
 immediately with pep 
 . An indent parser like this 
 tokens: space newline word words 
 leading.space = nl space .... 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CANDIDATES FOR NEW COMMANDS OR SYNTAX FOR PEP'></a>
<h3 class="section-heading">CANDIDATES FOR NEW COMMANDS OR SYNTAX FOR PEP <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The commands and new syntax below have not been implemented 
 but might solve a range of problems. 

<p>
 Here are some possible future changes to the machine. <em class='code-description'>abbreviations for character classes eg [:S:] for [:space:]</em> 
 (already in translate.java.pss and some other "transpilers" 
 but not gh.c) 

<p>
 *- replacetape command: would allow unique lists to be 
 constructed (ie replace in workspace text in the current tape cell 
 with a constant string.) <em class='code-description'>a "length" command that sets the accumulator to the length</em> 
 of the current workspace?? <em class='code-description'>some accumulator based tests might be good. eg:</em> 
 :: >n { <commands> } # check if accumulator greater than n 
 :: <n { <commands> } # check if accumulator less than n 
 :: setchars # set accumulator = character counter 
 :: setlines # set accumulator = line counter <em class='code-description'>create a java/javascript/python/ruby/forth version of the machine</em> <em class='code-description'>I may separate the error checking code which is currently</em> 
 in compile.pss into a separate script error.pss . This will 
 allow the same code to be used in other scripts such as 
 translate.java.pss <em class='code-description'>add a new command "untiltape" which has no arguments,</em> 
 which reads the input stream until the workspace ends with 
 the text contained in the current cell of the tape. 
 eg: untiltape; 
 One application of this command would be parsing gnu sed 
 syntax, where the pattern delimiter is what ever character 
 follows the "s" for example: 
<table><td><pre class="code-line">s/a*b/c/</pre></td></table>
 
<table><td><pre class="code-line">s@a*b@c@</pre></td></table>
 
<table><td><pre class="code-line">s#a*b#c#</pre></td></table>
 <em class='code-description'>a new command "replacetape" which replaces text in the workspace</em> 
 with the contents of the current tape cell. eg: 

<p>
 replace all newlines in the workspace with current cell contents 
<table><td><pre class="code-line">replacetape "\n"; </pre></td></table>
 <em class='code-description'>remove "bail" the command. Instead allow the "quit" command to </em> 
 return an exit code. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='HISTORY OF IDEA'></a>
<h3 class="section-heading">HISTORY OF IDEA <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 The file <a href='/books/pars/object/gh.c'><em><tt>/books/pars/object/gh.c</tt></em></a> contains detailed information about the 
 development of this idea. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DESIGN PHILOSOPHY FOR THE MACHINE'></a>
<h3 class="section-heading">DESIGN PHILOSOPHY FOR THE MACHINE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 When designing the parse machine, I wanted to make its capabilities as 
 limited as possible, while still being able to properly parse and translate 
 "most" context-free languages and some context-sensitive languages. Related 
 to this idea, was the aim to make the machine implementable in the smallest 
 possible way. 

<p>
 Also, I deliberately excluded the use of regular expressions, so 
 that the script writer would not be tempted to try to "parse" 
 context-free patterns with them. 

<p>
 The general design of the syntax and command-line usage is inspired 
 by some old unix tools, such as sed, grep and awk 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='REGULAR EXPRESSIONS OR LACK THEREOF'></a>
<h4 class="sub-section-heading">REGULAR EXPRESSIONS OR LACK THEREOF <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 As oft-repeated in this document, the parse machine and language 
 does not support regular expressions. This may seem a strange 
 decision, considering that all existing "lexers" (tools that 
 perform the lexing phase of compilation) support regexes (as 
 far as I know). 

<p>
 I omitted regular expressions from the machine so that the machine 
 could be implemented in a minimal size and also, so that it 
 would run quickly. I am still hopeful that it is possible to 
 implement the machine on embedded architectures, with very 
 limited resources. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='EVOLUTION OF THE MACHINE AND LANGUAGE'></a>
<h3 class="section-heading">EVOLUTION OF THE MACHINE AND LANGUAGE <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 <em class='code-description'>The a+ and a- commands were initially called "plus" and "minus"</em> <em class='code-description'>The "lines" and "chars" (line number and character number) registers</em> 
 and commands are recent, but very important additions, because they 
 allow script error messages to pinpoint the line and character number 
 of the error. <em class='code-description'>The "mark" and "go" commands are also new additions, and were at </em> 
 first added to try to allow "indent" parsing, (also called "offside" 
 parsing, such as is using in the Python language) <em class='code-description'>june 2021</em> 
 - nochars and nolines added to object/pep.c (object/machine.interp.c) although they 
 - have been in pars/tr/translate.java.pss for a while 
 upper, lower, and cap (capital case) 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='IMPORTANT FILES AND FOLDERS'></a>
<h3 class="section-heading">IMPORTANT FILES AND FOLDERS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 This section describes some of the key files and folders within 
 the parse-machine implementation at 
 <a href='http://bumble.sourceforge.net/books/pars/'>http://bumble.sourceforge.net/books/pars/</a> 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='EXAMPLE SCRIPTS'></a>
<h4 class="sub-section-heading">EXAMPLE SCRIPTS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The folder <a href='/books/pars/eg/'><em><tt>/books/pars/eg/</tt></em></a> contains a set of scripts to demonstrate 
 the utility of the parse-script language and machine. Here is a 
 description of some of these scripts. 

<p>
 - mark.html.pss 
 This converts a particular plain text document format into html 
 An example of this format is the current file <a href='pars-book.txt'><em><tt>pars-book.txt</tt></em></a> 
 - exp.tolisp.pss 
 formats simple arithmetic expressions, of the form 
 "a+b*c+(d/e)" into a lisp-style syntax. 
 - history.pss 
 parses a bash history file which may contain comments for 
 a particular command as well as the timestamp (either 
 before or after the timestamp) 
 - json.parse.pss 
 parses and checks json data (but currently only recognises 
 integer numbers). 
 - .... 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='COMPILE DOT PSS'></a>
<h4 class="sub-section-heading">COMPILE DOT PSS <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This is the script compiler and also the compiler compiler. It has replaced 
 the handcoded <a href='/books/pars/asm.pp'><em><tt>/books/pars/asm.pp</tt></em></a> file because it is easier to write and maintain. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='ASM DOT PP'></a>
<h4 class="sub-section-heading">ASM DOT PP <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 This file implements the "pep" scripting language. It is a text file which 
 consists of a series of "instructions" or commands for the pep virtual 
 machine. These instructions include instructions which alter the registers of 
 the virtual machine; tests, which set the flag register of the machine to 
 true if the test returns true, or else false; and conditional and 
 unconditional jumps which change the instruction pointer for the machine if 
 the flag register is true. 

<p>
 <a href='Asm.pp'><em><tt>Asm.pp</tt></em></a> also contains labels (lines ending in ":" ). These labels make 
 it much easier to write code containing jumps (a label can be used 
 instead of an instruction number. 

<p>
 Because of the similarity of this format to many "assembly" languages 
 I refer to this as assembly language for the pep virtual machine. 

<p>
 "asm.pp" is now generated from <a href='/books/pars/compile.pss'><em><tt>/books/pars/compile.pss</tt></em></a> with 
<table><td><pre class="code-line">pep -f compile.pss compile.pss &gt; asm.new.pp; cp asm.new.pp asm.pp;</pre></td></table>
 
 (and then delete the final print statement at the end of asm.pp) 

<p>
 This is a good example of the utility of scripts compiling themselves. 
 In fact, all the "translate.xxx.pss" scripts could be used in this way. 
 For example: 
<table><td><pre class="code-line">pep -f translate.java.pss translate.java.pss &gt; Machine.java</pre></td></table>
 

<p>
 This creates a java source file which, when compiled with "javac" 
 is able to compile scripts into java. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='VIM AND PEP'></a>
<h3 class="section-heading">VIM AND PEP <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 I usually edit with the "vim" text editor (although "sam" or "acme" might 
 be worthwhile alternatives)). Here are some techniques for using vim with 
 the pep tool. The vim mappings and commands below are useful for checking 
 that pep "one-liners" and pep scripts or script fragments contained within a 
 text document, actually compile and run. This may be a way of approximating 
 Knuth's "literate programming" idea. 

<p>
 The multiline snippets are contained in a plain text document within "---" 
 and ",,," tags, which are both on an otherwise empty line. <em class='code-description'>create a vim command to run a script embedded in a text document</em> 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>with input provided as an argument to the vim command</em></td></tr>
<tr><td><pre class="code-line">com! -nargs=1 Ppm ?^ *---?+1,/^ *,,,/-1w !sed 's/^//' &gt; test.pss; /Users/baobab/sf/htdocs/books/pars/pep -f test.pss -i "&lt;args&gt;"</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create a vim command to compile to "assembly" format, an embedded script </em></td></tr>
<tr><td><pre class="code-line">com! Ppcc ?^ *---?+1,/^ *,,,/-1w !sed 's/^//' &gt; test.pss; /Users/baobab/sf/htdocs/books/pars/pep -f compile.pss test.pss </pre></td></tr>
</table>
 

<p>
 (The assembly compilation will be printed to stdout) 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>compile a one line script to assembly format and save as test.asm </em></td></tr>
<tr><td><pre class="code-line">com! -nargs=1 Pplcc .w !sed 's/^ *&gt;&gt;//' &gt; test.pss; /Users/baobab/sf/htdocs/books/pars/pep -f compile.pss test.pss &gt; test.asm</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>run a one line script embedded in a text document, input stream as arg</em></td></tr>
<tr><td><pre class="code-line">com! -nargs=1 Ppl .w !sed 's/^ *&gt;&gt;//' &gt; test.pss; ./pep -f test.pss -i "&lt;args&gt;"</pre></td></tr>
</table>
 

<p>
 Given a one line script such as the following 
<table><td><pre class="code-line">read; "'" { until "'"; print; } clear;</pre></td></table>
 

<p>
 Typing ":Ppl one'two'three" within the "Vim" text editor, with the cursor 
 positioned on the same line (the line beginning with ">>" ), will execute the 
 script with the text as input. 

<p>
 There will be quoting problems if the input contains " characters.
 <em class='code-description'>run a multiline script embedded in a text document</em> 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>with the input given as an argument </em></td></tr>
<tr><td><pre class="code-line">com! -nargs=1 Ppm ?^ *---?+1,/^ *,,,/-1w !sed 's/^//' &gt; test.pss; /home/rowantree/sf/htdocs/books/pars/pep -f test.pss -i "&lt;args&gt;" </pre></td></tr>
</table>
 <em class='code-description'>run a multiline script embedded in a text document</em> 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>with the file pars-book.txt as the input stream</em></td></tr>
<tr><td><pre class="code-line">com! Ppf ?^ *---?+1,/^ *,,,/-1w !sed 's/^//' &gt; test.pss; /Users/baobab/sf/htdocs/books/pars/pep -f test.pss pars-book.txt</pre></td></tr>
</table>
 <em class='code-description'>run a one line script embedded in a text document</em> 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>with the file "pars-book.txt" as the input stream. </em></td></tr>
<tr><td><pre class="code-line">com! Ppll .w !sed 's/^ *&gt;&gt;//' &gt; test.pss; /Users/baobab/sf/htdocs/books/pars/pep -f test.pss pars-book.txt </pre></td></tr>
</table>
 

<p>
 The mapping below can only run the script with a static input "abc" 
 which is not very useful, but at least it tests if the script compiles 
 properly. The compiled script will be saved in "sav.pp" 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create a vim mapping to run a script embedded in a text document</em></td></tr>
<tr><td><pre class="code-line">map ,pp :?^ *---?+1,/^ *,,,/-1w! test.pss \| !pp -f test.pss -i "abc"&lt;cr&gt;</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create a vim mapping to execute the current line as a bash "one-liner"</em></td></tr>
<tr><td><pre class="code-line">map ,pl :.w !sed 's/^ *&gt;&gt;//' \| bash</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>create a vim command to execute the current line as a pep "one-liner"</em></td></tr>
<tr><td><pre class="code-line">command! Ppl .w !sed 's/^ *&gt;&gt;//' | bash</pre></td></tr>
</table>
 

<p>
 The mappings and commands are for putting in the vimrc file. To 
 create them within the editor prepend a ":" to each mapping etc. 
<table><td><pre class="code-line">:command! Ppl .w !sed 's/^ *&gt;&gt;//' | bash</pre></td></table>
 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='CONVERT AND RUN WITH JAVA'></a>
<h4 class="sub-section-heading">CONVERT AND RUN WITH JAVA <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h4>
 

<p>
 The vim commands below work because <a href='translate.java.pss'><em><tt>translate.java.pss</tt></em></a> and 'pep' and 
 pars-book.txt (this document) are all in the same folder. The paths 
 below would have to be ajusted if that were not the case. 

<p>
 The commands below are very useful for testing the soundness of the 
 <a href='translate.java.pss'><em><tt>translate.java.pss</tt></em></a> script. <em class='code-description'>convert to java and run a multiline script embedded in a text document</em> 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>with the input given as an argument </em></td></tr>
<tr><td><pre class="code-line">com! -nargs=1 Ppmj ?^ *---?+1,/^ *,,,/-1w !sed 's/^//' &gt; test.pss; echo "[translating to java and compiling]"; ./pep -f translate.java.pss test.pss &gt; Machine.java; javac Machine.java; echo "[running code]"; echo "&lt;args&gt;" | java Machine</pre></td></tr>
</table>
 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>convert to java a script embedded in a text document, input stream as arg</em></td></tr>
<tr><td><pre class="code-line">com! -nargs=1 Pplj .w !sed 's/^ *&gt;&gt;//' &gt; test.pss; echo "[translating to java and compiling]"; ./pep -f translate.java.pss test.pss &gt; Machine.java; javac Machine.java; echo "[running code]"; echo "&lt;args&gt;" | java Machine</pre></td></tr>
</table>
 

<p>

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='HISTORY'></a>
<h3 class="section-heading">HISTORY <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 See <a href='/books/pars/object/pep.c'><em><tt>/books/pars/object/pep.c</tt></em></a> for detailed development history 

<p>
 13 march 2020 
 made "chars" and "lines" aliases for cc and ll in compile.pss 

<p>
 2 November 2019 

<p>
 Need to write tr/translate.c.pss to create executable code. This 
 can be based on translate.java.pss . Also need to write 
 translate.php.pss so that scripts can easily be run on a web-server. 
 Also, translate.python.pss since python is an important modern 
 language. translate.swift.pss translate.ruby.pss translate.forth.pss 

<p>
 Need to fix mark.html.pss to produce acceptable html output from 
 this booklet file. Also need to write mark.latex.pss , based 
 on mark.html.pss so that I can create a decent pdf booklet. Then 
 need to print the booklet with some images and send to people 
 who may be interested in this. 

<p>
 27 september 2019 

<p>
 translate.javascript.pss is nearing completion... seems to be able 
 to compile many scripts to javascript. 

<p>
 25 august 2019 

<p>
 Great progress has been made. compile.pss has all sorts of 
 nice new syntax like negated text= tests !"abc"{ ... } 
 Almost all tests can be negated. There is now an AND concatentation 
 operator (.). 

<p>
 begin blocks, begintests in ortestsets. compile.pss 
 has replaced asm.handcode.pp for compiling scripts. 

<p>
 2019 

<p>
 For a number of years I have been working on a project to write 
 a virtual machine for pattern parsing. The source code is located 
 at <a href='https://bumble.sf.net/books/pars/object/pep.c'>https://bumble.sf.net/books/pars/object/pep.c</a> 
 This virtual machine can (and is) used to implement a script language 
 for parsing and compiling some context-free languages. (The implementation 
 is in 'asm.pp') 

<p>
 The project is now at a stage where useful scripts can be written in 
 the parse-script language. 

<p>
 The purpose of the virtual machine is to be able to parse and transform 
 patterns which cannot normally be dealt with through "regular expressions" . 
 I.e patterns which are not "regular languages" . Possibly the simplest 
 example of one of these would be palindromes (eg "aba" , "hannah" , "anna" ). 
 The machine also allows a script language to describe patterns and 
 transformations, and this language has similarities to sed and to awk. 

<p>
 In fact the whole idea was inspired by sed and its limitations for 
 context free languages. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='PALINDROMES'></a>
<h3 class="section-heading">PALINDROMES <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 Palindromes are also interesting because they can be parsed with the 
 simplest possible recursive descent parser. 
     <p />
     <table width="60%" border="0">
     <tr><td><em class='code-description'>pseudo code</em></td></tr>
<tr><td><pre class="code-line">
    parsePalindrome (text) {
      n = text.firstCharacter, m = text.lastCharacter
      if n &lt;&gt; m { return false }
      newText = text - first and last characters
      parsePalindrome(newText)
      return true
    }
  </pre></td></tr>
</table>
 

<p>
 But the "pep" machine does not use recursive descent parsing. In fact 
 the gh machine was written because recursive descent parsing seemed 
 aesthetically unpleasing. 

<p>
<!-- - - - - - - - - - - - - - - - - - -->
<a name='DOCUMENT HISTORY'></a>
<h3 class="section-heading">DOCUMENT HISTORY <a href="#toc" title="table of contents" class="toc-link">(&uarr;)</a></h3>
 

<p>
 22 July 2021 

<p>
 13 march 2020 
 revisiting eg/mark.html.pss in order to format this booklet 
 into html, LaTeX and pdf for printing. Also, some revisions of 
 the booklet. 

<p>
 1 november 2019 
 Revising this book file and attempting to make the examples 
 work and more useful. 

<p>
 13 sept 2019 
 some editing. 

<p>
 4 September 2019 
 Adding some ideas about parsing optional elements. 

<p>
 23 August 2019 
 trying to organise this document. 

<p>
 131517 
 a 

<p>

</body></html>

