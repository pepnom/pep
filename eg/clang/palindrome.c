

 /* c code generated by "tr/translate.c.pss" */
 /* note: this c engine cannot handle unicode! */
#include <stdio.h> 
#include <string.h>
#include <time.h> 
#include <ctype.h> 
#include "colours.h"
#include "tapecell.h"
#include "tape.h"
#include "buffer.h"
#include "charclass.h"
#include "command.h"
#include "parameter.h"
#include "instruction.h"
#include "labeltable.h"
#include "program.h"
#include "machine.h"
#include "exitcode.h"
#include "machine.methods.h"
int main() {
  struct Machine machine;
  struct Machine * mm = &machine;
  newMachine(mm, stdin, 100, 10);
  while (isspace(mm->peep) && readc(mm)) {}  /* while */
  mm->buffer.workspace[0] = '\0';      /* clear */
  add(mm, "> Searching for palindromes and sub-palindromes \n"); 
  add(mm, "> in the input. Strings of the same character are not \n"); 
  add(mm, "> considered as palindromes (eg: xxxx or yyy). \n"); 
  add(mm, "> This version does not ignore whitespace characters.\n"); 
  add(mm, " Palidrome: text that is the same backwards.  \n"); 
  add(mm, "  παλίν (palin) = back \n"); 
  add(mm, "  δρομος (dromos) = running \n"); 
  printf("%s", mm->buffer.workspace);  /* print */
  mm->buffer.workspace[0] = '\0';      /* clear */
  script: 
  while (!mm->peep != EOF) {
    if (mm->peep == EOF) { break; } else { readChar(mm); }  /* read */
    // make the character count relative to the line number.
    if (workspaceInClassType(mm, "[\n]")) {
      mm->charsRead = 0; /* nochars */
    }
    put(mm);
    mm->buffer.workspace[0] = '\0';      /* clear */
    add(mm, "char*"); 
    push(mm);
    //-----------
    // here lexing ends and parsing begins
    parse: 
    // To view parse-stack token reduction uncomment the lines below
    // lines; add ":"; chars; add " "; print; clear; 
    // unstack; add "\n"; print; clip; stack; 
    //------------
    // 2 tokens
    pop(mm);
    pop(mm);
    if (0 == strcmp(mm->buffer.workspace, "pal*pal*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      increment(mm);  /* ++ */ 
      if (strcmp(mm->buffer.workspace, 
        mm->tape.cells[mm->tape.currentCell].text) == 0) {
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "[palindrome found!] ends at line "); 
        lines(mm);
        add(mm, ", char "); 
        chars(mm);
        add(mm, ": "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "pal*"); 
        push(mm);
        goto parse;
      }
      mm->buffer.workspace[0] = '\0';      /* clear */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      add(mm, "pal*pal*"); 
    }
    if (0 == strcmp(mm->buffer.workspace, "char*char*")) {
      // create the list* token
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      increment(mm);  /* ++ */ 
      if (strcmp(mm->buffer.workspace, 
        mm->tape.cells[mm->tape.currentCell].text) == 0) {
        // save a copy of the single char on the tape
        // where it wont get overwritten
        increment(mm);  /* ++ */ 
        put(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "list*"); 
        push(mm);
        goto parse;
      }
      mm->buffer.workspace[0] = '\0';      /* clear */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      add(mm, "char*char*"); 
    }
    if (0 == strcmp(mm->buffer.workspace, "list*char*")) {
      // the next tape cell has a copy of the single char
      // of the list
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      get(mm);
      increment(mm);  /* ++ */ 
      if (strcmp(mm->buffer.workspace, 
        mm->tape.cells[mm->tape.currentCell].text) == 0) {
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        get(mm);
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "list*"); 
        push(mm);
        goto parse;
      }
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "list*char*"); 
    }
    //------------
    // 3 tokens
    pop(mm);
    if (0 == strcmp(mm->buffer.workspace, "list*list*list*") || 0 == strcmp(mm->buffer.workspace, "char*list*char*") || 0 == strcmp(mm->buffer.workspace, "list*char*list*") || 0 == strcmp(mm->buffer.workspace, "list*pal*list*") || 0 == strcmp(mm->buffer.workspace, "pal*list*pal*") || 0 == strcmp(mm->buffer.workspace, "char*char*char*") || 0 == strcmp(mm->buffer.workspace, "char*pal*char*") || 0 == strcmp(mm->buffer.workspace, "pal*pal*pal*") || 0 == strcmp(mm->buffer.workspace, "pal*char*pal*")) {
      push(mm);
      push(mm);
      push(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (strcmp(mm->buffer.workspace, 
        mm->tape.cells[mm->tape.currentCell].text) == 0) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        get(mm);
        increment(mm);  /* ++ */ 
        get(mm);
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "[palindrome found!] ends at line "); 
        lines(mm);
        add(mm, ", char "); 
        chars(mm);
        add(mm, ": "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        mm->buffer.workspace[0] = '\0';      /* clear */
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        pop(mm);
        pop(mm);
        pop(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "pal*"); 
        push(mm);
        goto parse;
      }
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      pop(mm);
      pop(mm);
      pop(mm);
    }
    push(mm);
    push(mm);
    push(mm);
    if (mm->peep == EOF) {
      pop(mm);
      pop(mm);
      if (0 == strcmp(mm->buffer.workspace, "pal*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "[whole string is a complete palindrome!]\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      if (0 == strcmp(mm->buffer.workspace, "list*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "[a list]\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      push(mm);
      push(mm);
      add(mm, "Whole string isn't a palindrome.\n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      mm->buffer.workspace[0] = '\0';      /* clear */
      // add "The parse-stack tokens are:\n  "; print; clear;
      // unstack; 
      // replace "pal*" "palindrome|";
      // replace "*" "|"; clip; add "\n"; print; clear;
    }
  }
}
