

 /* c code generated by "tr/translate.c.pss" */
 /* note: this c engine cannot handle unicode! */
#include <stdio.h> 
#include <string.h>
#include <time.h> 
#include <ctype.h> 
#include "colours.h"
#include "tapecell.h"
#include "tape.h"
#include "buffer.h"
#include "charclass.h"
#include "command.h"
#include "parameter.h"
#include "instruction.h"
#include "labeltable.h"
#include "program.h"
#include "machine.h"
#include "exitcode.h"
#include "machine.methods.h"
int main() {
  struct Machine machine;
  struct Machine * mm = &machine;
  newMachine(mm, stdin, 100, 10);
  // the empty recordset trick to simplify the grammar rules
  add(mm, "recordset*"); 
  push(mm);
  script: 
  while (!mm->peep != EOF) {
    if (mm->peep == EOF) { break; } else { readChar(mm); }  /* read */
    if (workspaceInClassType(mm, "[\n]")) {
      // just to debug
      // lines; print;
      mm->buffer.workspace[0] = '\0';      /* clear */
    }
    while (!(strchr("\n", mm->peep) != NULL) && readc(mm)) {}  /* while */
    // ignore blank lines
    if (0 == strcmp(mm->buffer.workspace, "") || workspaceInClassType(mm, "[:space:]")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      goto parse;
    }
    put(mm);
    if (strncmp(mm->buffer.workspace, "#", strlen("#")) == 0 && 0 != strcmp(mm->buffer.workspace, "#")) {
      if (workspaceInClassType(mm, "[#0123456789]")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "timestamp*"); 
        push(mm);
        goto parse;
      }
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "comment*"); 
      push(mm);
      goto parse;
    }
    // tag the command as trivial if it is 
    // for later removal. If there is a comment above it we may keep it anyway
    // tag as trivial all commands less than 5 characters
    /* clip */ 
    if (*mm->buffer.workspace != 0)  
      { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
    /* clip */ 
    if (*mm->buffer.workspace != 0)  
      { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
    /* clip */ 
    if (*mm->buffer.workspace != 0)  
      { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
    /* clip */ 
    if (*mm->buffer.workspace != 0)  
      { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
    if (0 == strcmp(mm->buffer.workspace, "")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "trivial*"); 
      push(mm);
      goto parse;
    }
    mm->buffer.workspace[0] = '\0';      /* clear */
    get(mm);
    if (strncmp(mm->buffer.workspace, "df ", strlen("df ")) == 0 || 0 == strcmp(mm->buffer.workspace, "df") || strncmp(mm->buffer.workspace, "du ", strlen("du ")) == 0 || strncmp(mm->buffer.workspace, "mv ", strlen("mv ")) == 0 || strncmp(mm->buffer.workspace, "cp ", strlen("cp ")) == 0 || strncmp(mm->buffer.workspace, "less ", strlen("less ")) == 0 || strncmp(mm->buffer.workspace, "vim ", strlen("vim ")) == 0 || strncmp(mm->buffer.workspace, "rm ", strlen("rm ")) == 0 || strncmp(mm->buffer.workspace, "mkdir ", strlen("mkdir ")) == 0 || strncmp(mm->buffer.workspace, "find ", strlen("find ")) == 0 || strncmp(mm->buffer.workspace, "locate ", strlen("locate ")) == 0 || strncmp(mm->buffer.workspace, "cd ", strlen("cd ")) == 0 || 0 == strcmp(mm->buffer.workspace, "cd") || strncmp(mm->buffer.workspace, "ls ", strlen("ls ")) == 0 || 0 == strcmp(mm->buffer.workspace, "ls") || 0 == strcmp(mm->buffer.workspace, "pwd") || 0 == strcmp(mm->buffer.workspace, "hist") || 0 == strcmp(mm->buffer.workspace, "books") || 0 == strcmp(mm->buffer.workspace, "bk") || 0 == strcmp(mm->buffer.workspace, "ho") || 0 == strcmp(mm->buffer.workspace, "updatedb") || 0 == strcmp(mm->buffer.workspace, "bashrc") || 0 == strcmp(mm->buffer.workspace, "vimrc") || 0 == strcmp(mm->buffer.workspace, "os") || 0 == strcmp(mm->buffer.workspace, "cos") || 0 == strcmp(mm->buffer.workspace, "ccos") || 0 == strcmp(mm->buffer.workspace, "make")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "trivial*"); 
      push(mm);
      goto parse;
    }
    mm->buffer.workspace[0] = '\0';      /* clear */
    add(mm, "command*"); 
    push(mm);
    parse: 
    // for debugging
    // add "line "; lines; add " char "; chars; add ": "; print; clear; 
    //add "line "; lines; add ": "; print; clear; 
    //unstack; print; stack; add "\n"; print; clear;
    // ----------------
    // 2 tokens
    pop(mm);
    pop(mm);
    // ignore duplicated timestamps. 
    if (0 == strcmp(mm->buffer.workspace, "timestamp*timestamp*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "timestamp*"); 
      push(mm);
      goto parse;
    }
    // handle multiline comments
    if (0 == strcmp(mm->buffer.workspace, "comment*comment*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "comment*"); 
      push(mm);
      goto parse;
    }
    // dont need because an initial recordset always exists
    //"record*record*","recordset*record*" {
    if (0 == strcmp(mm->buffer.workspace, "recordset*record*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // debug code
      // a+; count; add " record!\n"; print; clear;
      add(mm, "recordset*"); 
      push(mm);
      goto parse;
    }
    // this will be compiled differently from r*r*
    if (0 == strcmp(mm->buffer.workspace, "recordset*command*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "recordset*"); 
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "recordset*trivial*")) {
      mm->accumulator++; /* a+ */
      // count filtered commands
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "recordset*"); 
      push(mm);
      goto parse;
    }
    if (mm->peep == EOF) {
      // clean up trailing comments etc
      if (0 == strcmp(mm->buffer.workspace, "recordset*timestamp*") || 0 == strcmp(mm->buffer.workspace, "recordset*comment*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "recordset*record*"); 
        push(mm);
        push(mm);
        goto parse;
      }
    }
    // 3 tokens
    pop(mm);
    // remove trivial commands without comments
    if (0 == strcmp(mm->buffer.workspace, "recordset*timestamp*trivial*")) {
      mm->accumulator++; /* a+ */
      // count filtered commands
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "recordset*"); 
      push(mm);
      goto parse;
    }
    // ignore duplicated timestamps. 
    if (0 == strcmp(mm->buffer.workspace, "timestamp*comment*timestamp*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "comment*timestamp*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    // amalgamate comments before and after the timestamp
    if (0 == strcmp(mm->buffer.workspace, "comment*timestamp*comment*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      add(mm, "\n"); 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "comment*timestamp*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "comment*timestamp*command*") || 0 == strcmp(mm->buffer.workspace, "comment*timestamp*trivial*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "record*"); 
      push(mm);
      goto parse;
    }
    // dont remove trivial commands with comments
    if (0 == strcmp(mm->buffer.workspace, "timestamp*comment*command*") || 0 == strcmp(mm->buffer.workspace, "timestamp*comment*trivial*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      // switch the order to make comment precede timestamp
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, "\n"); 
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "record*"); 
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "recordset*timestamp*command*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "recordset*record*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    // resolve commands and trivial command with comments
    if (0 == strcmp(mm->buffer.workspace, "recordset*comment*command*") || 0 == strcmp(mm->buffer.workspace, "recordset*comment*trivial*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, "\n"); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "recordset*record*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    push(mm);
    push(mm);
    push(mm);
    if (mm->peep == EOF) {
      pop(mm);
      pop(mm);
      if (0 != strcmp(mm->buffer.workspace, "recordset*")) {
        push(mm);
        push(mm);
        add(mm, "# History file did not parse well!\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "# Parse stack was: "); 
        printf("%s", mm->buffer.workspace);  /* print */
        mm->buffer.workspace[0] = '\0';      /* clear */
        while (pop(mm)) {}          /* unstack */
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      if (0 == strcmp(mm->buffer.workspace, "recordset*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        get(mm);
        add(mm, "\n# History file parsed and filtered by pars/eg/bash.history.pss \n"); 
        add(mm, "# "); 
        count(mm);
        add(mm, " trivial commands (without preceding comments) were removed.\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
      }
    }
  }
}
