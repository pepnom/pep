

   /* c code generated by "tr/translate.c.pss" */
   /* note: the translation script has not been debugged
            expect unusual results! */
#include <stdio.h> 
#include <string.h>
#include <time.h> 
#include <ctype.h> 
#include "colours.h"
#include "tapecell.h"
#include "tape.h"
#include "buffer.h"
#include "charclass.h"
#include "command.h"
#include "parameter.h"
#include "instruction.h"
#include "labeltable.h"
#include "program.h"
#include "machine.h"
#include "exitcode.h"
#include "machine.methods.h"
int main() {
  struct Machine machine;
  struct Machine * mm = &machine;
  newMachine(mm, stdin, 100, 10);

  script: 
  while (!mm->peep != EOF) {
    if (mm->peep == EOF) { break; } else { readChar(mm); }  /* read */
    // the code in this block builds 2 buffers. One with 
    // the original word, and the other with the word in reverse
    // Later, the code checks whether the 2 buffers contain the 
    // same text (a palindrome).
    if (!workspaceInClassType(mm, "[:space:]")) {
      // save the current character
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      get(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // restore the current character
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      increment(mm);  /* ++ */ 
      swap(mm);
      get(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
    }
    // check for palindromes when a space or eof found
    if (workspaceInClassType(mm, "[:space:]") || mm->peep == EOF) {
      // clear white space
      if (workspaceInClassType(mm, "[:space:]")) {
        while (isspace(mm->peep) && readc(mm)) {}  /* while */
        mm->buffer.workspace[0] = '\0';      /* clear */
      }
      // check if the previous word was a palindrome
      get(mm);
      increment(mm);  /* ++ */ 
      // if the word is the same as its reverse and not empty
      // then its a palindrome. Dont print palindromes that are
      // only punctuation or digits or only 3 chars
      if (strcmp(mm->buffer.workspace, 
        mm->tape.cells[mm->tape.currentCell].text) == 0 && 0 != strcmp(mm->buffer.workspace, "") && !workspaceInClassType(mm, "[:punct:]") && !workspaceInClassType(mm, "[:digit:]")) {
        /* clip */ 
        if (*mm->buffer.workspace != 0)  
          { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
        /* clip */ 
        if (*mm->buffer.workspace != 0)  
          { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
        /* clip */ 
        if (*mm->buffer.workspace != 0)  
          { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
        if (0 != strcmp(mm->buffer.workspace, "")) {
          mm->buffer.workspace[0] = '\0';      /* clear */
          get(mm);
          add(mm, "\n"); 
          printf("%s", mm->buffer.workspace);  /* print */
        }
      }
      // clear the workspace and 1st two cells
      mm->buffer.workspace[0] = '\0';      /* clear */
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
    }
  }
}
