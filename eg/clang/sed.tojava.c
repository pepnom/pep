

 /* c code generated by "tr/translate.c.pss" */
 /* note: this c engine cannot handle unicode! */
#include <stdio.h> 
#include <string.h>
#include <time.h> 
#include <ctype.h> 
#include "colours.h"
#include "tapecell.h"
#include "tape.h"
#include "buffer.h"
#include "charclass.h"
#include "command.h"
#include "parameter.h"
#include "instruction.h"
#include "labeltable.h"
#include "program.h"
#include "machine.h"
#include "exitcode.h"
#include "machine.methods.h"
int main() {
  struct Machine machine;
  struct Machine * mm = &machine;
  newMachine(mm, stdin, 100, 10);

  script: 
  while (!mm->peep != EOF) {
    if (mm->peep == EOF) { break; } else { readChar(mm); }  /* read */
    // make char number relative to line, for error messages
    if (workspaceInClassType(mm, "[\n]")) {
      mm->charsRead = 0; /* nochars */
    }
    // newlines can separate commands in (gnu) sed so we will
    // just add a dummy ';' here. Also, no trailing ; is required
    if (workspaceInClassType(mm, "[\n]")) {
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, ";*"); 
      push(mm);
      goto parse;
    }
    // ignore extraneous white-space?
    if (workspaceInClassType(mm, "[:space:]")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      if (mm->peep == EOF) {
        goto parse;
      }
      continue;
    }
    // comments, convert to java comments
    if (0 == strcmp(mm->buffer.workspace, "#")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "/* "); 
      until(mm, "\n");
      if (endsWith(mm->buffer.workspace, "\n")) {
        /* clip */ 
        if (*mm->buffer.workspace != 0)  
          { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      }
      add(mm, " */\n"); 
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // uncomment line below to include comments in output
      // add "comment*"; push; .reparse
    }
    // literal tokens '{' and '}' are used to group commands in
    // sed, ';' is used to separate commands and ',' to separate line
    // ranges. ! is the postfix negation operator for ranges
    if (0 == strcmp(mm->buffer.workspace, ",") || 0 == strcmp(mm->buffer.workspace, "{") || 0 == strcmp(mm->buffer.workspace, "}") || 0 == strcmp(mm->buffer.workspace, ";") || 0 == strcmp(mm->buffer.workspace, "!")) {
      put(mm);
      add(mm, "*"); 
      push(mm);
      goto parse;
    }
    // various actions: print, delete, swap
    if (0 == strcmp(mm->buffer.workspace, "=") || 0 == strcmp(mm->buffer.workspace, "p") || 0 == strcmp(mm->buffer.workspace, "P") || 0 == strcmp(mm->buffer.workspace, "l") || 0 == strcmp(mm->buffer.workspace, "d") || 0 == strcmp(mm->buffer.workspace, "D") || 0 == strcmp(mm->buffer.workspace, "F") || 0 == strcmp(mm->buffer.workspace, "g") || 0 == strcmp(mm->buffer.workspace, "G") || 0 == strcmp(mm->buffer.workspace, "h") || 0 == strcmp(mm->buffer.workspace, "H") || 0 == strcmp(mm->buffer.workspace, "n") || 0 == strcmp(mm->buffer.workspace, "N") || 0 == strcmp(mm->buffer.workspace, "x") || 0 == strcmp(mm->buffer.workspace, "z")) {
      if (0 == strcmp(mm->buffer.workspace, "=")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        // print line-number + newline
        add(mm, "System.out.println(mm.linesRead);  /* '=' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "d")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        // 'd' delete pattern-space, restart 
        // the if true trick is necessary to avoid 'unreachable statement'
        // java compile errors (when multiple 'd' commands are given)
        add(mm, "if (true) { mm.patternSpace.setLength(0); continue; } /* 'd' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "D")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        // add "/* 'D' delete pattern-space to 1st \\n, restart */";
        add(mm, "if (mm.patternSpace.indexOf(\"\\n\") > -1) {\n"); 
        add(mm, "  mm.patternSpace.delete(0, mm.patternSpace.indexOf(\"\\n\"));\n"); 
        add(mm, "  mm.readNext = false; if (true) continue; \n"); 
        add(mm, "} else { mm.patternSpace.setLength(0); continue; } /* 'd' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "F")) {
        // F: print input filename + newline
        // maybe unsupported in java
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "System.out.println(\"<unknown-file>\");  /* F */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "g")) {
        // g: replace patt-space with hold-space
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "mm.patternSpace.setLength(0); \n"); 
        add(mm, "mm.patternSpace.append(mm.holdSpace);  /* 'g' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "G")) {
        // G; append hold-space to patt-space + \\n"
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "mm.patternSpace.append(\"\\n\" + mm.holdSpace);  /* 'G' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "h")) {
        // h:  replace hold-space with patt-space
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "mm.holdSpace.setLength(0); \n"); 
        add(mm, "mm.holdSpace.append(mm.patternSpace);  /* 'h' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "H")) {
        // H:  append patt-space to hold-space + newline
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "mm.holdSpace.append(\"\\n\" + mm.patternSpace);  /* 'H' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "l")) {
        // print pattern-space unambiguously, synonym for p ?
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "System.out.println(mm.patternSpace); /* 'l' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "n")) {
        // n: print patt-space, get next line into patt-space
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "if (mm.autoPrint) { System.out.println(mm.patternSpace); }\n"); 
        add(mm, "mm.patternSpace.setLength(0);\n"); 
        add(mm, "mm.readLine();   /* 'n' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "N")) {
        // N: append next line to patt-space + newline
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "mm.patternSpace.append('\\n'); "); 
        add(mm, "mm.readLine();  /* 'N' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "p")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "System.out.println(mm.patternSpace); /* 'p' */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "P")) {
        // P: print pattern-space up to 1st newline"
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "if (mm.patternSpace.indexOf(\"\\n\") > -1) {\n"); 
        add(mm, "  System.out.println(\n"); 
        add(mm, "    mm.patternSpace.substring(0, mm.patternSpace.indexOf(\"\\n\")));\n"); 
        add(mm, "} else { System.out.println(mm.patternSpace); }"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "x")) {
        // x:  # swap pattern-space with hold-space
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "mm.swap();  /* x */"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "z")) {
        // z:  delete pattern-space, NO restart
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "mm.patternSpace.setLenth(0); /* z */"); 
      }
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "action*"); 
      push(mm);
      goto parse;
    }
    // line numbers are also selectors
    if (workspaceInClassType(mm, "[0-9]")) {
      while (((mm->peep >= '0') && ('9' >= mm->peep)) && readc(mm)) {} /* while */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "number*"); 
      push(mm);
      goto parse;
    }
    // $ is the last line of the file
    if (0 == strcmp(mm->buffer.workspace, "$")) {
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "number*"); 
      push(mm);
      goto parse;
    }
    // patterns - only execute commands if lines match 
    if (0 == strcmp(mm->buffer.workspace, "/")) {
      // save line/char number for error message 
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "near line/char "); 
      lines(mm);
      add(mm, ":"); 
      chars(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      until(mm, "/");
      if (!endsWith(mm->buffer.workspace, "/")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Missing '/' to terminate "); 
        get(mm);
        add(mm, "?\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      // java .matches method matches whole string not substring
      // so we need to add .* at beginning and end, but not if regex
      // begins with ^ or ends with $. complicated hey
      if (!endsWith(mm->buffer.workspace, "$")) {
        add(mm, ".*$"); 
      }
      if (strncmp(mm->buffer.workspace, "^", strlen("^")) != 0) {
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "^.*"); 
        get(mm);
      }
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // add any delimiter for pattern here, or none
      add(mm, "\""); 
      get(mm);
      add(mm, "\""); 
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "pattern*"); 
      push(mm);
      goto parse;
    }
    // read transliteration commands
    if (0 == strcmp(mm->buffer.workspace, "y")) {
      // save line/char number for error message 
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "near line "); 
      lines(mm);
      add(mm, ", char "); 
      chars(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // allow spaces between 'y' and '/' although gnu set doesn't
      until(mm, "/");
      if (!endsWith(mm->buffer.workspace, "/") || !workspaceInClassType(mm, "[ /]")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Missing '/' after 'y' transliterate command\n"); 
        add(mm, "Or trailing characters "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      // save line/char number for error message 
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "near line "); 
      lines(mm);
      add(mm, ", char "); 
      chars(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      until(mm, "/");
      if (!endsWith(mm->buffer.workspace, "/")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Missing 2nd '/' after 'y' transliterate command "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      if (0 == strcmp(mm->buffer.workspace, "/")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Sed syntax error? \n"); 
        add(mm, "  Empty regex after 'y' transliterate command "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      // replace pattern found
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "y/"); 
      get(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // save line/char number for error message 
      add(mm, "near line "); 
      lines(mm);
      add(mm, ", char "); 
      chars(mm);
      increment(mm);  /* ++ */ 
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      mm->buffer.workspace[0] = '\0';      /* clear */
      until(mm, "/");
      if (!endsWith(mm->buffer.workspace, "/")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Missing 3rd '/' after 'y' transliterate command "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      swap(mm);
      add(mm, "/"); 
      get(mm);
      add(mm, "/"); 
      // y/// does not have modifiers (unlike s///)
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "action*"); 
      push(mm);
      goto parse;
    }
    // various commands that have an option word parameter 
    // e has two variants
    //  "e" { replace "e" "e;  # exec patt-space command and replace"; }
    if (0 == strcmp(mm->buffer.workspace, "b") || 0 == strcmp(mm->buffer.workspace, "e") || 0 == strcmp(mm->buffer.workspace, "q") || 0 == strcmp(mm->buffer.workspace, "Q") || 0 == strcmp(mm->buffer.workspace, "t") || 0 == strcmp(mm->buffer.workspace, "T")) {
      // ignore intervening space if any
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      while ((strchr(" ", mm->peep) != NULL) && readc(mm)) {}  /* while */
      mm->buffer.workspace[0] = '\0';      /* clear */
      // A bit more permissive that gnu-sed which doesn't allow
      // read to end in ';'.
      while (!(strchr(" ;}", mm->peep) != NULL) && readc(mm)) {}  /* while */
      // word parameters are optional to these commands
      // just add a space to separate command from parameter
      if (0 != strcmp(mm->buffer.workspace, "")) {
        swap(mm);
        add(mm, " "); 
        swap(mm);
      }
      swap(mm);
      get(mm);
      // hard to implement because java has no goto ?
      if (strncmp(mm->buffer.workspace, "b", strlen("b")) == 0) {
        add(mm, ";  # branch to <label> or start"); 
      }
      if (strncmp(mm->buffer.workspace, "e ", strlen("e ")) == 0) {
        add(mm, ";  # exec <cmd> and insert into output"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "e")) {
        add(mm, ";  # exec patt-space command into patt-space"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "q")) {
        // q; print + quit
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "System.out.println(mm.patternSpace);\n"); 
        add(mm, "System.exit(0);"); 
      }
      if (strncmp(mm->buffer.workspace, "q ", strlen("q ")) == 0) {
        // q; print + quit with exit code
        clop(mm);
        clop(mm);
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "System.out.println(mm.patternSpace);\n"); 
        add(mm, "System.exit("); 
        get(mm);
        add(mm, ");"); 
      }
      if (0 == strcmp(mm->buffer.workspace, "Q")) {
        // Q; quit, dont print
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "System.exit(0);"); 
      }
      if (strncmp(mm->buffer.workspace, "Q ", strlen("Q ")) == 0) {
        // Q; quit with exit code, dont print
        clop(mm);
        clop(mm);
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "System.exit("); 
        get(mm);
        add(mm, ");"); 
      }
      if (strncmp(mm->buffer.workspace, "t", strlen("t")) == 0) {
        add(mm, ";  # branch to <label> if substitution made or start"); 
      }
      if (strncmp(mm->buffer.workspace, "T", strlen("T")) == 0) {
        add(mm, ";  # branch to <label> if NO substituion or start"); 
      }
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "action*"); 
      push(mm);
      goto parse;
    }
    // read 'read <filename>' and write commands
    if (0 == strcmp(mm->buffer.workspace, ":") || 0 == strcmp(mm->buffer.workspace, "r") || 0 == strcmp(mm->buffer.workspace, "R") || 0 == strcmp(mm->buffer.workspace, "w") || 0 == strcmp(mm->buffer.workspace, "W")) {
      // ignore intervening space if any
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      while ((strchr(" ", mm->peep) != NULL) && readc(mm)) {}  /* while */
      mm->buffer.workspace[0] = '\0';      /* clear */
      // A bit more permissive that gnu-sed which doesn't allow
      // read to end in ';'.
      while (!(strchr(" ;}", mm->peep) != NULL) && readc(mm)) {}  /* while */
      if (0 == strcmp(mm->buffer.workspace, "")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Sed syntax error? (at line:char "); 
        lines(mm);
        add(mm, ":"); 
        chars(mm);
        add(mm, ")\n"); 
        add(mm, "  no filename for read 'r' command. \n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      swap(mm);
      add(mm, " "); 
      get(mm);
      if (strncmp(mm->buffer.workspace, ": ", strlen(": ")) == 0) {
        add(mm, ";  # branch to <label>"); 
      }
      if (strncmp(mm->buffer.workspace, "r ", strlen("r ")) == 0) {
        add(mm, ";  # read file into patt-space"); 
      }
      if (strncmp(mm->buffer.workspace, "R ", strlen("R ")) == 0) {
        add(mm, ";  # insert file into output before next line"); 
      }
      if (strncmp(mm->buffer.workspace, "w ", strlen("w ")) == 0) {
        add(mm, ";  # write patt-space to file"); 
      }
      // mm.writeToFile(name)
      if (strncmp(mm->buffer.workspace, "W ", strlen("W ")) == 0) {
        add(mm, ";  # write 1st line of patt-space to file"); 
      }
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "action*"); 
      push(mm);
      goto parse;
    }
    // read substitution commands
    if (0 == strcmp(mm->buffer.workspace, "s")) {
      // save line/char number for error message 
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "near line/char "); 
      lines(mm);
      add(mm, ":"); 
      chars(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // allow spaces between 's' and '/' ??? 
      until(mm, "/");
      if (!endsWith(mm->buffer.workspace, "/") || !workspaceInClassType(mm, "[ /]")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Missing '/' after 's' substitute command\n"); 
        add(mm, "Or trailing characters "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      // save line/char number for error message 
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "near line "); 
      lines(mm);
      add(mm, ", char "); 
      chars(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      until(mm, "/");
      if (!endsWith(mm->buffer.workspace, "/")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Sed syntax error? \n"); 
        add(mm, "  Missing 2nd '/' after 's' substitute command "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      if (0 == strcmp(mm->buffer.workspace, "/")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Sed syntax error? \n"); 
        add(mm, "  Empty regex after 's' substitute command "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      // replace pattern found
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "mm.substitute(\""); 
      get(mm);
      add(mm, "\", \""); 
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // save line/char number for error message 
      add(mm, "near line/char "); 
      lines(mm);
      add(mm, ":"); 
      chars(mm);
      increment(mm);  /* ++ */ 
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      mm->buffer.workspace[0] = '\0';      /* clear */
      until(mm, "/");
      if (!endsWith(mm->buffer.workspace, "/")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "Missing 3rd '/' after 's' substitute command "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      swap(mm);
      get(mm);
      add(mm, "\", \""); 
      // also need to read modifiers, eg g/i/p/[0-9] etc
      // need better logic to process these modifiers.
      while ((strchr("gip", mm->peep) != NULL) && readc(mm)) {}  /* while */
      add(mm, "\");   /* s */ "); 
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "action*"); 
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "a") || 0 == strcmp(mm->buffer.workspace, "c") || 0 == strcmp(mm->buffer.workspace, "i")) {
      // label, append, branch, change, insert, quit, write, test, write, read
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "Unimplemented command (near line:char "); 
      lines(mm);
      add(mm, ":"); 
      chars(mm);
      add(mm, ")\n"); 
      add(mm, "  The script does not recognise '"); 
      get(mm);
      add(mm, "' yet.\n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      exit(0);
    }
    if (0 != strcmp(mm->buffer.workspace, "")) {
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "Sed syntax error? (near line:char "); 
      lines(mm);
      add(mm, ":"); 
      chars(mm);
      add(mm, ")\n"); 
      add(mm, "  unrecognised command '"); 
      get(mm);
      add(mm, "'\n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      exit(0);
    }
    // where token reduction begins
    parse: 
    // To visualise token reduction uncomment this below:
    add(mm, "// "); 
    lines(mm);
    add(mm, ":"); 
    chars(mm);
    add(mm, " "); 
    printf("%s", mm->buffer.workspace);  /* print */
    mm->buffer.workspace[0] = '\0';      /* clear */
    add(mm, "\n"); 
    while (pop(mm)) {}          /* unstack */
    printf("%s", mm->buffer.workspace);  /* print */
    /* clip */ 
    if (*mm->buffer.workspace != 0)  
      { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
    while (push(mm)) {}          /* stack */
    // commands do not have to be terminated with ';' at the end of a sed script.
    if (mm->peep == EOF) {
      pop(mm);
      if (0 == strcmp(mm->buffer.workspace, "action*")) {
        add(mm, ";*"); 
        push(mm);
        push(mm);
        goto parse;
      }
      push(mm);
    }
    pop(mm);
    pop(mm);
    pop(mm);
    pop(mm);
    pop(mm);
    pop(mm);
    // ----------------
    // 6 token reductions
    // these must be done first, to take precedence over 
    // eg pattern/{/commandset/}
    if (0 == strcmp(mm->buffer.workspace, "pattern*,*pattern*{*commandset*}*") || 0 == strcmp(mm->buffer.workspace, "pattern*,*number*{*commandset*}*") || 0 == strcmp(mm->buffer.workspace, "number*,*number*{*commandset*}*") || 0 == strcmp(mm->buffer.workspace, "number*,*pattern*{*commandset*}*")) {
      // also, need to indent the command set.
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      swap(mm);
      replace(mm, "\n", "\n  ");        /* replace */
      // use a brace token as temporary storage, so that we can
      // indent the 1st line of the commandset
      // should add 2 spaces but 1st line is getting an extra one.
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, " "); 
      get(mm);
      increment(mm);  /* ++ */ 
      swap(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      // using an array of boolean states to remember if a 
      // pattern has been 'seen'
      if (strncmp(mm->buffer.workspace, "pattern*,*pattern*", strlen("pattern*,*pattern*")) == 0) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "if (mm.line.toString().matches("); 
        get(mm);
        add(mm, ") && (mm.states["); 
        count(mm);
        add(mm, "] == false))\n  {"); 
        add(mm, " mm.states["); 
        count(mm);
        add(mm, "] = true; }\n"); 
        add(mm, "if (mm.states["); 
        count(mm);
        add(mm, "] == true) {\n"); 
        // get commandset at tape+4
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, "\n}\n"); 
        // comes after so last line is matched 
        add(mm, "if (mm.line.toString().matches("); 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, ") && (mm.states["); 
        count(mm);
        add(mm, "] == true))\n  {"); 
        add(mm, " mm.states["); 
        count(mm);
        add(mm, "] = false; }\n"); 
        put(mm);
        mm->accumulator++; /* a+ */
      }
      if (strncmp(mm->buffer.workspace, "pattern*,*number*", strlen("pattern*,*number*")) == 0) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "if (mm.line.toString()..matches("); 
        get(mm);
        add(mm, ") && (mm.states["); 
        count(mm);
        add(mm, "] == false))\n"); 
        add(mm, "  { mm.states["); 
        count(mm);
        add(mm, "] = true; }\n"); 
        add(mm, "if (mm.states["); 
        count(mm);
        add(mm, "] == true) {\n "); 
        // get commandset at tape+4
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, "\n}\n"); 
        // put here to match last line in range 
        add(mm, "if ((mm.linesRead > "); 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, ") && (mm.states["); 
        count(mm);
        add(mm, "] == true))\n"); 
        add(mm, "  { mm.states["); 
        count(mm);
        add(mm, "] = false; }\n"); 
        put(mm);
        mm->accumulator++; /* a+ */
      }
      if (strncmp(mm->buffer.workspace, "number*,*pattern*", strlen("number*,*pattern*")) == 0) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        // but this logic doesn't include last line
        add(mm, "if ((mm.linesRead == "); 
        get(mm);
        add(mm, ") && (mm.states["); 
        count(mm);
        add(mm, "] == false))\n"); 
        add(mm, "  { mm.states["); 
        count(mm);
        add(mm, "] = true; }\n"); 
        add(mm, "if (mm.states["); 
        count(mm);
        add(mm, "] == true) {\n "); 
        // get commandset at tape+4
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, "\n}\n"); 
        // after to match last line in range
        add(mm, "if (mm.line.toString().matches("); 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, ") && (mm.states["); 
        count(mm);
        add(mm, "] == true))\n"); 
        add(mm, "  { mm.states["); 
        count(mm);
        add(mm, "] = false; }\n"); 
        put(mm);
        mm->accumulator++; /* a+ */
      }
      if (strncmp(mm->buffer.workspace, "number*,*number*", strlen("number*,*number*")) == 0) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "if ((mm.linesRead >= "); 
        get(mm);
        add(mm, ") && (mm.linesRead <= "); 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, ")) {\n"); 
        // get commandset at tape+4
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, "\n}"); 
        put(mm);
        mm->accumulator++; /* a+ */
      }
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "command*"); 
      push(mm);
      goto parse;
    }
    push(mm);
    push(mm);
    push(mm);
    push(mm);
    push(mm);
    push(mm);
    pop(mm);
    pop(mm);
    pop(mm);
    //---------------
    // 3 tokens: 
    //   we have to do this first before the action*;* rule 
    //   is reduced.
    // change to the equivalent eg: range*{*command*}*
    // This avoids have to rewrite all the java code construction
    if (0 == strcmp(mm->buffer.workspace, "range*action*;*") || 0 == strcmp(mm->buffer.workspace, "number*action*;*") || 0 == strcmp(mm->buffer.workspace, "pattern*action*;*")) {
      // preserve range/number/pattern parse token
      push(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      // transfer action/command code to the correct tapecell
      get(mm);
      increment(mm);  /* ++ */ 
      put(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "{*commandset*}*"); 
      push(mm);
      push(mm);
      push(mm);
      goto parse;
      // now we have on the stack, for example
      // range*{*commandset*}* which is already handled, and the 
      // code attributes should be in the right tape cells.
      // we could do: add "{*command*}*" but it doesnt matter....
    }
    // gnu sed allows empty braces, so we will too.
    // Another trick: push an empty commandset onto the stack
    // after a brace - that gets rid of this rule and also
    // the : command/command/ -> commandset/ rule
    if (0 == strcmp(mm->buffer.workspace, "range*{*}*") || 0 == strcmp(mm->buffer.workspace, "number*{*}*") || 0 == strcmp(mm->buffer.workspace, "pattern*{*}*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      add(mm, " {}  # warning: empty braces- does nothing!"); 
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "command*"); 
      push(mm);
      goto parse;
    }
    push(mm);
    push(mm);
    push(mm);
    pop(mm);
    pop(mm);
    //---------------
    // 2 token errors
    if (0 == strcmp(mm->buffer.workspace, "pattern*number*") || 0 == strcmp(mm->buffer.workspace, "pattern*pattern*") || 0 == strcmp(mm->buffer.workspace, "number*number*") || 0 == strcmp(mm->buffer.workspace, "number*pattern*") || 0 == strcmp(mm->buffer.workspace, "range*number*") || 0 == strcmp(mm->buffer.workspace, "range*pattern*") || 0 == strcmp(mm->buffer.workspace, "pattern*;*") || 0 == strcmp(mm->buffer.workspace, "number*;*") || 0 == strcmp(mm->buffer.workspace, "range*;*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "Sed syntax error? (near line:char "); 
      lines(mm);
      add(mm, ":"); 
      chars(mm);
      add(mm, ")\n"); 
      add(mm, "  line selector/number/range with no action \n"); 
      add(mm, "  (missing ',' or misplaced ';' ?) \n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      exit(0);
    }
    if (0 == strcmp(mm->buffer.workspace, "action*action*") || 0 == strcmp(mm->buffer.workspace, "action*command*") || 0 == strcmp(mm->buffer.workspace, "action*number*") || 0 == strcmp(mm->buffer.workspace, "action*pattern*") || 0 == strcmp(mm->buffer.workspace, "action*range*") || 0 == strcmp(mm->buffer.workspace, "action*{*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "Sed error (line "); 
      lines(mm);
      add(mm, ", chars "); 
      chars(mm);
      add(mm, "):\n"); 
      add(mm, "  Missing ';' after command?\n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      exit(0);
    }
    if (0 == strcmp(mm->buffer.workspace, ",*}*") || 0 == strcmp(mm->buffer.workspace, ",*{*") || 0 == strcmp(mm->buffer.workspace, ",*;*") || 0 == strcmp(mm->buffer.workspace, ",*,*") || 0 == strcmp(mm->buffer.workspace, ";*,*") || 0 == strcmp(mm->buffer.workspace, ";*{*") || 0 == strcmp(mm->buffer.workspace, "range*,*")) {
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      clop(mm);
      clop(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "Sed error (line "); 
      lines(mm);
      add(mm, ", chars "); 
      chars(mm);
      add(mm, "):\n"); 
      add(mm, "  Unexpected character '"); 
      get(mm);
      add(mm, "' \n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      exit(0);
    }
    //---------------
    // 2 token reductions
    // ignore empty commands (and multiple \n)
    if (0 == strcmp(mm->buffer.workspace, "command*;*") || 0 == strcmp(mm->buffer.workspace, "commandset*;*") || 0 == strcmp(mm->buffer.workspace, ";*;*")) {
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "action*;*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "command*"); 
      push(mm);
      goto parse;
    }
    // maybe need a new token type for clarity here 
    // eg: negated selector
    if (0 == strcmp(mm->buffer.workspace, "number*!*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "number*"); 
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "pattern*!*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "pattern*"); 
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "command*command*") || 0 == strcmp(mm->buffer.workspace, "commandset*command*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      increment(mm);  /* ++ */ 
      add(mm, "\n"); 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "commandset*"); 
      push(mm);
      goto parse;
    }
    pop(mm);
    //---------------
    // 3 token errors
    // eg: '/a/,/bb/p;' or '/[0-3]/,20p;' etc
    //---------------
    // 3 token reductions
    // commands dont need a ';' before a closing brace in gnu sed
    // so transmogrify
    if (0 == strcmp(mm->buffer.workspace, "command*command*}*") || 0 == strcmp(mm->buffer.workspace, "command*action*}*") || 0 == strcmp(mm->buffer.workspace, "commandset*action*}*") || 0 == strcmp(mm->buffer.workspace, "commandset*command*}*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      increment(mm);  /* ++ */ 
      add(mm, "\n"); 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "commandset*}*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "range*action*}*") || 0 == strcmp(mm->buffer.workspace, "number*action*}*") || 0 == strcmp(mm->buffer.workspace, "pattern*action*}*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      get(mm);
      add(mm, "{\n  "); 
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, "\n}"); 
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "command*}*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "{*action*}*")) {
      // make commandset not command for grammar simplicity
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "{*commandset*}*"); 
      push(mm);
      push(mm);
      push(mm);
      goto parse;
    }
    // a single command in braces can be just treated like a 
    // set of commands in braces, so lets change to make other
    // grammar rules simpler
    if (0 == strcmp(mm->buffer.workspace, "{*command*}*")) {
      // make commandset not command for grammar simplicity
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "{*commandset*}*"); 
      push(mm);
      push(mm);
      push(mm);
      goto parse;
    }
    pop(mm);
    //---------------
    // 4 token errors
    //---------------
    // 4 token reductions
    if (0 == strcmp(mm->buffer.workspace, "pattern*{*commandset*}*") || 0 == strcmp(mm->buffer.workspace, "number*{*commandset*}*")) {
      // indent brace commands in tapecell+2
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      swap(mm);
      replace(mm, "\n", "\n  ");        /* replace */
      // indent 1st line using { token as temporary storage
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "  "); 
      get(mm);
      increment(mm);  /* ++ */ 
      swap(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (0 == strcmp(mm->buffer.workspace, "pattern*{*commandset*}*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "if (mm.line.toString().matches("); 
        get(mm);
        add(mm, ")) {\n"); 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, "\n}"); 
        put(mm);
      }
      if (0 == strcmp(mm->buffer.workspace, "number*{*commandset*}*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "if (mm.linesRead == "); 
        get(mm);
        add(mm, ") {\n"); 
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        add(mm, "\n}"); 
        put(mm);
      }
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "command*"); 
      push(mm);
      goto parse;
    }
    pop(mm);
    pop(mm);
    // ----------------
    // 6 token reductions
    // none because we have to do them first.
    push(mm);
    push(mm);
    push(mm);
    push(mm);
    push(mm);
    push(mm);
    if (mm->peep == EOF) {
      // check for valid sed script
      add(mm, "/* The token parse-stack was: "); 
      printf("%s", mm->buffer.workspace);  /* print */
      mm->buffer.workspace[0] = '\0';      /* clear */
      while (pop(mm)) {}          /* unstack */
      add(mm, " */\n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      /* clip */ 
      if (*mm->buffer.workspace != 0)  
        { mm->buffer.workspace[strlen(mm->buffer.workspace)-1] = '\0'; }
      if (0 != strcmp(mm->buffer.workspace, "commandset*") && 0 != strcmp(mm->buffer.workspace, "command*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "# [error] Sed syntax error? \n"); 
        add(mm, "# ----------------- \n"); 
        add(mm, "# Also, uncomment lines after parse> label in script\n"); 
        add(mm, "# to see how the sed script is being parsed. \n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        exit(0);
      }
      if (0 == strcmp(mm->buffer.workspace, "commandset*") || 0 == strcmp(mm->buffer.workspace, "command*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        // indent the generated code
        add(mm, "\n"); 
        get(mm);
        replace(mm, "\n", "\n       ");        /* replace */
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        // create the java preamble, with a 'sedmachine' having a 
        // holdspace and patternspace
        add(mm, ""); 
        add(mm, "\n"); 
        add(mm, "\n /* [ok] Sed syntax appears ok */"); 
        add(mm, "\n /* ---------------------      */"); 
        add(mm, "\n /* Java code generated by \"sed.tojava.pss\" */"); 
        add(mm, "\n import java.io.*;"); 
        add(mm, "\n import java.util.regex.*;"); 
        add(mm, "\n import java.util.*;   // contains stack"); 
        add(mm, "\n"); 
        add(mm, "\n public class javased {"); 
        add(mm, "\n   public StringBuffer patternSpace;"); 
        add(mm, "\n   public StringBuffer holdSpace;"); 
        add(mm, "\n   public StringBuffer line;         /* current line unmodified */"); 
        add(mm, "\n   public int linesRead;"); 
        add(mm, "\n   private boolean[] states;         /* pattern-seen state */"); 
        add(mm, "\n   private Scanner input; "); 
        add(mm, "\n   private boolean eof;              /* end of file reached? */"); 
        add(mm, "\n   private boolean hasSubstituted;   /* a sub on this cycle? */"); 
        add(mm, "\n   private boolean lastLine;         /* last line of input (for $) */"); 
        add(mm, "\n   private boolean readNext;         /* read next line or not */"); 
        add(mm, "\n   private boolean autoPrint;        /* autoprint pattern space? */"); 
        add(mm, "\n"); 
        add(mm, "\n   /** make a new machine with a character stream reader */"); 
        add(mm, "\n   public javased(Scanner scanner) {"); 
        add(mm, "\n     this.patternSpace = new StringBuffer(\"\"); "); 
        add(mm, "\n     this.holdSpace = new StringBuffer(\"\"); "); 
        add(mm, "\n     this.line = new StringBuffer(\"\"); "); 
        add(mm, "\n     this.linesRead = 0;"); 
        add(mm, "\n     this.input = scanner;"); 
        add(mm, "\n     this.eof = false;"); 
        add(mm, "\n     this.hasSubstituted = false;"); 
        add(mm, "\n     this.readNext = true;"); 
        add(mm, "\n     this.autoPrint = true;"); 
        add(mm, "\n     // assume that a sed script has no more than 1K range tests! */"); 
        add(mm, "\n     this.states = new boolean[1000];"); 
        add(mm, "\n     for (int ii = 0; ii < 1000; ii++) { this.states[ii] = false; }"); 
        add(mm, "\n   }"); 
        add(mm, "\n"); 
        add(mm, "\n   /** read one line from the input stream and update the machine. */"); 
        add(mm, "\n   public void readLine() {"); 
        add(mm, "\n     int iChar;"); 
        add(mm, "\n     if (this.eof) { System.exit(0); }"); 
        add(mm, "\n     // increment lines"); 
        add(mm, "\n     this.linesRead++;"); 
        add(mm, "\n     if (this.input.hasNext()) {"); 
        add(mm, "\n       this.line.setLength(0);"); 
        add(mm, "\n       this.line.append(this.input.nextLine());"); 
        add(mm, "\n       this.patternSpace.append(this.line);"); 
        add(mm, "\n     } else { this.eof = true; }"); 
        add(mm, "\n   }"); 
        add(mm, "\n"); 
        add(mm, "\n   /** command \"x\": swap the pattern-space with the hold-space */"); 
        add(mm, "\n   public void swap() {"); 
        add(mm, "\n     String s = new String(this.patternSpace);"); 
        add(mm, "\n     this.patternSpace.setLength(0);"); 
        add(mm, "\n     this.patternSpace.append(this.holdSpace.toString());"); 
        add(mm, "\n     this.holdSpace.setLength(0);"); 
        add(mm, "\n     this.holdSpace.append(s);"); 
        add(mm, "\n   }"); 
        add(mm, "\n"); 
        add(mm, "\n   /** command \"s///x\": make substitutions on the pattern-space */"); 
        add(mm, "\n   public void substitute(String first, String second, String flags) {"); 
        add(mm, "\n     // flags can be gip etc"); 
        add(mm, "\n     // gnu sed modifiers M,<num>,e,w filename may be tricky here."); 
        add(mm, "\n"); 
        add(mm, "\n     String temp = new String(\"\");"); 
        add(mm, "\n     String old = new String(this.patternSpace);"); 
        add(mm, "\n"); 
        add(mm, "\n     // case insensitive: add \"(?i)\" at beginning"); 
        add(mm, "\n     if ((flags.indexOf('i') > -1) ||"); 
        add(mm, "\n         (flags.indexOf('I') > -1)) { first = \"(?i)\" + first; }"); 
        add(mm, "\n"); 
        add(mm, "\n     // multiline matching, check!!"); 
        add(mm, "\n     if ((flags.indexOf('m') > -1) ||"); 
        add(mm, "\n         (flags.indexOf('M') > -1)) { first = \"(?m)\" + first; }"); 
        add(mm, "\n"); 
        add(mm, "\n     // <num>- replace only nth match"); 
        add(mm, "\n     // todo"); 
        add(mm, "\n"); 
        add(mm, "\n     // g- global, replace all."); 
        add(mm, "\n     if (flags.indexOf('g') == -1) {"); 
        add(mm, "\n       temp = this.patternSpace.toString().replaceFirst(first, second);"); 
        add(mm, "\n     } else {"); 
        add(mm, "\n       temp = this.patternSpace.toString().replaceAll(first, second);"); 
        add(mm, "\n     }"); 
        add(mm, "\n     this.patternSpace.setLength(0);"); 
        add(mm, "\n     this.patternSpace.append(temp);"); 
        add(mm, "\n     if  (!old.equals(this.patternSpace.toString())) {"); 
        add(mm, "\n       this.hasSubstituted = true;"); 
        add(mm, "\n       // only print if substitution made, patternspace different ?"); 
        add(mm, "\n       if (flags.indexOf('p') != -1) {"); 
        add(mm, "\n         System.out.println(this.patternSpace);"); 
        add(mm, "\n       }"); 
        add(mm, "\n       // execute pattern space, gnu ext"); 
        add(mm, "\n       if (flags.indexOf('e') != -1) {"); 
        add(mm, "\n       }"); 
        add(mm, "\n       // write pattern space to file, gnu ext"); 
        add(mm, "\n       // need to scan filename"); 
        add(mm, "\n       if (flags.indexOf('w') != -1) {"); 
        add(mm, "\n       }"); 
        add(mm, "\n     }"); 
        add(mm, "\n   }"); 
        add(mm, "\n"); 
        add(mm, "\n   /** command \"W\": save 1st line of patternspace to filename */"); 
        add(mm, "\n   public void writeFirstToFile(String fileName) {"); 
        add(mm, "\n     try {"); 
        add(mm, "\n       File file = new File(fileName);"); 
        add(mm, "\n       Writer out = new BufferedWriter(new OutputStreamWriter("); 
        add(mm, "\n          new FileOutputStream(file), \"UTF8\"));"); 
        add(mm, "\n       // get first line of ps"); 
        add(mm, "\n       out.append(this.patternSpace.toString());"); 
        add(mm, "\n       out.flush(); out.close();"); 
        add(mm, "\n     } catch (Exception e) {"); 
        add(mm, "\n       System.out.println(e.getMessage());"); 
        add(mm, "\n     }"); 
        add(mm, "\n   }"); 
        add(mm, "\n"); 
        add(mm, "\n   /** command \"w\": save the patternspace to filename */"); 
        add(mm, "\n   public void writeToFile(String fileName) {"); 
        add(mm, "\n     try {"); 
        add(mm, "\n       File file = new File(fileName);"); 
        add(mm, "\n       Writer out = new BufferedWriter(new OutputStreamWriter("); 
        add(mm, "\n          new FileOutputStream(file), \"UTF8\"));"); 
        add(mm, "\n       out.append(this.patternSpace.toString());"); 
        add(mm, "\n       out.flush(); out.close();"); 
        add(mm, "\n     } catch (Exception e) {"); 
        add(mm, "\n       System.out.println(e.getMessage());"); 
        add(mm, "\n     }"); 
        add(mm, "\n   }"); 
        add(mm, "\n"); 
        add(mm, "\n   public static void main(String[] args) throws Exception { "); 
        add(mm, "\n     String temp = \"\";    "); 
        add(mm, "\n     javased mm = new javased(new Scanner(System.in)); "); 
        add(mm, "\n     while (!mm.eof) {"); 
        add(mm, "\n       mm.hasSubstituted = false;"); 
        add(mm, "\n       mm.patternSpace.setLength(0);"); 
        add(mm, "\n       // some sed commands restart without reading a line..."); 
        add(mm, "\n       // hence the use of a flag."); 
        add(mm, "\n       if (mm.readNext) { mm.readLine(); }"); 
        add(mm, "\n       mm.readNext = true;"); 
        add(mm, "\n"); 
        get(mm);
        add(mm, "\n       if (mm.autoPrint) { System.out.println(mm.patternSpace); }"); 
        add(mm, "\n     }\n   }\n }\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
      }
      exit(0);
    }
  }
}
