

 /* c code generated by "tr/translate.c.pss" */
 /* note: this c engine cannot handle unicode! */
#include <stdio.h> 
#include <string.h>
#include <time.h> 
#include <ctype.h> 
#include "colours.h"
#include "tapecell.h"
#include "tape.h"
#include "buffer.h"
#include "charclass.h"
#include "command.h"
#include "parameter.h"
#include "instruction.h"
#include "labeltable.h"
#include "program.h"
#include "machine.h"
#include "exitcode.h"
#include "machine.methods.h"
int main() {
  struct Machine machine;
  struct Machine * mm = &machine;
  newMachine(mm, stdin, 100, 10);

  script: 
  while (!mm->peep != EOF) {
    if (mm->peep == EOF) { break; } else { readChar(mm); }  /* read */
    if (0 == strcmp(mm->buffer.workspace, "+") || 0 == strcmp(mm->buffer.workspace, "-")) {
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "opadd*"); 
      push(mm);
    }
    if (0 == strcmp(mm->buffer.workspace, "*") || 0 == strcmp(mm->buffer.workspace, "/")) {
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "opmul*"); 
      push(mm);
    }
    if (0 == strcmp(mm->buffer.workspace, "(") || 0 == strcmp(mm->buffer.workspace, ")")) {
      put(mm);
      add(mm, "*"); 
      push(mm);
    }
    if (workspaceInClassType(mm, "[0-9]")) {
      while (((mm->peep >= '0') && ('9' >= mm->peep)) && readc(mm)) {} /* while */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "number*"); 
      push(mm);
    }
    if (workspaceInClassType(mm, "[a-z]")) {
      while (((mm->peep >= 'a') && ('z' >= mm->peep)) && readc(mm)) {} /* while */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "variable*"); 
      push(mm);
    }
    if (workspaceInClassType(mm, "[:space:]")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
    }
    // a trick to catch bad characters. 
    // better would be a !"text" test
    if (0 == strcmp(mm->buffer.workspace, "")) {
      goto parse;
    }
    add(mm, " << incorrect character (at character "); 
    chars(mm);
    add(mm, " of input). \n"); 
    printf("%s", mm->buffer.workspace);  /* print */
    exit(0);
    parse: 
    // The parse/compile/translate/transform phase involves 
    // recognising series of tokens on the stack and "reducing" them
    // according to the required bnf grammar rules.
    pop(mm);
    // resolve numbers to expressions to simplify grammar rules
    // add a preceding space to numbers and variables.
    if (0 == strcmp(mm->buffer.workspace, "number*") || 0 == strcmp(mm->buffer.workspace, "variable*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, " "); 
      get(mm);
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "exp*"); 
      push(mm);
      goto parse;
    }
    //-----------------
    // 3 tokens
    pop(mm);
    pop(mm);
    // we dont need any look ahead here because * and / have 
    // precedence.
    if (0 == strcmp(mm->buffer.workspace, "exp*opmul*exp*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, " ("); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      get(mm);
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, ")"); 
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "exp*"); 
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "(*exp*)*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "exp*"); 
      push(mm);
      goto parse;
    }
    if (mm->peep == EOF) {
      if (0 == strcmp(mm->buffer.workspace, "exp*opadd*exp*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, " ("); 
        increment(mm);  /* ++ */ 
        get(mm);
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        get(mm);
        increment(mm);  /* ++ */ 
        increment(mm);  /* ++ */ 
        get(mm);
        add(mm, ")"); 
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
        put(mm);
        mm->buffer.workspace[0] = '\0';      /* clear */
        add(mm, "exp*"); 
        push(mm);
        goto parse;
      }
    }
    //-----------------
    // 4 tokens
    pop(mm);
    if (0 == strcmp(mm->buffer.workspace, "exp*opadd*exp*opadd*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, " ("); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      get(mm);
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, ")"); 
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "exp*opadd*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    if (0 == strcmp(mm->buffer.workspace, "exp*opadd*exp*)*")) {
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, " ("); 
      increment(mm);  /* ++ */ 
      get(mm);
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      get(mm);
      increment(mm);  /* ++ */ 
      increment(mm);  /* ++ */ 
      get(mm);
      add(mm, ")"); 
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      if (mm->tape.currentCell > 0) mm->tape.currentCell--;  /* -- */
      put(mm);
      mm->buffer.workspace[0] = '\0';      /* clear */
      add(mm, "exp*)*"); 
      push(mm);
      push(mm);
      goto parse;
    }
    push(mm);
    push(mm);
    push(mm);
    push(mm);
    if (mm->peep == EOF) {
      pop(mm);
      pop(mm);
      if (0 == strcmp(mm->buffer.workspace, "exp*")) {
        mm->buffer.workspace[0] = '\0';      /* clear */
        // add "Yes, its an expression! \n";
        add(mm, "lisp format: "); 
        get(mm);
        add(mm, "\n"); 
        printf("%s", mm->buffer.workspace);  /* print */
        mm->buffer.workspace[0] = '\0';      /* clear */
        exit(0);
      }
      push(mm);
      push(mm);
      add(mm, "No, it doesn't look like a valid 'in-fix' expression. \n"); 
      add(mm, "The parse stack was: "); 
      printf("%s", mm->buffer.workspace);  /* print */
      mm->buffer.workspace[0] = '\0';      /* clear */
      while (pop(mm)) {}          /* unstack */
      add(mm, "\n"); 
      printf("%s", mm->buffer.workspace);  /* print */
      exit(0);
    }
  }
}
