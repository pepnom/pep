#!/usr/bin/ruby

# code generated by "translate.ruby.pss" a pep script
# http://bumble.sf.net/books/pars/tr/
# require 'something'

class Machine 
  # make a new machine 
  attr_accessor :work, :charsRead, :linesRead, :escape, :delimiter, 
    :counter, :stack, :tape, :cell, :marks, :eof, :peep
  
  def initialize() 
    @size = 300      # how many elements in stack/tape/marks
    @eof = false     # end of stream reached?
    @charsRead = 0   # how many chars already read
    @linesRead = 1   # how many lines already read
    @escape = "\\"
    @delimiter = "*" # push/pop delimiter (default "*")
    @counter = 0     # a counter for anything
    @work = ""       # the workspace
    @stack = []      # stack for parse tokens 
    @cell = 0                # current tape cell
    @tape = Array.new(@size) {String.new}    # a list of attribute for tokens 
    @marks = Array.new(@size) {String.new}   # marked tape cells 
    # or dont initialse peep until "parse()" calls "setInput()"
    @peep = ARGF.readchar
  end

  def setInput(newInput) 
    puts "to be implemented"
  end

  # read one character from the input stream and 
  #    update the machine.
  def read 
    if @eof then exit end
    @charsRead += 1;
    # increment lines
    if @peep == "\n" then @linesRead += 1 end
    @work += @peep
    @peep = ARGF.readchar
    if @peep.nil? then @eof = true; end
  end

  # test if all chars in workspace are in unicode category
  def isInCategory(cat) 
    #for ch in @work
    #  if not category(ch).start_with?(cat) then return false end
    #return True
  end

  # this needs to actually walk the string
  # eg "abcab\cabc"
  # not trivial
  def unescapeChar(c)
    @work.gsub!("#{@escape}#{c}", c)
  end

  # add escape character : trivial?
  def escapeChar(c)
    @work.gsub!(c, @escape+c)
  end

  # a helper for the multiescape until bug
  def countEscaped(suffix) 
    count = 0
    #s = @work.sub(/#{suffix}$/, "")
    s = @work.delete_suffix(suffix)
    while s.end_with?(@escape) 
      count += 1
      s.delete_suffix!(@escape)
    end
    # puts "count=#{count}"
    return count
  end

  # reads the input stream until the workspace end with text 
  def until(suffix) 
    # read at least one character
    if @eof then return end
    self.read()
    while true do
      if @eof then return end
      # need to count the @escape chars preceding suffix
      # if odd, keep reading, if even, stop
      if @work.end_with?(suffix) then 
        if (self.countEscaped(suffix).even?) then return end
      end
      self.read()
    end
  end  

  # this implements the ++ command incrementing the tape pointer
  # and growing the tape and marks arrays if required
  def increment()
    @cell += 1
    if @cell >= @size then 
      @tape.append("")
      @marks.append("")
      @size += 1
    end
  end

  # pop the first token from the stack into the workspace */
  def pop() 
    if @stack.length == 0 then return false end
    @work = @stack.pop() + @work
    if @cell > 0 then @cell -= 1 end
    return true
  end

  # push the first token from the workspace to the stack 
  def push() 
    # dont increment the tape pointer on an empty push
    if @work == "" then return false end
    # need to get this from the delimiter.
    iFirst = @work.index(@delimiter)
    if iFirst.nil?
      @stack.push(@work); @work = ""; return true
      # also @stack << @work
    end
    # s[i..j] means all chars from i to j
    # s[i,n] means n chars from i
    @stack.push(@work[0..iFirst])
    @work = @work[iFirst+1..-1]
    self.increment()
    return true
  end

  def printState() 
    puts "Stack[#{@stack.join(', ')}] Work[#{@work}] Peep[#{@peep}]"
    puts "Acc:#{@counter} Esc:#{@escape} Delim:#{@delimiter} Chars:#{@charsRead}" +
         " Lines:#{@linesRead} Cell:#{@cell}"
  end

  def goToMark(mark) 
    ii = @marks.find_index(mark)
    if !ii.nil? then 
      @cell = ii 
    else
      print("bad mark '" + mark + "'!") 
      exit
    end
  end

  # this is where the actual parsing/compiling code should go
  # so that it can be used by other ruby classes/objects. Also
  # should have a stream argument.
  def parse(s) 
    # a reset or "setinput()" method would be useful to parse a 
    # different string/file/stream, without creating a new
    # machine object.
    # could use code like this to check if input is string or file
    #if isinstance(s, file)
      print("")
      # @reset(s)
      # @reader = s
    #elseif isinstance(s, string)
      #f = StringIO.StringIO("test")
      #for line in f  print(line)
    #else
    #  f = STDIN 
    #end
    #puts "not implemented"
  end

end

# end of Machine class definition

# will become:
# mm.parse(sys.stdin)  or 
# mm.parse("abcdef") or
# open f; mm.parse(f)

# the restart flag, which allows .restart to work before the 
# parse label, in languages (like ruby) that dont have 
# labelled loops
restart = false
mm = Machine.new 
while !mm.eof do 
  
  # lex block 
  while true 
    mm.read()        # read
    # make char number relative to line, for error messages
    if (mm.work.match?(/^[\n]+$/)) then
      mm.charsRead = 0           # nochars 
    end
    # newlines can separate commands in (gnu) sed so we will
    # just add a dummy ';' here. Also, no trailing ; is required
    if (mm.work.match?(/^[\n]+$/)) then
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += ";*"
      mm.push();
      break
    end
    # ignore extraneous white-space?
    if (mm.work.match?(/^[[:space:]]+$/)) then
      mm.work = ''        # clear
      if (mm.eof) then
        break
      end
      restart = true; break # restart
    end
    # comments, 
    if (mm.work == "#") then
      mm.until("\n");
      if (!mm.work.end_with?("\n")) then
        mm.work += "\n"
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # uncomment line below to include comments in output
      # and make new reductions
      # add "comment*"; push; .reparse
    end
    # literal tokens '{' and '}' are used to group commands in
    # sed, ';' is used to separate commands and ',' to separate line
    # ranges. ! is the postfix negation operator for ranges
    if (mm.work == "," || mm.work == "{" || mm.work == "}" || mm.work == ";" || mm.work == "!") then
      mm.tape[mm.cell] = mm.work  # put 
      mm.work += "*"
      mm.push();
      break
    end
    # various actions: print, delete, swap
    if (mm.work == "=" || mm.work == "p" || mm.work == "P" || mm.work == "l" || mm.work == "d" || mm.work == "D" || mm.work == "F" || mm.work == "g" || mm.work == "G" || mm.work == "h" || mm.work == "H" || mm.work == "n" || mm.work == "N" || mm.work == "x" || mm.work == "z") then
      if (mm.work == "=") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("=", "=;  # print line-number + \\n")
         end
        
      end
      if (mm.work == "d") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("d", "d;  # delete pattern-space, restart")
         end
        
      end
      if (mm.work == "D") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("D", "D;  # delete pattern-space to 1st \\n, restart")
         end
        
      end
      if (mm.work == "e") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("e", "e;  # exec patt-space command and replace")
         end
        
      end
      if (mm.work == "F") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("F", "F;  # print input filename + \\n")
         end
        
      end
      if (mm.work == "g") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("g", "g;  # replace patt-space with hold-space")
         end
        
      end
      if (mm.work == "G") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("G", "G;  # append hold-space to patt-space + \\n")
         end
        
      end
      if (mm.work == "h") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("h", "h;  # replace hold-space with patt-space")
         end
        
      end
      if (mm.work == "H") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("H", "H;  # append patt-space to hold-space + \\n")
         end
        
      end
      if (mm.work == "l") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("l", "l;  # print pattern-space unambiguously")
         end
        
      end
      if (mm.work == "n") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("n", "n;  # print patt-space, get next line into patt-space ")
         end
        
      end
      if (mm.work == "N") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("N", "N;  # append next line to patt-space + \\n ")
         end
        
      end
      if (mm.work == "p") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("p", "p;  # print pattern-space")
         end
        
      end
      if (mm.work == "P") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("P", "P;  # print pattern-space up to 1st newline")
         end
        
      end
      if (mm.work == "x") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("x", "x;  # swap pattern-space with hold-space")
         end
        
      end
      if (mm.work == "z") then
        # replace 
        if mm.work.length > 0 then 
          mm.work.gsub!("z", "z;  # delete pattern-space, NO restart")
         end
        
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "action*"
      mm.push();
      break
    end
    # line numbers are also selectors
    if (mm.work.match?(/^[0-9]+$/)) then
      # while  
      while /^[0-9]+$/.match?(mm.peep)
        if mm.eof then break end
        mm.read()
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "number*"
      mm.push();
      break
    end
    # $ is the last line of the file
    if (mm.work == "$") then
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "number*"
      mm.push();
      break
    end
    # patterns - only execute commands if lines match 
    if (mm.work == "/") then
      # save line/char number for error message 
      mm.work = ''        # clear
      mm.work += "near line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", char "
      mm.work += mm.charsRead.to_s # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.until("/");
      if (!mm.work.end_with?("/")) then
        mm.work = ''        # clear
        mm.work += "Missing '/' to terminate "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "?\n"
        print mm.work       # print
        exit
      end
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # add any delimiter for pattern here, or none
      mm.work += "/"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "/"
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "pattern*"
      mm.push();
      break
    end
    # read transliteration commands
    if (mm.work == "y") then
      # save line/char number for error message 
      mm.work = ''        # clear
      mm.work += "near line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", char "
      mm.work += mm.charsRead.to_s # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # allow spaces between 'y' and '/' although gnu set doesn't
      mm.until("/");
      if (!mm.work.end_with?("/") || !mm.work.match?(/^[ \/]+$/)) then
        mm.work = ''        # clear
        mm.work += "Missing '/' after 'y' transliterate command\n"
        mm.work += "Or trailing characters "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      # save line/char number for error message 
      mm.work = ''        # clear
      mm.work += "near line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", char "
      mm.work += mm.charsRead.to_s # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.until("/");
      if (!mm.work.end_with?("/")) then
        mm.work = ''        # clear
        mm.work += "Missing 2nd '/' after 'y' transliterate command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      if (mm.work == "/") then
        mm.work = ''        # clear
        mm.work += "Sed syntax error? \n"
        mm.work += "  Empty regex after 'y' transliterate command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      # replace pattern found
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "y/"
      mm.work += mm.tape[mm.cell] # get
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # save line/char number for error message 
      mm.work += "near line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", char "
      mm.work += mm.charsRead.to_s # chars 
      mm.increment()      # ++
      mm.tape[mm.cell] = mm.work  # put 
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.work = ''        # clear
      mm.until("/");
      if (!mm.work.end_with?("/")) then
        mm.work = ''        # clear
        mm.work += "Missing 3rd '/' after 'y' transliterate command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += "/"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "/"
      # y/// does not have modifiers (unlike s///)
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "action*"
      mm.push();
      break
    end
    # various commands that have an option word parameter 
    if (mm.work == "b" || mm.work == "e" || mm.work == "q" || mm.work == "Q" || mm.work == "t" || mm.work == "T") then
      # ignore intervening space if any
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # while  
      while /^[ ]+$/.match?(mm.peep)
        if mm.eof then break end
        mm.read()
      end
      mm.work = ''        # clear
      # A bit more permissive that gnu-sed which doesn't allow
      # read to end in ';'.
      # whilenot  
      while !/^[ ;}]+$/.match?(mm.peep)
        if mm.eof then break end
        mm.read()
      end
      # word parameters are optional to these commands
      # just add a space to separate command from parameter
      if (mm.work != "") then
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
        mm.work += " "
        mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      end
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += mm.tape[mm.cell] # get
      if (mm.work.start_with?("b")) then
        mm.work += ";  # branch to <label> or start"
      end
      if (mm.work.start_with?("e ")) then
        mm.work += ";  # exec <cmd> and insert into output"
      end
      if (mm.work == "e") then
        mm.work += ";  # exec patt-space command into patt-space"
      end
      if (mm.work.start_with?("q")) then
        mm.work += ";  # print + quit with optional exit code"
      end
      if (mm.work.start_with?("Q")) then
        mm.work += ";  # quit with optional exit code"
      end
      if (mm.work.start_with?("t")) then
        mm.work += ";  # branch to <label> if substitution made or start"
      end
      if (mm.work.start_with?("T")) then
        mm.work += ";  # branch to <label> if NO substituion or start"
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "action*"
      mm.push();
      break
    end
    # read 'read <filename>' and write commands
    if (mm.work == ":" || mm.work == "r" || mm.work == "R" || mm.work == "w" || mm.work == "W") then
      # ignore intervening space if any
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # while  
      while /^[ ]+$/.match?(mm.peep)
        if mm.eof then break end
        mm.read()
      end
      mm.work = ''        # clear
      # A bit more permissive that gnu-sed which doesn't allow
      # read to end in ';'.
      # whilenot  
      while !/^[ ;}]+$/.match?(mm.peep)
        if mm.eof then break end
        mm.read()
      end
      if (mm.work == "") then
        mm.work = ''        # clear
        mm.work += "Sed syntax error? (at line:char "
        mm.work += mm.linesRead.to_s # lines 
        mm.work += ":"
        mm.work += mm.charsRead.to_s # chars 
        mm.work += ")\n"
        mm.work += "  no filename for read 'r' command. \n"
        print mm.work       # print
        exit
      end
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += " "
      mm.work += mm.tape[mm.cell] # get
      if (mm.work.start_with?(": ")) then
        mm.work += ";  # branch to <label>"
      end
      if (mm.work.start_with?("r ")) then
        mm.work += ";  # read file into patt-space"
      end
      if (mm.work.start_with?("R ")) then
        mm.work += ";  # insert file into output before next line"
      end
      if (mm.work.start_with?("w ")) then
        mm.work += ";  # write patt-space to file"
      end
      if (mm.work.start_with?("W ")) then
        mm.work += ";  # write 1st line of patt-space to file"
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "action*"
      mm.push();
      break
    end
    # read substitution commands
    if (mm.work == "s") then
      # save line/char number for error message 
      mm.work = ''        # clear
      mm.work += "near line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", char "
      mm.work += mm.charsRead.to_s # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # allow spaces between 's' and '/'
      mm.until("/");
      if (!mm.work.end_with?("/") || !mm.work.match?(/^[ \/]+$/)) then
        mm.work = ''        # clear
        mm.work += "Missing '/' after 's' substitute command\n"
        mm.work += "Or trailing characters "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      # save line/char number for error message 
      mm.work = ''        # clear
      mm.work += "near line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", char "
      mm.work += mm.charsRead.to_s # chars 
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.until("/");
      if (!mm.work.end_with?("/")) then
        mm.work = ''        # clear
        mm.work += "Sed syntax error? \n"
        mm.work += "  Missing 2nd '/' after 's' substitute command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      if (mm.work == "/") then
        mm.work = ''        # clear
        mm.work += "Sed syntax error? \n"
        mm.work += "  Empty regex after 's' substitute command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      # replace pattern found
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "s/"
      mm.work += mm.tape[mm.cell] # get
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      # save line/char number for error message 
      mm.work += "near line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", char "
      mm.work += mm.charsRead.to_s # chars 
      mm.increment()      # ++
      mm.tape[mm.cell] = mm.work  # put 
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.work = ''        # clear
      mm.until("/");
      if (!mm.work.end_with?("/")) then
        mm.work = ''        # clear
        mm.work += "Missing 3rd '/' after 's' substitute command "
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
        exit
      end
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      mm.work, mm.tape[mm.cell] = mm.tape[mm.cell], mm.work   # swap 
      mm.work += "/"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "/"
      # also need to read modifiers, eg g/i/p/[0-9] etc
      # need better logic to process these modifiers.
      # while  
      while /^[gip]+$/.match?(mm.peep)
        if mm.eof then break end
        mm.read()
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "action*"
      mm.push();
      break
    end
    if (mm.work == "a" || mm.work == "c" || mm.work == "i") then
      # label, append, branch, change, insert, quit, write, test, write, read
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "Unimplemented command (near line:char "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ":"
      mm.work += mm.charsRead.to_s # chars 
      mm.work += ")\n"
      mm.work += "  The script does not recognise '"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "' yet.\n"
      print mm.work       # print
      exit
    end
    if (mm.work != "") then
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "Sed syntax error? (near line:char "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ":"
      mm.work += mm.charsRead.to_s # chars 
      mm.work += ")\n"
      mm.work += "  unrecognised command '"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "'\n"
      print mm.work       # print
      exit
    end
    # where token reduction begins
    break 
  end
  if restart then restart = false; next; end
  
  # parse block 
  while true 
    # To visualise token reduction uncomment this below:
    # lines; add ":"; chars; add " "; print; clear; 
    # add "\n"; unstack; print; clip; stack; 
    # commands do not have to be terminated with ';' at the end of a sed script.
    if (mm.eof) then
      mm.pop();
      if (mm.work == "action*") then
        mm.work += ";*"
        mm.push();
        mm.push();
        next
      end
      mm.push();
    end
    mm.pop();
    mm.pop();
    mm.pop();
    #---------------
    # 3 tokens: 
    #   we have to do this first before the action*;* rule 
    #   is reduced.
    if (mm.work == "range*action*;*" || mm.work == "number*action*;*" || mm.work == "pattern*action*;*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.work += " {\n  "
      mm.increment()      # ++
      mm.work += mm.tape[mm.cell] # get
      mm.work += "\n}"
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "command*"
      mm.push();
      next
    end
    # gnu sed allows empty braces, so we will too.
    if (mm.work == "range*{*}*" || mm.work == "number*{*}*" || mm.work == "pattern*{*}*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.work += " {}  # warning: empty braces- does nothing!"
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "command*"
      mm.push();
      next
    end
    mm.push();
    mm.push();
    mm.push();
    mm.pop();
    mm.pop();
    #---------------
    # 2 token errors
    if (mm.work == "pattern*number*" || mm.work == "pattern*pattern*" || mm.work == "number*number*" || mm.work == "number*pattern*" || mm.work == "range*number*" || mm.work == "range*pattern*" || mm.work == "pattern*;*" || mm.work == "number*;*" || mm.work == "range*;*") then
      mm.work = ''        # clear
      mm.work += "Sed syntax error? (near line:char "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ":"
      mm.work += mm.charsRead.to_s # chars 
      mm.work += ")\n"
      mm.work += "  line selector/number/range with no action \n"
      mm.work += "  (missing ',' or misplaced ';' ?) \n"
      print mm.work       # print
      exit
    end
    if (mm.work == "action*action*" || mm.work == "action*command*" || mm.work == "action*number*" || mm.work == "action*pattern*" || mm.work == "action*range*" || mm.work == "action*{*") then
      mm.work = ''        # clear
      mm.work += "Sed error (line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", chars "
      mm.work += mm.charsRead.to_s # chars 
      mm.work += "):\n"
      mm.work += "  Missing ';' after command?\n"
      print mm.work       # print
      exit
    end
    if (mm.work == ",*}*" || mm.work == ",*{*" || mm.work == ",*;*" || mm.work == ",*,*" || mm.work == ";*,*" || mm.work == ";*{*" || mm.work == "range*,*") then
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      if !mm.work.empty? then       # clop 
        mm.work = mm.work[1..-1];  # clop 
      end
      if !mm.work.empty? then       # clop 
        mm.work = mm.work[1..-1];  # clop 
      end
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "Sed error (line "
      mm.work += mm.linesRead.to_s # lines 
      mm.work += ", chars "
      mm.work += mm.charsRead.to_s # chars 
      mm.work += "):\n"
      mm.work += "  Unexpected character '"
      mm.work += mm.tape[mm.cell] # get
      mm.work += "' \n"
      print mm.work       # print
      exit
    end
    #---------------
    # 2 token reductions
    # ignore empty commands (and multiple \n)
    if (mm.work == "command*;*" || mm.work == "commandset*;*" || mm.work == ";*;*") then
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      mm.push();
      next
    end
    if (mm.work == "action*;*") then
      mm.work = ''        # clear
      mm.work += "command*"
      mm.push();
      next
    end
    # maybe need a new token type for clarity here 
    # eg: negated selector
    if (mm.work == "number*!*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "number*"
      mm.push();
      next
    end
    if (mm.work == "pattern*!*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "pattern*"
      mm.push();
      next
    end
    if (mm.work == "command*command*" || mm.work == "commandset*command*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++
      mm.work += "\n"
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "commandset*"
      mm.push();
      next
    end
    mm.pop();
    #---------------
    # 3 token errors
    # eg: '/a/,/bb/p;' or '/[0-3]/,20p;' etc
    if (mm.work == "pattern*,*pattern*" || mm.work == "pattern*,*number*" || mm.work == "number*,*number*" || mm.work == "number*,*pattern*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.work += ","
      mm.increment()      # ++
      mm.increment()      # ++
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0 then mm.cell -= 1; end # --
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "range*"
      mm.push();
      next
    end
    #---------------
    # 3 token reductions
    # commands dont need a ';' before a closing brace in gnu sed
    # so transmogrify
    if (mm.work == "command*command*}*" || mm.work == "command*action*}*" || mm.work == "commandset*action*}*" || mm.work == "commandset*command*}*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.increment()      # ++
      mm.work += "\n"
      mm.work += mm.tape[mm.cell] # get
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "commandset*}*"
      mm.push();
      mm.push();
      next
    end
    if (mm.work == "range*action*}*" || mm.work == "number*action*}*" || mm.work == "pattern*action*}*") then
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.work += "{\n  "
      mm.increment()      # ++
      mm.work += mm.tape[mm.cell] # get
      mm.work += "\n}"
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "command*}*"
      mm.push();
      mm.push();
      next
    end
    if (mm.work == "{*action*}*") then
      mm.work = ''        # clear
      mm.work += "{*command*}*"
      mm.push();
      mm.push();
      mm.push();
      next
    end
    mm.pop();
    #---------------
    # 4 token errors
    #---------------
    # 4 token reductions
    if (mm.work == "range*{*command*}*" || mm.work == "range*{*commandset*}*" || mm.work == "pattern*{*command*}*" || mm.work == "pattern*{*commandset*}*" || mm.work == "number*{*command*}*" || mm.work == "number*{*commandset*}*") then
      # indent brace commands
      mm.work = ''        # clear
      mm.increment()      # ++
      mm.increment()      # ++
      mm.work += mm.tape[mm.cell] # get
      # replace 
      if mm.work.length > 0 then 
        mm.work.gsub!("\n", "\n  ")
       end
      
      mm.tape[mm.cell] = mm.work  # put 
      if mm.cell > 0 then mm.cell -= 1; end # --
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.work = ''        # clear
      mm.work += mm.tape[mm.cell] # get
      mm.work += " {\n  "
      mm.increment()      # ++
      mm.increment()      # ++
      mm.work += mm.tape[mm.cell] # get
      mm.work += "\n}"
      if mm.cell > 0 then mm.cell -= 1; end # --
      if mm.cell > 0 then mm.cell -= 1; end # --
      mm.tape[mm.cell] = mm.work  # put 
      mm.work = ''        # clear
      mm.work += "command*"
      mm.push();
      next
    end
    mm.push();
    mm.push();
    mm.push();
    mm.push();
    if (mm.eof) then
      # check for valid sed script
      mm.work += "Parse stack was:\n "
      print mm.work       # print
      mm.work = ''        # clear
      while mm.pop() do next end  # unstack 
      mm.work += "\n"
      print mm.work       # print
      if !mm.work.empty? then       # clip 
        mm.work = mm.work[0..-2]   # clip 
      end
      if (mm.work != "commandset*" && mm.work != "command*") then
        mm.work = ''        # clear
        mm.work += "# Sed syntax error? \n"
        mm.work += "# ----------------- \n"
        mm.work += "# Also, uncomment lines after parse> label in script\n"
        mm.work += "# to see how the sed script is being parsed. \n"
        print mm.work       # print
        exit
      end
      if (mm.work == "commandset*" || mm.work == "command*") then
        mm.work = ''        # clear
        mm.work += "# Sed syntax appears ok \n"
        mm.work += "# --------------------- \n"
        mm.work += "# [script explained]    \n"
        mm.work += mm.tape[mm.cell] # get
        mm.work += "\n"
        print mm.work       # print
      end
      exit
    end
    break 
  end # parse
  
end


# end of generated code
