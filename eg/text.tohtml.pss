
#*
  
ABOUT

  This is another version of a script to transform a "plain" (minimal markup)
  text document into simple html and css.  I intend to only add the structures
  which I use frequently. This script is grammatically simpler than an earlier
  attempt called /eg/mark.html.pss and it feels easier to maintain and extend.
  This script has been very successful and is used for rendering the [html] at
  www.nomlang.org

  This formatting script relies heavily on /site.blog.css to actually make 
  the html look good or ok.

GRAMMAR TOKENS USED BY THE SCRIPT

  space* white-space and newlines
  word* one space delimited word
  text* any text including html tags as added
  quoted* text between double quotes "like this" but one line only.
  url* anything starting with http:// https:// www. etc
  file* a filename
  upper.heading* an uppercase heading line.
  item* an item of a list
  endlist* reverse shift reductions of lists

  The success of this html formatting script is probably owing to 
  the small number of grammar tokens. For example there is no newline*
  or blankline* token although I do use the accumulator to determine
  if the current word is the first word on the line. Also, lists are 
  terminated by a "blank" line (empty, or only space) but I don't
  actually create a parse token for it.

  The relative simplicity of this script grammar is probably due
  to it using a *word-by-word* parsing technique which means that 
  few grammar tokens are required.

TODO

  Make archaic spellings like applyed and ribband which I like in
  some cases. 
  
  all upper case headings which I have used in many documents
  
  Make the text "add command" and "nom scripts" etc format the command
  word like 'add' as <code> or something similar.

  Think about "quoted". or "quoted", either ending in dot or comma
  to parse properly.

  definition lists ? 

DONE 

  put a "title=" attribute in links to give a hint for things like oed:
  lookup.

  unordered lists. eg 
   - one
   - two end
     with blank line

  images, sort of (need to make a width for the <figure> tag) 

OTHER FILES

  /site.blog.css
    actually makes the html look ok.
  books/pars/www/blog.sh
    A bash script which contains a set of functions which use this 
    script to manage blog websites.
  books/pars/eg/make.html.header.pss
    Generates the html header and banner for the page (contains css).

NOTES

  U+1F674 üô¥ heavy ampersand ornament
  U+1F675 üôµ  swash ampersand ornament

  https://html.spec.whatwg.org/multipage/named-characters.html

  &gscr; &Gscr; is a cursive g html entity.
  &ascr; &Ascr; 

  The development of this proceeded very quickly. In a few hours I
  had significant syntax implemented. This was much faster than
  mark.html.pss and mark.latex.pss

  This is part of an effort to create a pep/nom based blog with
  rss feed (pars/www/blog.sh) as well as the shrob.org blog
  and the makethespoon.org site.

  
  It would be nice to have an "until 'ab','cd','ef'" syntax
  to that we could parse one line quotes etc. Eg
    >> until '"','\n';
  We cant do
    >> whilenot ["\n]
  but that has its own problems.

MARKUP FORMAT

  See /eg/text.tohtml.format.html (.txt) for detailed info about 
  the minimal markup format that this script recognises and 
  formats. Supported are images (with size, placement and captions),
  lists, headings, links, convenience links etc

STATUS

  18 mar 2025
    marking up lots of formats, see /eg/text.tohtml.format.html
    Script seems to be working well with links headings emphasis.
    Unordered lists seem to work.
    Still missing some lists and all capital heading lines.

HISTORY

  28 August 2025
    I seem to have fixed the segmentation faults that were occuring
    with this script and the pep interpreter, but I dont think I have really
    got to the heart of the problem.
  13 August 2025
    Adding better help and testing to this script, but I am starting
    to run into lots of segmentation faults when adding to the script
    which are marked as fix: So it is time to find out which bit of 
    my pep interpreter code is dodgy.
  9 August 2025
    Added self-translation via /eg/nom.to.pss script
    eg: pep -f text.tohtml.pss -i /torust
  25 july 2025
    A strange segmentation fault when adding an extra brace block
    to a block. See the code below.
  22 july 2025
    added a help system to this, because it is fun. I will 
    also add an error* token, but I don't expect to use it much,
    probably only when there is an empty document.
  26 april 2025
    adding uppercase lines as headings to this formatter.
  24 april 2025
    making quotes and emphasised text work even when there is a 
    trailing dot or comma.
  18 march 2025
    Doing some crazy reverse reductions with lists. There is no real
    start-token for an unordered list (just the '-' word starting a
    line, but that is the item* token). So have to reduce the list 
    when I get to the end of it.
  6 march 2025 
    Added rosetta:// schema for rosettacode.org problems.
  24 feb 2025 
    added an urbandict:// schema for word lookups.
    reformed the was oed: and urbandict: links are rendered by rendering
    in the parsing phase not lexing phase
  21 feb 2025
    added a nomsyn:// url schema for writing about nom syntax
  20 feb 2025
    really struggled with the images. Had to change the width format
    to multiples of 5em, because variable length fields were too 
    hard to extract without regexs
  13 feb 2025
    added attributes to images eg <:o:3:<<:imagename.ext> the 
    parsing is working but have to fix the css and maybe also
    the <figure> <img> tag interaction.
  11 feb 2025
    added forced line breaks >> and horizontal rules
  9 feb 2025
    Added some html curly quotes to quoted text which is not a 
    link. Added ordinal number superscripts in english (which is 
    a bit silly really. working on images 
  4 Feb 2025
    Began this script, created some useful syntax

*#

 # check for an empty doc and trigger help if true
 begin {
   while [:space:]; clear;
   (eof) {
     # the category is help and the token too.
     add "usage"; put; clear; 
     add "help*"; push; .reparse
   }
   # a document starting with / or // etc will be considered a help request
   # get 2 words and save with no space
   while [/];
   !"" {
     # get 2 help words and save with no space 
     clear; while [:space:]; clear; whilenot [:space:];
     put; clear; while [:space:]; clear; whilenot [:space:];
     swap; get; put; clear;
     add "help*"; push; .reparse
   }
 }

 read;
 # newlines and empty lines
 [\n] {
   clear; add "\n"; put;

   clear; pop;
   # check for last all uppercase line heading
   "upper.heading*" {
     clear; add "<h2>"; get; add "</h2>"; put;
     clear; add "text*"; push;
   }
   push;

   # no words on previous line, so this is a blank line
   clear; count; "0" {
     clear; 

     # check here for end of list
     pop; pop; 
     "item*text*" {
       push; push; add "</li>\n</ul>\n"; put; 
       clear; add "endlist*"; push; .reparse
     }
     push;push; 
     add "<p>\n"; put; clear;
   }
   # set accumulator == 0 so that we can count words 
   # per line (and know which is the first word)
   clear; zero; nochars;
   add "space*"; push; .reparse
 }

 # parse space, but maybe [:space:] would be better.
 [ \t] {
   while [ \t]; 
   clear; add " "; put; clear;
   add "space*"; push; .reparse
 }

 # ignore other types of space
 [:space:] {
   clear; .restart
 }

 # everything else is a word
 ![:space:] {
   # read word and increment word counter
   whilenot [:space:]; a+;
   
   # here parse image files in format <imfile.jpg> before we
   # change > < to entities.
   # --------------
   #B"<" {
   #  E".jpg>",E".jpeg>",E".png>",E".gif>" {
   #    clip; clop; put; clear;
   #    add "imagefile*"; push; .reparse
   #  }
   #}

   # here we build an <img> html tag from minimal and optional markup
   # attributes are <:corners:float:width:filename.ext>
   # this code is quite tricky. See also /eg/imagetext.tohtml.pss 
   # the .img extension is a fake extension for random images.
   B"<".E">".!"<>" {
     E".png>",E".jpg>",E".jpeg>",E".bmp>",E".gif>",E".img>" { 
       # an example image text format may be 
       # <:0:4:>>:/image/name.gif> or <name.gif> 
       # The order of the attributes is important but the attributes 
       # are optional eg: <:<<:r:20pt:name.jpg> wont work because the 
       # float attribute '<<' comes before the rounded corner attribute 'r'
       clip; clop; put; clear;
       # put a faint grey border around images.?
       # add "<img style='border:4px solid #999999;"; swap; 
       add "<img style='"; swap; 
       # we use swap to juggle the built html and the original
       # minimal markup text.
       # :0: is the circle image (avatar) indicator,

       # allow the first colon to be missing
       B":O:",B":o:",B"O:",B"o:" {
         swap; add "border-radius:50%;";
         swap; B":" { clop; } clop;
       }
       # small rounded corners on the image
       B":r:",B"r:" {
         swap; add "border-radius:5%;";
         swap; B":" { clop; } clop;
       }
       # large rounded corners 
       B":R:",B"R:" {
         swap; add "border-radius:15%;";
         swap; B":" { clop; } clop;
       }

       # width spec multiple of 5em, allow missing 1st colon
       B":1:",B":2:",B":3:",B":4:",B":5:",
       B"1:",B"2:",B"3:",B"4:",B"5:" {
         B":" { clop; }
         B"1:" { swap; add "width:5em;"; }
         B"2:" { swap; add "width:10em;"; }
         B"3:" { swap; add "width:15em;"; }
         B"4:" { swap; add "width:20em;"; }
         B"5:" { swap; add "width:25em;"; }
         swap; clop;
       }
       # add a default width
       swap; !E"em;" { add "width:10em;"; }
       # finish off the style attribute
       add "' "; swap;
       # the float right indicator, it needs to come after :0:
       B":>>:",B">>:" {
         swap; add "class='float-right' "; 
         swap; B":" { clop; } clop; clop;
       }
       # float left 
       B":<<:",B">>:" {
         swap; add "class='float-left' "; 
         swap; B":" { clop; } clop; clop;
       }
       # centre indicator  
       B":cc:" {
         swap; add "class='center' "; 
         swap; clop; clop; clop;
       }

       B":" { clop; }
       # build the html image src= attribute. 
       # 
       swap; add " title='"; get; add "' src='"; get; add "'/>"; 
       swap; clear;

       clear;
       add "imagefile*"; push; .reparse
     }
   }

   # make < and > html entities because they will wreck our page
   # but not if is >> as 1st word
   !">>" { replace ">" "&gt;"; replace "<" "&lt;"; }
   # some curly quotes, why not? A half hearted attempt for english

   # promote the language with italics
   "nom" { clear; add "<em>nom</em>"; }
   "Nom" { clear; add "<em>Nom</em>"; }
   "pep" { clear; add "<em>pep</em>"; }
   "pep/nom","pep and nom" { 
     clear; add "<em class='pep-and-nom'>Pep & Nom</em>";
     # U+1F675 
     # swash ampersand ornament
     # U+1F671 üô± heavy script ligature et ornament
     # U+1F672 üô≤ ligature open et ornament
     # U+1F673 üô≥ heavy ligature open et ornament
     # U+1F674 üô¥ heavy ampersand ornament
     # U+1F675 üôµ swash ampersand ornament
   }

   

   #*
    I had the idea to substitute archaic words and spellings for 
    modern one more or less randomly to add a bit of spice to the 
    text... but not sure if I will

    anon: "immediately"
    betwixt: "in between"
    erelong: "soon"
    shortly: "soon"
    Forthwith: "immediately"
    Potation: "a beverage"
    ribband: "ribbon"
    countrie: "country"
    ys: "is"
    pryvy: privy
    sayd: said
    Scurvy: "worthless"
    'tis: "it is"
    Twelvemonth: "a year"
    Wench: "young woman or girl"
    Thee: "thou" 

   *#
  
   # mark up nom parse tokens as being something special which end in
   # * . This should not clash with emphasised text because that is parsed
   # with nom://whilenot 
   E"*".!"*".!B"*".!"#*" { 
     put; clear; 
     add "<em><code class='nom-token'>"; get; add "</code></em>";
   }
   
   # fix: this was causing a segmentation fault (maybe because of 
   # bad 'until' code.
   !"ae" { replace "ae" "√¶"; }
   # !"ae" { replace "ae" "ae"; }
   # but this no.
   replace "ae" "√¶"; 
   # put the 'ears' on some words - this is a Yolngu thing
   "naive","dais" { replace "i" "√Ø"; }
   "bronte","moet" { replace "e" "√´"; }
   "reelect","reentry" { replace "ee" "e√´"; }

   # insert some apostrophes
   "doesnt","isnt","cant","arent","couldnt","didnt","hasnt",
   "havent","shouldnt","mustnt","wasnt" {
     replace "nt" "n't";
   }
   "lets","thats","whats" {
     replace "ts" "t's";
   }

   "I'm","you're","he's","she's","it's","we're","they're","aren't",
   "can't","couldn't","didn't","doesn't","hadn't","hasn't","haven't",
   "isn't","mightn't","mustn't","oughtn't","shouldn't","wasn't",
   "weren't","won't","wouldn't","I've","you've","he's","she's","it's",
   "we've","they've","I'd","you'd","he'd","she'd","it'd","we'd",
   "they'd","I'll","you'll","he'll","she'll","it'll","we'll","they'll",
   "there's","that's","what's","who's","where's","when's","why's",
   "how's" {
     # curly vs straight apostrophe
     # replace "'" "&rsquo;";
     replace "'" "&apos;";

   }

   # some common typos for apostrophe contractions in english
   "wouldnt","shouldnt","wont","dont","Im","theyre","wasnt","werent",
   "arent","cant","didnt","doesnt","havent","hasnt","isnt","couldnt" {
     replace "Im" "I&rsquo;m"; replace "nt" "n&rsquo;t"; 
   }

   # now do t's english typos or fast typing. I know, very english centric
   # but I write in english, so there
   "thats","whats","its" {
     replace "ts" "t&rsquo;s"; 
   }

   put;
   # make nice arrows out of -> and --> and <- and <--
   "-&gt;" { clear; add "‚Üí"; } "--&gt;" { clear; add "‚Ü¶"; }
   "&lt;-" { clear; add "‚áΩ"; } "&lt;--" { clear; add "‚á¶"; }

   # typeset No. Number abbreviation.
   "No.","no." {
     clear; 
     add "N<sup style='text-decoration:underline;";
     add " text-decoration-thickness:2px;";
     add " font-style:bold; vertical-align:0.30em;'>o</sup>";
   }

   # ordinals in english, very perfunctory but sort of fun. 
   # eg: 1st, 2nd, 301rd
   [0123456789stndrdth] {
     E"1st" {
       # check matches [0-9]*1st
       clip; clip; clip; "",[0-9] {
         clear; get; clip; clip;
         add "<sup class='ordinal'>st</sup>";
       }
     } 
     E"2nd" {
       # check matches [0-9]*2nd
       clip; clip; clip; "",[0-9] {
         clear; get; clip; clip;
         add "<sup class='ordinal'>nd</sup>";
       }
     }
     E"3rd" {
       clip; clip; clip; "",[0-9] {
         clear; get; clip; clip;
         add "<sup class='ordinal'>rd</sup>";
       }
     }
     E"th" {
       # check matches [0-9]*[4-9]th 
       clip; clip; !"".!E"1".!E"2".!E"3".[0-9] {
         add "<sup class='ordinal'>th</sup>";
       }
     }
   }

   put; clear; count;
   # deal with ">>" when not first word
   !"1" { 
     clear; get; 
     ">>" { clear; add "&gt;&gt;"; put; }
     clear; count;
   }
   # check if this is the first word on the line
   # because several markup elements (as in markdown) need to be
   # the 1st word to be significant.
   "1" {
     clear; get;

     # a one line comment, just ignored at the moment.
     "#:" { 
       clear; whilenot [\n]; clear; .reparse
     }

     # uppercase headings. First word must be at least 3 characters
     [A-Z] {
       clip; clip; 
       !"" {
         clear; add "upper.heading*"; push; .reparse
       }
       clear; get;
     }

     # unordered list items.
     "-" { 
       clear; add "</li>\n<li>"; put; clear;
       add "item*"; push; .reparse
     }

     # asterix as first word on line marks the description of 
     # a code line or block which follows (like a caption)
     # format this later in 2 token parsing. 
     # starlines are used as captions for code and also citations
     # for quotations.
     "*" { 
       clear; whilenot [\n]; 
       replace ">" "&gt;"; replace "<" "&lt;";
       # primitive markup technique
       replace " nom " " nom ";
       replace " pep " " pep ";
       replace " pep/nom " " pep/nom ";
       put; clear;
       add "starline*"; push; .reparse
     }
     # document or page title  
     "&&" { 
       clear; whilenot [\n]; 
       replace ">" "&gt;"; replace "<" "&lt;";
       replace " Pep and Nom" " Pep & Nom";
       replace " nom " " Nom "; replace " pep " " Pep ";
       replace " Nom " " Nom ";
       replace " Pep " " Pep ";
       # U+1F674 üô¥ heavy ampersand ornament
       put; clear;
       add "<!-- ------------ page title -------------------- -->\n";
       add "<h1 class='page-title'>"; get; add "</h1>\n"; put; clear;
       add "text*"; push; .reparse
     }
     # markdown style headings. I would prefer to use one # as 
     # a comment.
     "#" { 
       clear; whilenot [\n]; 
       replace ">" "&gt;"; replace "<" "&lt;";
       put; clear;
       add "<!-- ------------------------------- -->\n";
       add "<h1>"; get; add "</h1>\n"; put; clear;
       add "text*"; push; .reparse
     }
     # headings to capital case
     "##" { 
       clear; whilenot [\n]; cap;
       replace ">" "&gt;"; replace "<" "&lt;";
       replace "Pep and Nom" "Pep & Nom";
       replace " nom " " nom ";
       replace " pep " " pep ";
       replace " pep/nom " " pep/nom ";
       put; clear;
       add "<!-- ------------------------------- -->\n";
       add "<h2>"; get; add "</h2>\n"; put; clear;
       add "text*"; push; .reparse
     }
     "###" { 
       clear; whilenot [\n]; cap;
       replace ">" "&gt;"; replace "<" "&lt;";
       replace "Pep and Nom" "Pep & Nom";
       replace " nom " " nom ";
       replace " pep " " pep ";
       replace " pep/nom " " pep/nom ";

       put; clear;
       add "<!-- ------------------------------- -->\n";
       add "<h3>"; get; add "</h3>\n"; put; clear;
       add "text*"; push; .reparse
     }

     # one line of code etc
     ">>" { 
       clear; whilenot [\n]; 
       replace ">" "&gt;"; replace "<" "&lt;";
       put; clear;
       add "<pre class='codeline'>\n"; get; 
       add "\n</pre>\n"; put; 
       clear; add "codeline*"; push; .reparse
     }

     # horizontal rules >--------  (> is already &gt;)
     B"&gt;---" {
       # ensure matches regex ">[-]{3,}"
       clop;clop;clop;clop; [-] {
         clear; add "<hr/>\n"; put;
         clear; add "text*"; push; .reparse
       }
     }

     # codeblocks begin with --- or ---- etc
     B"---".[-] {
       clear; until ",,,"; clip; clip; clip;
       replace ">" "&gt;"; replace "<" "&lt;";
       put; clear; add "<pre class='codeblock'>\n"; get; add "</pre>\n"; 
       put; clear; while [,]; clear;
       add "codeblock*"; push; .reparse
     }

     # need a nom codeblock for postprocessing to colourise
     # the nom code. 
     # nom codeblocks begin with ---+ or ----+ etc
     B"---".[-+].E"+" {
       clear; until ",,,"; clip; clip; clip;
       # > is used in the parse label so I want 
       # eg/nom.snippet.tohtml.pss to render it
       # replace ">" "&gt;"; 
       replace "<" "&lt;"; put; 
       clear; add "<pre class='nom-code'><code class='language-nom'>\n"; 
       get; add "</code></pre>\n"; 
       put; clear; while [,]; clear;
       add "codeblock*"; push; .reparse
     }

     # multiline quotes, start and end with 3 quotes """. Starting """ 
     # must be first on line. The only problem is that they can chew up the 
     # whole doc. This may be rendered with a big curly quote at the 
     # beginning. If this is preceded by a star line, then that is the 
     # author of the quotation. The html <blockquote> will be added later
     # during 2 grammar token parsing.
     B'"""' {
       clop; clop; clop; until '"""'; clip; clip; clip;
       replace ">" "&gt;"; replace "<" "&lt;";
       put; clear; 
       add "blockquote*"; push; .reparse
     }

   }
   clear; get;

   # force a line break with '>>' (but not first word on line), 
   # could be a way to imitate lists
   "&gt;&gt;" {
     # todo bug? need to clear; I dont know why this works
     clear; add "<br/>\n"; put; 
     clear; add "text*"; push; .reparse
   }

   # just some chess stuff, why not
   "[chess:king]","[chess:queen]","[chess:rook]" {
     clip; clop; replace "chess:" "";
     replace "king" "<span class='chess-piece'>‚ôö</span>"; 
     replace "queen" "<span class='chess-piece'>‚ôõ</span>"; 
     replace "rook" "<span class='chess-piece'>‚ôú</span>"; 
     put; clear;
     add "<big><abbr class='chess-piece'>"; get; add "</abbr></big>";
     put; clear; add "text*"; push; .reparse 
   }

   # insert links to the good nom translation scripts 
   "[nom:translation.links]" {
     clear;
     add "
       <a href='/tr/nom.torust.pss' 
          title='nom to rust translation script'>rust</a> |
       <a href='/tr/nom.todart.pss' 
          title='nom to dart translation script'>dart</a> |
       <a href='/tr/nom.toperl.pss' 
          title='nom to perl translation script'>perl</a> |
       <a href='/tr/nom.tolua.pss' 
          title='nom to lua translation script'>lua</a> |
       <a href='/tr/translate.go.pss' 
          title='nom to go translation script'>go</a> |
       <a href='/tr/nom.tojava.doc.html' 
          title='nom to java translation script'>java</a> |
       <a href='/tr/translate.js.pss' 
          title='nom to javascript translation script'>javascript</a> |
       <a href='/tr/translate.ruby.pss' 
          title='nom to ruby translation script'>ruby</a> |
       <a href='/tr/translate.python.pss' 
          title='nom to python translation script'>python</a> |
       <a href='/tr/translate.tcl.pss' 
          title='nom to python translation script'>tcl</a> |
       <a href='/tr/translate.c.pss' 
          title='nom to c translation script'>c</a>
       ";
     put; clear; add "text*"; push; .reparse 
   }

   # todo: some "etymological word": for example 
   # [heuristic] -- insert the greek derivation and the explanation
   #  eg: from 'today' that which we learn each day
   # [idiot] from greek 'private' 
   #  these words would be good as "footnotes" maybe 

   "[cryptic]","[heuristic]","[idiot]","[epistemology]" {
     clip; clop; put; clear;
     add "<abbr class='etymology' \n";
     add "      title='##'>"; get; add "</abbr>";
     swap;
     "cryptic" { swap; replace "##" "hidden: from latin 'cryptus'"; }
     "heuristic" { swap; replace "##" " Œµ·ΩëœÅŒØœÉŒ∫œâ: what is found."; }
     "epistemology" { 
       swap; replace "##" " ·ºêœÄŒπœÉœÑŒÆŒºŒ∑: theory of knowledge "; }
     "idiot" { swap; replace "##" " ·º∞Œ¥ŒπœéœÑŒ∑œÇ: private citizen"; }
     put; clear; add "text*"; push; .reparse 
   }

   # sort of tech terms that aren't acronyms...
   #  do <stdin> <stdout> ?
   "[stdin]","[stdout]","[malloc]","[realloc]" {
     clip; clop; put; clear;
     add "\n";
     add "<abbr class='tek-acronym' \n";
     add "      title='##'>"; get; add "</abbr>";
     swap; 
     # put < > around these terms 
     "stdin" { swap; replace "##" "standard input stream"; }
     "stdout" { swap; replace "##" "standard output stream"; }
     "malloc" { swap; replace "##" "c memory allocation torture"; }
     "realloc" { swap; replace "##" "more c memory torture"; }
     put; clear; add "text*"; push; .reparse 
   }

   # some explanatory "titles" (tooltips) for acronyms ?
   # a less verbose way, also do <stdin> <stdout> ?
   "[html]","[csv]","[ast]","[bnf]","[ebnf]","[xbnf]",
   "[pep]","[nom]","[json]","[html]","[xml]","[http]","[gnu]",
   "[rfc]", "[faq]","[man]","[awk]","[sed]","[grep]",
   "[groff]","[eqn]","[lisp]","[latex]",
   "[forth]","[unix]","[linux]","[minix]","[vim]",
   "[java]","[c++]","[python]","[perl]","[awk]",
   "[lua]","[wren]","[logo]","[go]","[dart]","[rust]","[tcl]",
   "[antlr]","[gcc]","[tcc]","[utf8]","[utf16]","[unicode]",
   "[eof]","[bash]","[markdown]" {
     clip; clop; 
     upper; put; clear;
     add "\n";
     add "<abbr class='tek-acronym' \n";
     add "      title='##'>"; get; add "</abbr>";
     replace "NOM" "NOM";
     replace "PEP" "PEP";
     # a silly attempt at the LATEX logo
     replace "LATEX" "L<sup><small>A</small></sup>T<sub>E</sub>X";
     swap; 
     "HTML" { swap; replace "##" "Hyper-text Markup Language"; }
     "CSV" { swap; replace "##" "Comma Separate Values"; }
     "PEP" { swap; replace "##" "Parsing Engine for Patterns"; }
     "AST" { swap; replace "##" "Abstract Syntax Tree"; }
     "BNF" { swap; replace "##" "Backus-Naur Form"; }
     "EBNF" { swap; replace "##" "Extended Backus-Naur Form"; }
     "XBNF" { swap; replace "##" "Any random BNF format"; }
     "NOM" { swap; replace "##" "Nom Parsing Language"; }
     "JSON" { swap; replace "##" "Javascript object notation"; }
     "HTML" { swap; replace "##" "Hyper-text Markup Language, aka tag soup"; }
     "XML" { swap; replace "##" "Extensible Markup Language"; }
     "HTTP" { swap; replace "##" "Hyper-text Transport Protocol"; }
     "GNU" { swap; replace "##" "Gnu is not Unix, silly acronym."; }
     "RFC" { swap; replace "##" "Request For Comments"; }
     "FAQ" { swap; replace "##" "Frequently Asked Questions"; }
     "MAN" { swap; replace "##" "Unix Manual (Doc) Pages"; }
     "AWK" { swap; replace "##" "AWK Programming language"; }
     "SED" { swap; replace "##" "Text Stream Editor"; }
     "GREP" { swap; replace "##" "Search Text Files: g/regex/p"; }
     "GROFF" { swap; replace "##" "Old unix typesetting system"; }
     "EQN" { swap; replace "##" "Old unix formula typesetting system"; }
     "LISP" { swap; replace "##" "List Processing Language"; }
     "LATEX" { 
       # a silly attempt at the LATEX logo
       replace "A" "<sup><small>A</small></sup>";
       replace "E" "<sub>E</sub>";
       swap; replace "##" "The LaTeX text processing system"; 
     }
     "FORTH" { swap; replace "##" "The Incomparable Forth 'Language'"; }
     "UNIX" { swap; replace "##" "The Unix Operating System"; }
     "LINUX" { swap; replace "##" "The successor to minix"; }
     "MINIX" { swap; replace "##" "The Minix Minimal Unix Operating System"; }
     "VIM" { swap; replace "##" "Vi Improved Text Editor"; }
     "JAVA" { swap; replace "##" "Java Programming Language"; }
     "C++" { swap; replace "##" "Object-Oriented C"; }
     "LUA" { swap; replace "##" "An embeddable script language"; }
     "WREN" { swap; replace "##" "R. Nystrom's language"; }
     "PYTHON" { swap; replace "##" "A strangely popular indent language"; }
     "PERL" { swap; replace "##" "Larry Wall's shell script language"; }
     "AWK" { swap; replace "##" "Text-data processing mini-language"; }
     "LOGO" { swap; replace "##" "The turtle drawing language"; }
     "GO" { swap; replace "##" "Google's C Language Replacement"; }
     "RUST" { swap; replace "##" "The Rust System Language (c-ish)"; }
     "DART" { swap; replace "##" "Google's Application Language"; }
     "TCL" { swap; replace "##" "Tool Control Language"; }
     "ANTLR" { swap; replace "##" "Another Tool for Language Recognition"; }
     "GCC" { swap; replace "##" "The Gnu C Compiler"; }
     "TCC" { swap; replace "##" "Bellard's Tiny C Compiler"; }
     "UTF8" { swap; replace "##" "Unicode Text Format 8"; }
     "UTF16" { swap; replace "##" "Unicode Text Format 16"; }
     "UNICODE" { swap; replace "##" "The Universal Language Code"; }
     "EOF" { swap; replace "##" "End-Of-File (input-stream)"; }
     "BASH" { swap; replace "##" "Unix [B]ourne [A]gain [Sh]ell"; }
     "MARKDOWN" { swap; replace "##" "non-distracting text documents"; }

     put; clear; add "text*"; push; .reparse 
   }

   # urls, we need to add html formatting later because of the
   # "text" http://dada.org syntax There are a lot of "fake" schemas 
   # here for convenience.
   B"rosetta:",B"urbandict:",B"oed:",B"wp:",B"nom:",B"nomsyn:",
   B"nomsf:",B"pep:",B"http://",B"https://",B"nntp://",B"file://",B"www." {
     !"rosetta:".!"urbandict:".!"oed:".!"wp:".!"nom:".
     !"nomsyn:".!"nomsf:".!"pep:".!"http://".!"https://".
     !"nntp://".!"file://".!"www." {
       B"file://" {
         replace "file://" ""; put; 
       }
       # make the fake schema wp:// or wp: wikipedia links after wp:// should
       # just be the wikipedia page name

       # better to parse this in the E"url*".!"url*" block so that 
       # we can make a nice visible link text for the wikipedia page.
       # ie. do the same as the nom:// fake url
       B"wp:" {
         clop; clop; clop; B"//" { clop; clop; }
         # I dont like writing underscores
         replace "." "_"; put; clear;
         add "https://en.wikipedia.org/wiki/"; get; put; 
       }

       # schema for oed eg oed:// with search
       # oxford english dictionary
       B"oed:" {
         # allow trailing dot or comma
         E".",E"," { clip; } 
         !B"oed://" { replace "oed:" "oed://"; }
         put;
       }

       #add "https://www.oed.com/search/dictionary/?scope=Entries&q=";

       # schema for the urban dictionary, just because it can be fun,
       # and anyway, nom is a language thing, and we like language.
       # this should be parse in quoted*url* etc
       B"urbandict:" {
         # allow trailing dot or comma
         E".",E"," { clip; } 
         !B"urbandict://" { replace "urbandict:" "urbandict://"; }
         put;  
       }

       # rosettacode.org problems
       B"rosetta:" {
         # allow trailing dot or comma
         E".",E"," { clip; } 
         !B"rosetta://" { replace "rosetta:" "rosetta://"; }
         replace "." "_"; put;  
       }

       # add "https://www.urbandictionary.com/define.php?term=";
       # this is just a convenience so I dont have to type out the url
       # to the pep/nom sourceforge site everytime
       B"nomsf:",B"nomsf://" {
         E".",E"," { clip; }  # allow trailing ./,
         replace "nomsf:" ""; B"//" { clop; clop; }
         put; clear; add "https://bumble.sf.net/books/pars/";
         get; put;
       }

       # convenience schema, this time for nom language commands 
       # eg: push pop get put
       B"nom:" {
         # allow trailing dot or comma
         E".",E"," { clip; } 
         # add the url later, much easier.
         !B"nom://" { replace "nom:" "nom://"; }
         put;  
       }
       # another convenience schema, nom syntax documentation
       # eg: blocks, tests, parselabel 
       B"nomsyn:" {
         # add the url later, much easier.
         !B"nomsyn://" { replace "nomsyn:" "nomsyn://"; }
         put;  
       }

       # pep virtual machine structure eg: stack, tape, peep 
       B"pep:" {
         E".",E"," { clip; }  # allow trailing ./,
         !B"pep://" { replace "pep:" "pep://"; }
         put; clear; 
       }

       # add a schema to www. urls
       B"www." { clear; add "http://"; get; put; }
       clear; add "url*"; push; .reparse
     }
   }

   # a fake uri schema syntax eg google:"pratt parsers"
   # --> https://www.google.com/search?q=distance+colombia+to+tasmania
   # this is separate to the code above because it has to read ahead
   # in the input stream
   B"google:",B"google://" {
      replace "google://" "";
      replace "google:" ""; 
      # read until next " or newline
      B'"' {
        clop; whilenot [\n"]; 
        #replace ">" "&gt;"; replace "<" "&lt;";
        replace " " "+"; put; clear;
        add "https://www.google.com/search?q="; get;
        put; clear;
        !(eof) { read; [\n] { zero; nochars; } }
        clear;
        add "url*"; push; .reparse
      }
   }

   # local files with no schema, imagefile tokens have already been parsed
   E".h",E".c",E".a",E".txt",E".doc",E".py",E".rb",E".rs",E".java",E".class",
   E".xml",E".json",
   E".tcl",E".tk",E".sw",E".js",E".go",E".pp",E".pss",E".cpp",E".pl",
   E".html",E".pdf",E".tex",E".sh",E".css",E".out",E".log",
   E".png",E".jpg",E".jpeg",E".bmp",
   E".mp3",E".wav",E".aux",
   E".tar",E".gz",E"/" {
     # not very elegant all this. maybe an ee test would be good 
     # (begins with but not equal to) or change the delim to . and push
     !".h",!".c",!".a",!".txt",!".doc",!".py",!".rb",!".rs",!".java",!".class",
     !".xml",!".json",
     !".tcl",!".tk",!".sw",!".js",!".go",!".pp",!".pss",!".cpp",!".pl",
     !".html",!".pdf",!".tex",!".sh",!".css",!".out",!".log",
     !".png",!".jpg",!".jpeg",!".bmp",
     !".mp3",!".wav",!".aux",
     !".tar",!".gz",!"/" {
       # just automatically link filename beginning with /
       # because they are probably weblinks
       B"/" { clear; add "url*"; push; .reparse }
       !B"http://".!B"https://".!B"nntp://".!B"file://".!B"www." {
         clear; add "file*"; push; .reparse
       }
     }
   }

   # multiple words quoted text,eg: "sych mor", maximum one line 
   B'"'.!'"'.!'""'.!'"""'.!E'"' {
     # single quoted word with trailing . or , etc. This can't be part
     # of a URL link 
     E'",',E'".',E'"!',E'":' {
       # leave the trailing ,.:! etc and use replace
       clop; 
       replace ">" "&gt;"; replace "<" "&lt;";
       replace '",' "&rdquo;,"; replace '".' "&rdquo;.";
       replace '"!' "&rdquo;!"; replace '":' "&rdquo;:";
       put; 
       clear; add "&ldquo;"; get; add "\n"; put; 
       clear; add "text*"; push; .reparse
     }

     clop; whilenot [\n"]; 
     replace ">" "&gt;"; replace "<" "&lt;";
     put; clear;
     # The code below is not great, but is required because we
     # dont have "until 'ab','cd','ef'" syntax. ie multiple end delimiters
     # all this is to prevent multiline quotes (which could eat up the 
     # whole document.
     !(eof) { read; [\n] { zero; nochars; } }
     clear;
     add "quoted*"; push; .reparse
   }

   # single quoted word, multiline quotes (blockquotes) may begin with
   # """. These can be the link text for a hyperlink which is why I do
   # not format them immediately.
   B'"'.!'"'.!'""'.!'"""'.E'"' {
     clip; clop; 
     replace ">" "&gt;"; replace "<" "&lt;";
     put; clear;
     add "quoted*"; push; .reparse
   }

   # or B'**'.![*] ? 
   B'**'.!'**'.!'****'.!"***" {
     # single bold emphasised word eg: **strong**
     E'**' {
       clip; clip; clop; clop;
       replace ">" "&gt;"; replace "<" "&lt;";
       put; clear;
       add "<strong><em>"; get; add "</em></strong>\n"; put; clear;
       add "text*"; push; .reparse
     }
     # single bold emphasised word with trailing , or .
     E'**,',E'**.' {
       clop; clop;
       replace ">" "&gt;"; replace "<" "&lt;";
       replace "**." "</em></strong>.";
       replace "**," "</em></strong>,";
       add "\n"; put; 
       clear; add "<strong><em>"; get; put; 
       clear; add "text*"; push; .reparse
     }
   }

   # bold emphasised multi-word text between **double asterixes**
   # single line maximum, multiple words
   B"**" {
     clop; clop; whilenot [\n*]; 
     # find the next * if its there. This is clumsy code because we
     # cant say "until '**','\n';" which would be better
     # actually this code accepts ** text* with only one terminating 
     # asterix, but its not important. It's a text format...

     replace ">" "&gt;"; replace "<" "&lt;";
     put; clear;
     add "<strong><em>"; get; add "</em></strong>\n"; put; clear;
     # If there is some emphasised text immediately on the next line
     # this will not be good, but we aren't flying an aeroplane.
     while [*]; clear;
     add "text*"; push; .reparse
   }

   # emphasised italic text between *two asterixes*
   # single line maximum, multiple words
   B"*".!"*".!E"*" {
     # single emphasised word, with trailing ,. etc
     E'*,',E'*.' {
       clop; 
       replace ">" "&gt;"; replace "<" "&lt;";
       replace "*." "</em>."; replace "*," "</em>,";
       add "\n"; put; 
       clear; add "<em>"; get; put; 
       clear; add "text*"; push; .reparse
     }

     clop; whilenot [\n*]; 
     replace ">" "&gt;"; replace "<" "&lt;";
     put; clear;
     add "<em>"; get; add "</em>"; put; clear;
     # could i just use "while [*];" here?
     !(eof) { read; [\n] { zero; nochars; } }
     clear;
     add "text*"; push; .reparse
   }

   # single emphasised word, no special grammar token needed.
   B'*'.!'*'.!'**' {
     E'*' {
       clip; clop; 
       replace ">" "&gt;"; replace "<" "&lt;";
       put; clear;
       add "<em>"; get; add "</em>"; put; clear;
       add "text*"; push; .reparse
     }

   }

   clear; add "word*"; push;

 }

 !"" {
   clear;
   # just delete weird characters, we don't need them.
   # but probably should investigate further
   #*
   add "! An unexpected character '"; get; add "'";
   add "  in text input was encountered at \n";
   add "  line "; lines; add " char "; chars; add "\n";
   add "  Check the 'lexical parsing' phase of the script \n";
   add "    pars/eg/text.tohtml.pss ";
   add "  This is the section of the script above the parse> label \n";
   print; quit;
   *#
 }

parse>

 # for debugging
 # add "<!-- line "; lines; add " char "; chars; add ": "; print; clear; 
 # unstack; print; stack; add " -->\n"; print; clear;


 # ----------------
 # the error and help system
 pop;

 #*
  error and help tokens which allow implementing a help system
  that can be triggered by an empty document or by help keywords
 *#
 "error*" {
   # maybe get the parse stack here as well
   clear; 
   add "The text-to-html script:";
   # add " near line:"; lines; add " char:"; chars; add "\n";
   get; add "\n"; print;
   clear; pop; "help*" { push; .reparse } 
   # he help* token also quits
   quit;
 }

 #*
  using a parse help token to display help for a topic, category of 
  topics or everthing. This is a very useful system because it allows
  the language parser/compiler to document its own syntax, and also
  it allows the nom script to implement some "help" commands so
  that the language user can refresh his or her memory about how the 
  language works.

  The swap commands below are used to save the help text in the tape
  cell so that several or all help topics can be printed at once.

 *#

 "help*" {
   # wrap it all in an html comment?.  
   clear; swap; 
   
   # how to use this script
   "usage","help","all" {
     swap; add "
   USAGE
     pep -f text.tohtml.pss file.txt
     pep -f text.tohtml.pss -i 'text' 
     pep -f text.tohtml.pss -i '/<helpword>'

     A nom script to transform a text document into an HTML fragment
     suitable for including in a webpage.
     ";
     swap;
   }

   # help about the help-system
   "words","about","help" {
     swap; add "
   HELP KEYWORDS

     All text documents/input which begin with '/' are considered to be help 
     requests. See below for the list of valid help keywords.

     pep -f text.tohtml.pss -i /<helpword> 
       see some help for that topic or category

     pep -f text.tohtml.pss -i /all
       see all the help.

     pep -f text.tohtml.pss -i /helpwords
       see what help topics and categories are available 

     pep -f text.tohtml.pss -i /toperl | bash
       translate this script to perl 
       
   ### General Help 

     - /usage: show a usage message for this script 
     - /words: show what help commands are available
     - /faq: show some (not!) frequently-asked questions about this script.
     - /nom: show information about the nom script language

   ### This plain text format 

     - /code: including code lines and blocks with a description.
     - /lists: how to include an unordered list 
     - /images: including and fomatting images in the output 
     - /links: show information about the text link format
     - /headings: info about text heading format.
      
   ### translating and testing the script

     - /translate: show how to translate this script to another language
     - /to<lang>: translate this script to some other language
     - /eg.lines: display a list of one line input to the script
     - /eg: display an example input document
     - /test.line: test one line of input from the 
     - /test.eg: translate the example document to html 
     - /test.eg.open: create a page with example and open 
     - /test/<text-file>: test the given text file as input and display

     There are also help 'categories' which display several help
     topics at once such as:

     - /help: all script help
     - /about: about the script and usage
     - /format: all information about the plain text format including images,
              links, lists, etc

     ";
     swap;
   }

   # the faq 
   "faq","joke","all" {
     swap; add "
   FAQ
     (not) frequently asked questions about /eg/text.tohtml.pss

     Q: What is the purpose of this script?
     A: To format a plain text document as HTML

     Q: Is the format 'markdown'?
     A: No, sorry, I invented my own format. If you want to know more about
        the format try the /format help word, for example just type
        >> pep -f text.tohtml.pss /format
     
     Q: (groan) Why?? There are already so many of these 'lightweight
        markup languages. eg: markdown, asciidoc, mediawiki format, 
        textile. Why on earth would you invent another one?
     A: Well, I like writing in my own format, so I just invented my
        own. It's no big deal.

     Q: where can I see more information about this text format?
     A: www.nomlang.org/eg/text.tohtml.format.html or use the /format
        help word with this script.

     Q: OK, and what is this strange language the script is written in?
     A: Its called pep:nom or just 'nom' and its the best thing since 
        sliced cheese but I could be the only one who uses it in the whole
        wide world (I also invented it and implemented it, I should 
        un-humblebrag). Its sort of like *sed* (the unix stream-editor) but
        for context-free and (some) context-sensitive languages.

     Q: Why is it so good?
     A: Because it is more powerful that Large-Language-Models. Potentially.
        Maybe. Anyway, it allows you to think about patterns as patterns.
        And it can do useful things like detect palindromes in text.

     Q: It looks pretty cryptic. How am I supposed to know how the language 
        works?
     A: You could try reading www.nomlang.org . The syntax is pretty similar
        to *sed* but there are no regular expressions, and commands can have 
        word-names as well as single letter-names.

     Q: Why is there an FAQ and other docs inside of a text-formatting script?
     A: Because I like the idea of 'self-documenting' things. Maybe its like 
        'literate programming' or maybe its just a good way to remind myself
        what I was doing three nights ago.
        
     Q: Can I translate this pep:nom script to some other language?
     A: Absolutely. Type the /translate help-word for more 
        information, or have a look at www.nomlang.org/tr/ 

     Q: This script seems to have a lot of markup formats that are only
        relevant to the nom language. Can I use it for a normal text document?
     A: Yes, just dont use the formats related to nom (such as the nom:// and 
        pep:// fake url schemas for example)

     Q: What if I want to begin my document with a / character?
     A: Just dont. If you do, the script will think that its a help-keyword.

     Q: Thats a terrible limitation.
     A: In the next life you are coming back as a Javanese construction worker.

     Q: Why does nobody use 'nom' except you?
     A: Maybe they dont know about it. I dont know. Maybe they have better 
        things to do with their time.

     Q: How do I make a list?
     A: A dash - starting a line, followed by a space. End the list with 
        a blank line

     Q: What about nested lists?
     A: Come on! Do you really need that? There is a thing called 'pandoc' 
        written by some ivy-league philosophy professor that does everything.
        (œÄ·æ∂ŒΩ is Greek for 'everything'). Try that if you feel unhappy.
     
     Q: Why don't you like Markdown?
     A: I just don't like the way it looks and also I don't like being 
        forced to indent things if I don't want to.

     Q: This script seems to translate itself to other languages like 
        perl/lua/rust using the /to<lang> helpwords. Is this sensible?
        Why does an html renderer script need to translate itself to another
        language?
     A: Well, I think its an interesting idea, and it sort of showcases how
        Nom can translate itself and then use the translated translator to 
        translate the translator.

     Q: Thats silly. Why bother?
     A: Well, if you wan't an text-to-html thingy on a webserver and the 
        only thing that server has available are Perl CGI scripts, then
        you can just do: pep -f text.tohtml.pss -i /toperl and voila, you
        have your perl html formatter.

     Q: Perl CGI Scripts? What is that, anyway?
     A: Well its an old thing. But anyway, my point stands.

     Q: Are you going to make every nom script be able to translate itself
        into every format ever invented?
     A: No, but its a bit like putting these FAQs into nom scripts: its sort
        of fun. And it gets another weird piece of self-referentiality 
        happening, because we can use the help system to output some text
        in my dodgy markup/down format and then feed that into the 
        translated translator in order to test the whole process. Namely
        >> pep -f text.tohtml.pss -i /all | ./texttohtml.<lang>
        In fact that is exactly what the words /try<lang> do. They try 
        out the recently minted translated script that you just created 
        with /to<lang>

     Q: Isn't this all going a bit far? Aren't you just going to confuse 
        yourself?
     A: Possibly, but its quite nice to have all the docs and translators
        right where you need them, in the actual script itself. We could 
        keep going, and make script able to render themselves into 
        pdf or postscript or man pages or whatever.

     Q: Are you going to put an FAQ in every nom script you write?
     A: Why not? Its the Socratic dialectic method.
     
     ";
     swap;
   }
      
   # more information about the nom language 
   "nom","about","all" {
     swap; add "
       This script is written in pep:nom.
       Nom is a scripting language for parsing/translating context-free and 
       (some) context-sensitive patterns. Please see www.nomlang.org for
       (much) more information.
     ";
     swap;
   }

   #*
   # fix: another seq fault!!
   # 
   "eg","help" {
     swap; add '
     # some example input
     file link: /eg/tocfoot.tohtml.pss
     See the /tr/ folder
     folder link with text: "translations" /tr/
     nom command link with text: "translations" nom://add
     file names: eg/palindrome.pss file.txt
     ';
     replace "\n   " "\n";
     swap;
   }
   *#

   # 
   "eg.lines","help" {
     swap; add '
     # some example lines for testing the script
     file link: /eg/tocfoot.tohtml.pss
     See the /tr/ folder
     folder link with text: "translations" /tr/
     nom command link with text: "translations" nom://add
     file names: eg/palindrome.pss file.txt
     ';
     replace "\n   " "\n";
     swap;
   }

   # probably not useful here, since all text documents should 
   # parse, one way or another
   "eg.bad.lines" { swap; add " "; swap; }

   # tests one line with this text-to-html converter script. 
   "test.line" {
     swap; add "
       # TESTING SOME RANDOM (one-line) TEXT INPUT
       doc=$(pep -f text.tohtml.pss -i /eg.lines | \\
         sed '/^ *#/d;/^ *$/d;' | shuf -n 1) 
       echo \"<!-- input: $doc -->\"
       pep -f text.tohtml.pss -i \"$doc\" 
       echo \"<!-- input: $doc -->\"
       # ------------------------
       # RUN THIS WITH:
       # pep -f text.tohtml.pss -i /test.line | bash
       ";
     replace "\n     " "\n";
     swap;
   }


   #*
   # fix: causing another seg fault
   # translate the example input to html
   "test.eg" {
     swap; add "
       # TESTING THE EXAMPLE DOCUMENT
       pep -f text.tohtml.pss -i /eg | bash > test.txt
       pep -f text.tohtml.pss test.txt
       # ------------------------
       # RUN THIS WITH:
       # pep -f text.tohtml.pss -i /test.eg | bash
     \n";
     replace "\n    " "\n";
     print; quit;
   }
   *#

   # make the html file with the example document and open 
   "test.eg.open" {
     swap; 
      add "
        # TESTING INPUT from the file '"; get; add "'
        echo -e \"
         <!DOCTYPE html>
         <html lang='en'>
         <head>
             <meta charset='UTF-8'>
             <title>Test www.nomlang.eg/eg/text.tohtml.pss</title>
         </head><bod> 
         \" > test.html 

        pep -f text.tohtml.pss test.txt >> test.html
        echo \"</body></html>\" >> test.html
        firefox test.html
        # ------------------------
        # RUN THIS WITH:
        # pep -f text.tohtml.pss -i '/test/ "; get; add "' | bash
        \n";
     replace "\n     " "\n";
     print; quit;
   }

    # tests one one-line invalid text, but maybe not useful here 
    "test.bad.line" {
      swap; add "
        # TESTING SOME RANDOM (one-line) BAD EXPRESSION
        doc=$(pep -f text.tohtml.pss -i /eg.bad.lines | \\
          sed '/^ *#/d;/^ *$/d;' | shuf -n 1) 
        echo \"test-line: $doc\"
        pep -f text.tohtml.pss -i \"$doc\" 
        # ------------------------
        # RUN THIS WITH:
        # pep -f text.tohtml.pss -i /test.bad.line | bash
        ";
      replace "\n     " "\n";
      print; quit;
    }

    # tests the script with the given input text file 
    B"test/" {
      clop; clop; clop; clop; clop;
      # fix: was? causing segmentation fault in pep
      "",[:space:] {
        add "No file name given to /test\n";
        add "eg: pep -f text.tohtml.pss -i '/test file.txt'\n";
        print; quit;
      }

      put; clear;
      add "
        # TESTING INPUT from the file '"; get; add "'
        echo -e \"
         <!DOCTYPE html>
         <html lang='en'>
         <head>
             <meta charset='UTF-8'>
             <title>Test www.nomlang.eg/eg/text.tohtml.pss</title>
         </head><bod> 
         \" > test.html 

        pep -f text.tohtml.pss "; get; add " >> test.html
        echo \"</body></html>\" >> test.html
        firefox test.html
        # ------------------------
        # RUN THIS WITH:
        # pep -f text.tohtml.pss -i '/test/ "; get; add "' | bash
        \n";
      replace "\n     " "\n";
      print; quit;
    }


   
   
   # This tests the (translated) html renderer that was already created 
   # with eg: pep -f text.tohtml.pss -i /tolua
   B"try" {
     E"perl",E"lua",E"javascript",E"ruby",E"python",E"tcl" {
       swap; add '
        script="texttohtml.<lang>"
        if [ -f $script ]; then
          echo -e "<!-- Found script: $script -->"
        else
          echo -e "
           Could not find script: texttohtml.<lang>
           try to create the (translated) text-to-html script/exe with:
           >> pep -f text.tohtml.pss -i /to<lang> 
           and then run this again
           "
          exit 1;
        fi
        if command -v <lang> &> /dev/null
        then
          echo "<!-- <lang> interpreter was found -->"
        else
          echo "No <lang> interpreter was found!"
          exit;
        fi
        pep -f text.tohtml.pss -i /all | ./$script
        # echo "Created file {$outfile} (a text-to-html formatter in <lang>)"
       ';
       swap;
       # causing segmentation fault not sure why!!! It seems to 
       # be caused by length of E list
       # If I add any extra braces to this block I get a segfault,
       # but I can add other commands without a problem.
       # eg: (==) { add "."; } gives seg fault.
       # fix:

       E"perl" { swap; replace "<lang>" "perl"; swap; }
       E"lua" { swap; replace "<lang>" "lua"; swap; }
       E"ruby" { swap; replace "<lang>" "ruby"; swap; }
       E"python" { swap; replace "<lang>" "python"; swap; }
       E"tcl" { swap; replace "<lang>" "tcl"; swap; }
       # E"javascript" { swap; replace "<lang>" "javascript"; swap; }

     }
   }
   #

   # it is possible to pipe this to bash in order 
   # to automatically translate to perl.  This is an idea that could form
   # the incipient seedling of the TLM the tiny-language-model which is 
   # a way of discussing nom with nom.

   # just call the /eg/nom.to.pss script which does translation from
   # a simple command like 'translate text.tohtml.pss to ruby'
   # >> pep -f text.tohtml.pss -i /to<lang> | bash
   B"to" {
     clop; clop; put; clear;
     add '
      # run this with
      #   pep -f text.tohtml.pss -i /to<lang> | bash
      translator=${PEPNOM}/eg/nom.to.pss
      if [ -f $translator ]; then
        echo -e "[ok] Found translator script: $translator"
      else
        echo -e "
         [error] did not find translator: ${PEPNOM}/eg/nom.to.pss
         (maybe) set the $PEPNOM environment var
         (or)    download the translator from www.nomlang.org/eg/ 
         ";
        exit 1;
      fi
      pep -f $translator -i "translate text.tohtml.pss to '; get; add '"';
      add ' | bash\n';

      replace "\n    " "\n";
      print;
      quit;
   }

   # how to translate this script to another language, 
   "translate","tr","about","all" {
     swap; add "

    HOW TO TRANSLATE THIS SCRIPT

      
      This script can be translated to other languages using nom 
      translation scripts which are available at www.nomlang.org/tr/
    
      * translate this script to ruby
      >> pep -f text.tohtml.pss -i /toruby

      Currently nom scripts can be translated into the following languages.
        rust|dart|perl|lua|go|java|javascript|ruby|python|tcl|c      
      Some of the translators are better than others. The translators are 
      all nom scripts, and they can translate themselves (!?)
      
      Also, any nom script can be translated to another language 
      with the /eg/nom.to.pss script for example

      * translate this script to rust with nom.to.pss
      >> pep -f nom.to.pss -i 'translate text.tohtml.pss to rust'

      Below, I show how to translate scripts 'by hand' using the 
      translation scripts in the www.nomlang.org/tr/ folder.

      * translate this script to rust, compile and run (needs 'rustc')
      ---
        pep -f tr/nom.torust.pss text.tohtml.pss > text.tohtml.rs
        rustc -o texttohtml.exe texttohtml.rs
        echo ' some *strong* text ' | ./texttohtml.exe 
      ,,,

      * translate a script to perl, and run with 'doc.txt' as input
      ---
        pep -f nom.toperl.pss text.tohtml.pss > test.pl 
        chmod +x test.pl
        cat doc.txt | ./test.pl
      ,,,

     ";
     swap;
   }

   "textstyle","format","all" {
     swap; add "
    TEXT STYLES 
      - italic: *make bold with asterisks* 
      - bold-italic: **make bold with asterisks**

     ";
     swap;
     nop;
   }

   "images","format","all" {
     swap; add "
    IMAGE FORMAT

      Images can be included in the output document by using a quirky 
      format that I decided to invent. Elements can be omitted from the 
      image format. 

      Captions can be added to images by preceding the image with some double
      quoted text.
      
      * the image format
      >> <:corners:size:alignment:/path/name.ext>
     
      The options:
      - corners: R (big rounded corners) r (small rounded corners)
        o/O circular
      - alignment: centre=cc;float-left=<<;float-right=>> 
      - size: is a number from 1-9 indicating a fraction of the page width
      
      Examples:
 
        - <img.jpeg> An image with no specifications that will appear at
          is original size.
        - 'caption text' <img.jpg> an image with a caption underneath it.
        - <:o:4:image/doodle.horse.duck.swirl.300.jpg>
          20em width, default float
        - and

     ";
     swap;
   }

   "code","format","all" {
     swap; add "

    CODE FORMAT

     Computer code or some other pre-formatted text can be included in
     the text document with the delimiters *>>* (starting the line and 
     delimiting only one line of code) or *---* and *,,,* (or *----* *,,,,,*
     etc.) which delimit a block of code or pre-formatted text.
     
     If the code block or code line is preceded by a line starting with
     an asterisk (*) then that line will be formatted as a description of 
     the following code. This is an advantage of using a parsing language 
     like pep/nom to format the html because elements can be parsed together
     which would be tricky or impossible with regular expressions.

     Below are some examples of one code documentation.

     * run a one line nom script
     >> pep -e 'read; print; clear;' -i 'abcd'

     * a nom script that deletes whitespace
     ---
       read; [:space:] { clear; }
       print;
     ,,,

     The nom script /eg/nom.snippet.tohtml.pss will also colourise nom
     code which is between *---+* and *,,,* delimiters.

     ";
     swap;
   }

   "lists","format","all" {
     swap; add "
    LIST FORMAT

      Lists (unordered) are indicated by a dash '- ' starting a line. The dash 
      needs to be followed by at least one space (This is because this 
      script uses a word-by-word parsing technique, and words are delimited
      by white-space). Lists are terminated by an empty line. Lists cannot
      contain sublists. 

       - Markdown: this items can contain other elements such as 
          links.
       - Asciidoc
       - Perldoc
       - Textile
       
     ";
     swap;
   }

   # display help about the links format. 
   # The category of help is 'format'
   "links","format","all" {
     swap; add '

    LINK FORMAT

      With all the link formats it is possible to precede the link with
      some double quoted text which will become the display text for 
      that link.

      - "text" schema://url any double quoted text followed by one of the 
        following patterns will become link with the given display text.
      - /path/file.ext links to a file on the server 
      - link:// or file:// does the same as above 
      - http:// https:// nntp:// link to these urls
      - www.dom.ext/path links to the url
      - urbandict:// links to the urban dictionary 
      - rosetta:// links a problem on the rosetta-code.org site 
      - oed:// or oed: links to the oxford english dictionary 
      - wp:// or wp: links to wikipedia, (dots become _)
      - google://"some text" or google:"some text" creates a link to the 
        results of a google search for "some text"
      - rosetta:// or rosetta: link to a particular problem on the 
        rosetta code site.

    SPECIAL NOM URLS

      There are also some special fake url schema to help in documenting
      the pep/nom system. These are only really of interest to me.

      - nom://<command> links to the documentation for the nom command  
        so nom://add will link to www.nomlang.org/doc/commands/add
      - nomsyn://<syntax-element> link the documentation for a particular
        aspect of nom syntax
      - nomsf:// make a link to the nom sourceforge site.
      - pep://<machine-register> link to documentation about a register
        in the machine. eg *pep://stack* will link to the documentation 
        about the pep:nom pep://stack 

     ';
     swap;
   }

   # document heading format.
   "headings","format","all" {
     swap; add "
    HEADINGS FORMAT

      Headings can be included in the document with the normal Markdown
      syntax of several hashes (# ## ### etc) which must start the line
      and be followed by a space. 
      
      Lines which are all capital letters will also be rendered as a 
      level-2 heading. 

      The script does not currently produce a table of contents.
      See /eg/tocfoot.tohtml.pss for how to do that.

     ";
     swap;
   }
   
   swap;
   "" {
     add "Help topic '/"; get; add "' not known\n";  
     add "Type: pep -f text.tohtml.pss -i /helpwords \n";
     add "  to see valid help keywords";
   }
   add "\n\n"; print; quit; 
 }

 push;
 # end of the error and help system.

 # -----------------
 # 2 tokens parse reductions
 pop; pop;

 # a list at the end of the document, with no blankline to
 # terminate it.
 (eof) {
   "item*text*" {
     push; push; add "</li>\n</ul>\n"; put; 
     clear; add "endlist*"; push; .reparse
   }
   # resolve upper case lines at the end of the file
   B"upper.heading*",E"upper.heading*" {
     replace "upper.heading*" "text*"; push; push; .reparse
   }
 }

 # starline*codeline* or starline*codeblock* is significant
 "starline*space*" {
    # dont really need this space
    clear; get; ++; get; --; put; clear;
    add "starline*"; push; .reparse
 }

 # This is another use for starline, as the "citation" or author
 # for a multiline quote ("""..."""). This has to go above here because
 # starlines are about to disappear
 E"blockquote*".!"blockquote*" {
   B"starline*" { 
     clear; 
     add "<blockquote class='quotation'>\n"; ++; get; --; 
     add "<cite>"; get; add "</cite>\n";
     add "</blockquote>\n"; 
     put; clear; add "text*"; push; .reparse
   }
   # blockquote with no citation, treat the unknown 1st token as 
   # text.
   clear; get;
   add "\n<blockquote class='quotation'>\n"; ++; get; --; 
   add "</blockquote>\n";
   put; clear; add "text*"; push; .reparse
 }

 # a caption followed by some code
 B"starline*".!"starline*" {
   E"codeline*",E"codeblock*" { 
     clear; 
     add "<figure class='code-with-caption'>\n";
     add "<figcaption class='code-caption'>\n";
     get; add "</figcaption>\n"; ++; get; --; add "</figure>";
     put; clear; add "text*"; push; .reparse
   }
   # format star-lines, then reduce to text (token no longer needed)
   replace "starline*" "text*"; push; push; 
   # state;
   --; --; add "<em class='starline'>\n"; get; add "\n</em>\n"; put; clear;
   # dont need to transfer attribute
   ++; ++; .reparse
 }

 # format and reduce image files, but the <img> tag has already
 # been built above so we can just add the figure and caption if 
 # required
 E"imagefile*".!"imagefile*" {
   # "link text" http://abc syntax
   B"quoted*" { 
     # the problem here is that <figure> needs to set the width 
     # and alignment not the image, but the <img> tag has already
     # been built. Maybe we can just accept that captioned images
     # are not going to look much good.
     clear; ++; get; 
     # check if image is floating left or right
     # a hack to get around no "contains" test eg C"float-right"
     replace "float-right" "";   
     !(==) {
       clear; add "\n<figure class='float-right'>\n  ";
     }
     (==) {
       clear; add "\n<figure class='float-left'>\n  ";
     }
     get; --;
     add "\n  <figcaption class='image-caption'>\n  "; get;  
     add "\n  </figcaption>"; 
     add "\n</figure>\n";
     put; clear; add "text*"; push; .reparse
   }
   # image with no caption 
   clear; get; ++; get; --; add "\n";
   put; clear; add "text*"; push; .reparse
 }

 # format and reduce urls
 E"url*" {
   # "link text" http://abc syntax
   B"quoted*" { 
     clear; ++; get; --;
     # deal with nom schema, nom: has been normalised to nom://
     # nom command filenames in format nom.<command>.txt

     B"oed://" {
       replace "oed://" ""; ++; put; clear;
       add "<a href='https://www.oed.com/search/dictionary/?scope=Entries&q=";
       get; --; add "' title='oxford english dictionary'>"; get; add "</a>";
       put; clear; add "text*"; push; .reparse
     }

     B"urbandict://" {
       replace "urbandict://" ""; ++; put; clear;
       add "<a href='https://www.urbandictionary.com/define.php?term=";
       get; --; add "' title='urban dictionary'>"; get; add "</a>";
       put; clear; add "text*"; push; .reparse
     }

     # the rosettacode.org problems 
     # eg https://rosettacode.org/wiki/Balanced_brackets
     B"rosetta://" {
       replace "rosetta://" ""; ++; put; clear;
       add "<a href='https://rosettacode.org/wiki/";
       get; --; add "' title='rosetta-code problem'>"; get; add "</a>";
       put; clear; add "text*"; push; .reparse
     }

     B"nom://" {
       # could I allow verb endings on the nom commands such as 
       # nom://pushing nom://pushes etc.? This would make writing about
       # the commands more natural, but I can just add a space.

       # save trailing char or suffix 2 cells up 
       # E"," { clip; ++; ++; swap; clear; add ","; swap; --; --; }
       # E")" { clip; ++; ++; swap; clear; add ")"; swap; --; --; }
       # if a nom command ends in 'ing' this will cause havoc
       # E"ing" { clip; clip; clip; ++; ++; swap; clear; add "ing"; swap; --; --; }
       replace "nom://" ""; ++; put; clear;
       add "<a title='nom command reference: "; get; add "'";
       add " href='http://nomlang.org/doc/commands/nom."; 
       get; --; add ".html'>"; get; add "</a>";
       # restore the saved trailing char or suffix
       # ++; ++; get; --; --;
       put; clear; add "text*"; push; .reparse
     }

     B"nomsyn://" {
       replace "nomsyn://" ""; ++; put; clear;
       add "<a title='nom syntax reference: "; get; add "'";
       add " href='http://nomlang.org/doc/syntax/nom.syntax."; 
       get; --; add ".html'>"; get; add "</a>";
       put; clear; add "text*"; push; .reparse
     }

     # pep machine filenames in format pep.<part>.txt
     B"pep://" {
       replace "pep://" ""; ++; put; clear;
       add "<a title='pep machine reference: "; get; add "'";
       add " href='http://nomlang.org/doc/machine/pep."; 
       get; --; add ".html'>"; get; add "</a>";
       put; clear; add "text*"; push; .reparse
     }
     # other "quote" url:// formats
     clear; 
     add "<a href='"; ++; get; --; add "'>"; get; add "</a>";
     put; clear; add "text*"; push; .reparse
   }
   # plain url link, add html link to text
   clear; ++; get; --;

   # make a nice link to the OED
   B"oed://" {
     replace "oed://" ""; 
     ++; put; --; clear;
     get; add "<a href='https://www.oed.com/search/dictionary/?scope=Entries&q=";
     ++; get; add "' title='oxford english dictionary'>"; get; add "</a>"; 
     --; put; clear; add "text*"; push; .reparse
   }

   # what about multiple words
   B"urbandict://" {
     replace "urbandict://" ""; 
     ++; put; --; clear;
     get; add "<a href='https://www.urbandictionary.com/define.php?term=";
     ++; get; add "' title='urban dictionary'>"; get; add "</a>"; 
     --; put; clear; add "text*"; push; .reparse
   }

   B"rosetta://" {
     replace "rosetta://" ""; 
     ++; put; --; clear;
     get; add "<a href='https://rosettacode.org/wiki/";
     ++; get; add "' title='rosetta-code problem'>"; get; add "</a>"; 
     --; put; clear; add "text*"; push; .reparse
   }

   B"nom://" {
     # is nom://-- valid? yes and also nom://minusminus 
     # mark this up as <code> because it is.
     replace "nom://" ""; 
     ++; put; --; clear; get; 
     add "<code class='nom-command'>";
     add "<a title='nom command reference: "; ++; get; add "'";
     add " href='http://nomlang.org/doc/commands/nom."; 
     get; add ".html'>"; 
     # allow nom://++ and nom://a+ syntax etc
     replace "++.html" "plusplus.html";
     replace "--.html" "minusminus.html";
     replace "a+.html" "aplus.html";
     replace "a-.html" "aminus.html";
     get; add "</a></code>"; 
     # allow nom://plusplus syntax etc (make visible link correct)
     replace "html'>plusplus" "html'>++";
     replace "html'>minusminus" "html'>--";
     replace "html'>aplus" "html'>a+";
     replace "html'>aminus" "html'>a-";
     replace "html'>reparse" "html'>.reparse";
     replace "html'>restart" "html'>.restart";
     --; put; clear; add "text*"; push; .reparse
   }

   B"nomsyn://" {
     replace "nomsyn://" ""; 
     ++; put; --; clear; get;
     add "<a title='nom syntax reference: "; ++; get; add "'";
     add " href='http://nomlang.org/doc/syntax/nom.syntax."; 
     get; add ".html'>"; 
     # allow nomsyn://parse> syntax etc, but > has already been
     # made into &gt; for html.
     replace "parse&gt;.html" "parselabel.html";
     replace "class.html" "classes.html";
     get; add "</a>"; 
     # allow nom://parselabel syntax etc (make visible link correct)
     replace "html'>parselabel" "html'>parse&gt;";
     --; put; clear; add "text*"; push; .reparse
   }

   B"pep://" {
     replace "pep://" ""; ++; put; --; clear; get;
     add "<a title='nom syntax reference: "; ++; get; add "'";
     add " href='http://nomlang.org/doc/machine/pep."; 
     get; add ".html'>"; get; add "</a>"; --;
     put; clear; add "text*"; push; .reparse
   }

   clear;
   get; add "<a href='"; ++; get; add "'>";
   swap;

   # make file links code-like
   B"/" {
     # save to next tape cell
     ++; put; 
     clear; add "<code>"; get; add "</code>";
     --;
   }

   # remove the https:// etc from the visible link because
   # they look ugly in the text.
   replace "https" ""; replace "http" ""; replace "nntp" "";
   replace "://" "";
   swap; get; add "</a>";
   --; put; clear; add "text*"; push; .reparse
 }

 # "text" file.txt syntax to be linked
 "quoted*file*" {
    clear; 
    add "<a href='"; ++; get; --; add "'>"; get; add "</a>";
    put; clear; add "text*"; push; .reparse
 }

 # reduce file* grammar tokens separately so we can html format them
 B"file*".!"file*" {
   replace "file*" "text*"; push; push; 
   --; --; add "<code>"; get; add "</code>"; put; ++; ++; clear;
   .reparse
 }

 # quoted*url* or quoted*file* is significant
 "quoted*space*" {
    clear; 
    get; ++; get; --; put; clear;
    add "quoted*"; push; .reparse
 }

 # reduce "quoted" separately so we can add some html curly quotes
 # the !"quoted*" clause is supposed to ensure 2 tokens (this should only
 # really be a problem if the "quoted" is the first word of the document)
 B"quoted*".!"quoted*" {
   !E"url*".!E"file*" {
     clear;
     # The quoted attribute may have a space (or many?) at the end
     # so need to put it after the curly quotes
     # add some html curly quotes and get saved space
     add "&ldquo;"; get; add "&rdquo;"; 
     # remove the space just before the last quote (which is added
     # during "space*" reductions.
     replace " &rdquo;" "&rdquo;"; 
     # add a space to separate from next word.
     add " ";
     ++; get; --; put; clear;
     add "text*"; push; .reparse
   }
 }
 
 # all capital lines are headings or ending with '....'
 "upper.heading*text*" {
   # check if following text is also uppercase 
   clear; ++; get; --; replace " " "";
   [A-Z] {
     clear; get; ++; get; --; put;
     clear; add "upper.heading*"; push; .reparse
   }
   # following text not upper so not a heading.
   clear; get; ++; get; --; put;
   clear; add "text*"; push; .reparse
 }

 # tokens to reduce to text
 # codeline, codeblock, word, text, space, quoted,
 #B"word*",B"text*",B"space*",B"quoted*",B"codeline*",B"codeblock*" {
 B"word*",B"text*",B"space*",B"codeline*",B"codeblock*" {
   # need to conserve quoted at end
   E"word*",E"text*",E"space*",E"codeline*",E"codeblock*" {
     # check that there really are 2 tokens (not one)
     push; !"" {
       pop;
       clear; get; ++; get; --; 
       # just playing with auto formatting of certain word
       # sequences.
       E"read command" {
         replace "read command" "<code class='nom-command'>read</code> command"; 
         replace "add command" "<code class='nom-command'>add</code> command"; 
       }
       put; clear;
       add "text*"; push; .reparse
     }
     pop;
   }
 }

 # -------------------
 # 3 token token reductions
 pop;

 # this is crazy reverse reduction
 "item*text*endlist*" {
   clear; get; ++; get; ++; get; --; --; put;
   clear; add "endlist*"; push; .reparse
 }

 # have reduced the whole list (in reverse) so just make text 
 # there could be 1,2, or 3 tokens here. need to get the endlist attribute
 # and add a start <ul> tag
 E"endlist*".!B"item*text*" {
    # more succinct way to get the last token when there is a variable
    # number of tokens. A clever trick.
    push; !"" { push; !"" { push; } } pop;
    clear; add "<!---- list ----->\n";
    add "<ul>"; get; replace "<ul></li>" "<ul>\n"; put; 
    clear; add "text*"; push; .reparse 
 }

 # sometimes we might get text*text*something* (eg in lists)
 B"text*text*".!"text*text*" {
   replace "text*text*" "text*"; push; push;
   --; --; get; ++; get; --; put; clear;
   # transfer unknown token attribute
   ++; ++; get; --; put; clear;
   # realign tape pointer
   ++; .reparse
 }

 push; push; push;

 (eof) {
   #*
   add "<!-- final stack: "; print; clear;
   unstack; add " -->\n"; print; clear;
   stack;
   add "<!-- html rendered by Nom script (www.nomlang.org): -->\n";
   add "<!--   www.nomlang.org/eg/text.tohtml.pss -->\n";
   add "<!--   pep -f eg/text.tohtml.pss file.txt -->\n";
   add "<!-- see eg/text.tohtml.format.txt for text format -->\n";
   print; clear;
   *#
   # print the rendered html
   pop; clear; get; 

   # causing seg fault with pep
   # !E"\n" { add "\n"; }
   add "\n";
   print; quit;
   # The html header and footer are made in pars/www/blog.sh
 }

